import datetime
import time
from time import sleep
from pprint import pprint
from kiteconnect import KiteConnect
from kiteconnect import KiteTicker
from selenium import webdriver
import xlwings as xw
from webdriver_manager.chrome import ChromeDriverManager
import pandas as pd
import pdb as ppp
from xlwings import Range, constants
import py_vollib.black_scholes
import py_vollib.black_scholes_merton.implied_volatility
import py_vollib_vectorized
import requests
import re
from selenium import webdriver
from selenium.webdriver.chrome.service import Service

from thefirstock import thefirstock

import undetected_chromedriver as uc
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.by import By
# import time
import pyotp
import logging
import sys
import py_vollib.black_scholes
import py_vollib.black_scholes_merton.implied_volatility
import py_vollib_vectorized

from multiprocessing import Process, freeze_support
# importing module
import logging

# importing all required libraries
import telebot
from telethon.sync import TelegramClient
from telethon.tl.types import InputPeerUser, InputPeerChannel
from telethon import TelegramClient, sync, events

chrome_driver_path = "C:\\Program Files (x86)\\ChromeWebDriver\\chromedriver-win64\\chromedriver.exe"

is_login = 0
my_api_key = "TEST"
my_api_secret = "TEST"
access_token = "TEST"
nifty_expiryday = 3  # 3 for thursday , 2 for wednesday
expiryday = 3  # 3 for thursday , 2 for wednesday
midcap_expiryday = 0
sensex_expiryday = 4
fin_expiryday = 1
bn_expiryday = 2

success_status_firstock = "COMPLETE"
firstock_testing_mode = False

kite = ""
kws = ""

test = "hello"
months = {
    1: 'JAN',
    2: 'FEB',
    3: 'MAR',
    4: 'APR',
    5: 'MAY',
    6: 'JUN',
    7: 'JUL',
    8: 'AUG',
    9: 'SEP',
    10: 'OCT',
    11: 'NOV',
    12: 'DEC'

}

order_index = 0
txn_type_index = 1
symbol_index = 2
quantity_index = 3
price_index = 4

quantity_dict_index = 0
buysellval_dict_index = 1
pnl_dict_index = 2


# global ltp_dict

# def test():
#     # from globalvar import ltp_dict
#     # print(ltp_dict)


def set_logger(filename):
    global logger
    try:

        # logging.basicConfig(filename=filename, format='%(asctime)s %(message)s', filemode='w')
        # logging.basicConfig(encoding='utf-8', level=logging.INFO,
        # handlers=[logging.FileHandler(filename), logging.StreamHandler(sys.stdout)])

        # logging.basicConfig(encoding='utf-8', level=logging.INFO,
        #                     handlers=[logging.FileHandler(filename), logging.StreamHandler(sys.stdout)])
        custom_time_format = '%Y-%m-%d %H:%M:%S'

        logging.basicConfig(format='%(asctime)s -> %(message)s', level=logging.INFO, datefmt=custom_time_format,
                            handlers=[logging.FileHandler(filename), logging.StreamHandler(sys.stdout)])
        # # Creating an object
        logger = logging.getLogger()

        logger.setLevel(logging.INFO)

    except Exception as e:

        print("__________________________________________________________")
        print("LOGGER COULDN'T BE SET UP PROPERLY IN FILE: ", filename)
        print("__________________________________________________________")
        print(e)
        print("__________________________________________________________")


def send_logs(log_message):
    try:
        logger.info(log_message)
        # print(log_message)
    except Exception as e:
        curtime = datetime.datetime.now()
        cur_seconds = curtime.second
        cur_minute = curtime.minute
        cur_hour = curtime.hour
        curdate = datetime.datetime.today()
        curday = curdate.weekday()

        filename = "datafiles\\logs\\bn_strangle_logs\\" + curdate.strftime("%d") + curdate.strftime(
            "%m") + curdate.strftime(
            "%y") + "BN_Strangle.txt"
        set_logger(filename)
        print("__________________________________________________________")
        print("ERROR WHILE SENDING LOGS")
        print("__________________________________________________________")
        print(e)
        print("__________________________________________________________")


def take_logs(log_message, filename):
    try:
        logger.info(log_message)
        # print(log_message)
    except Exception as e:
        curtime = datetime.datetime.now()
        cur_seconds = curtime.second
        cur_minute = curtime.minute
        cur_hour = curtime.hour
        curdate = datetime.datetime.today()
        curday = curdate.weekday()

        # filename = "datafiles\\logs\\bn_strangle_logs\\" + curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        # "%y") + "BN_Strangle.txt"
        set_logger(filename)
        print("__________________________________________________________")
        print("ERROR WHILE SENDING LOGS")
        print("__________________________________________________________")
        print(e)
        print("__________________________________________________________")


def login_in_telegram():
    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # get your api_id, api_hash, token
    # from telegram as described above
    api_id = '7200801'
    api_hash = '558afa04fd353f2a6a202971861c293b'
    token = '5288806515:AAE30rUMGGQadW7kfm052KA-5uIsAq4R7_I'
    message = "YOU STARTED SHEET/ BN STRANGLE CODE ON: " + curdate.strftime("%d") + "." + curdate.strftime(
        "%m") + "." + curdate.strftime("%y") + " AT TIME " + str(curtime.hour) + ":" + str(curtime.minute)

    phone = '+919871683418'
    global client, myself, receiver

    try:
        client = TelegramClient('session', api_id, api_hash)
        client.connect()

        if not client.is_user_authorized():
            client.send_code_request(phone)

            # signing in the client
            client.sign_in(phone, input('Enter the code FOR TELEGRAM: '))
            myself = client.get_me()
            # print(myself)
            # ppp.set_trace()

        myself = client.get_me()
        user_hash = myself.access_hash
        user_id = 892515817

        try:

            receiver = InputPeerUser(user_id, user_hash)

            client.send_message(receiver, message, parse_mode='html')
            send_logs("LOGGED INTO TELEGRAM SUCCESSFULLY")

        except Exception as e:

            send_logs("_____________________________________________")
            send_logs(e)
            send_logs('TELEGRAM ERROR FROM CONFIG')
            send_logs("_____________________________________________")
            send_logs("_____________________________________________")
    except Exception as ex:

        send_logs("_____________________________________________")
        send_logs(ex)
        send_logs('TELEGRAM ERROR FROM CONFIG outer')
        send_logs("_____________________________________________")
        send_logs("_____________________________________________")


def message_telegram(message):
    try:

        # receiver = InputPeerUser(user_id, user_hash)

        client.send_message(receiver, message, parse_mode='html')

    except Exception as e:

        send_logs("_____________________________________________")
        send_logs(e)
        send_logs("TELEGRAM ERROR WHILE SENDING MESSAGE " + str(message) + " FROM CONFIG")
        send_logs("_____________________________________________")
        send_logs("_____________________________________________")


def multiple_account_login_in_zerodha(name, api_key, api_secret, user_id, user_pwd, totp_key):
    # login_in_telegram()
    global kite, kws, access_token, test, is_login

    kite = KiteConnect(api_key=api_key)
    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    login_filename = "datafiles\\login_info\\" + name + curdate.strftime("%d") + curdate.strftime(
        "%m") + curdate.strftime(
        "%y") + "login_info.txt"

    f = open(login_filename, "a")  # Append mode

    f.close()

    f = open(login_filename, "r")  # File Reading
    filedata = f.read()
    # f.close()

    # symbol_dict= {}

    access_token_data = filedata.splitlines()
    num_access_token = len(access_token_data)
    # processed_order_data = []
    access_token_from_file = ""
    if (num_access_token == 0):
        send_logs("Access Tokken is not set yet. This is the 1st time you are logging in for the day mp!")
        send_logs("_______________________________________________________________________________________________")
    # return
    else:
        access_token_from_file = access_token_data[0]
        access_token = access_token_from_file
        send_logs("ACCESS TOKEN FROM FILE IS: " + str(access_token_from_file))
        send_logs("_______________________________________________________________________________________________")

    f = open(login_filename, "a")  # Append mode
    # latestchromedriver = ChromeDriverManager().install()
    if num_access_token == 0:
        # driver = uc.Chrome(use_subprocess=True)
        # driver = webdriver.Chrome(chrome_driver_path)
        service = Service()
        options = webdriver.ChromeOptions()
        driver = webdriver.Chrome(service=service, options=options)

        # driver = uc.Chrome(driver_executable_path=latestchromedriver)
        driver.get(f'https://kite.trade/connect/login?api_key={api_key}&v=3')
        login_id = WebDriverWait(driver, 10).until(lambda x: x.find_element(By.XPATH, '//*[@id="userid"]'))
        login_id.send_keys(user_id)

        pwd = WebDriverWait(driver, 10).until(lambda x: x.find_element(By.XPATH, '//*[@id="password"]'))
        pwd.send_keys(user_pwd)

        keep_logged_in_to_kite_web = WebDriverWait(driver, 10).until(
            lambda x: x.find_element(By.XPATH, '//*[@id="container"]/div/div/div[2]/form/div[3]/div/label'))
        keep_logged_in_to_kite_web.click()

        submit = WebDriverWait(driver, 10).until(
            lambda x: x.find_element(By.XPATH, '//*[@id="container"]/div/div/div[2]/form/div[4]/button'))
        submit.click()

        time.sleep(1)

        totp = WebDriverWait(driver, 10).until(
            lambda x: x.find_element(By.XPATH, '//*[@id="container"]/div[2]/div/div/form/div[1]/input'))
        # /html/body/div[1]/div/div/div[1]/div[2]/div/div/form/div[1]/input
        # /html/body/div[1]/div/div/div[1]
        authkey = pyotp.TOTP(totp_key)
        send_logs("authkey" + str(authkey))
        totp.send_keys(authkey.now())

        continue_btn = WebDriverWait(driver, 10).until(
            lambda x: x.find_element(By.XPATH, '//*[@id="container"]/div[2]/div/div/form/div[2]/button'))
        # //*[@id="container"]/div[2]/div/div/form/div[2]/button
        continue_btn.click()

        time.sleep(5)

        url = driver.current_url
        initial_token = url.split('request_token=')[1]
        request_token = initial_token.split('&')[0]

        # driver.close()

        data = kite.generate_session(request_token, api_secret=api_secret)
        access_token = data['access_token']
        f.write(access_token)

        # kite.set_access_token(access_token)
        send_logs("ACCESS TOKEN IS:" + str(access_token))
    f.close()
    kite.set_access_token(access_token)
    kws = KiteTicker(my_api_key, access_token)

    return kite


def login_in_zerodha(api_key, api_secret, user_id, user_pwd, totp_key):
    # login_in_telegram()
    global kite, kws, access_token, test, is_login

    kite = KiteConnect(api_key=api_key)
    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    login_filename = "datafiles\\login_info\\" + curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "login_info.txt"

    f = open(login_filename, "a")  # Append mode

    f.close()

    f = open(login_filename, "r")  # File Reading
    filedata = f.read()
    # f.close()

    # symbol_dict= {}

    access_token_data = filedata.splitlines()
    num_access_token = len(access_token_data)
    # processed_order_data = []
    access_token_from_file = ""
    if (num_access_token == 0):
        send_logs("Access Tokken is not set yet. This is the 1st time you are logging in for the day mp!")
        send_logs("_______________________________________________________________________________________________")
    # return
    else:
        access_token_from_file = access_token_data[0]
        access_token = access_token_from_file
        send_logs("ACCESS TOKEN FROM FILE IS: " + access_token_from_file)
        send_logs("_______________________________________________________________________________________________")

    f = open(login_filename, "a")  # Append mode

    if num_access_token == 0:
        # driver = uc.Chrome(use_subprocess=True)
        service = Service()
        options = webdriver.ChromeOptions()
        driver = webdriver.Chrome(service=service, options=options)

        driver.get(f'https://kite.trade/connect/login?api_key={api_key}&v=3')
        login_id = WebDriverWait(driver, 10).until(lambda x: x.find_element(By.XPATH, '//*[@id="userid"]'))
        login_id.send_keys(user_id)

        pwd = WebDriverWait(driver, 10).until(lambda x: x.find_element(By.XPATH, '//*[@id="password"]'))
        pwd.send_keys(user_pwd)

        keep_logged_in_to_kite_web = WebDriverWait(driver, 10).until(
            lambda x: x.find_element(By.XPATH, '//*[@id="container"]/div/div/div[2]/form/div[3]/div/label'))
        keep_logged_in_to_kite_web.click()

        submit = WebDriverWait(driver, 10).until(
            lambda x: x.find_element(By.XPATH, '//*[@id="container"]/div/div/div[2]/form/div[4]/button'))
        submit.click()

        time.sleep(1)

        totp = WebDriverWait(driver, 10).until(
            lambda x: x.find_element(By.XPATH, '//*[@id="container"]/div[2]/div/div/form/div[1]/input'))
        # /html/body/div[1]/div/div/div[1]/div[2]/div/div/form/div[1]/input
        # /html/body/div[1]/div/div/div[1]
        authkey = pyotp.TOTP(totp_key)
        send_logs("authkey" + str(authkey))
        totp.send_keys(authkey.now())

        # continue_btn = WebDriverWait(driver, 10).until(
        # lambda x: x.find_element(By.XPATH, '//*[@id="container"]/div[2]/div/div/form/div[2]/button'))

        # continue_btn.click()

        time.sleep(5)

        url = driver.current_url
        initial_token = url.split('request_token=')[1]
        request_token = initial_token.split('&')[0]

        # driver.close()

        data = kite.generate_session(request_token, api_secret=api_secret)
        access_token = data['access_token']
        f.write(access_token)

        # kite.set_access_token(access_token)
        send_logs("ACCESS TOKEN IS:" + str(access_token))
    f.close()
    kite.set_access_token(access_token)
    kws = KiteTicker(my_api_key, access_token)

    return kite


# def login_in_firstock_Ashish():
#     totp_key = 'TEST'
#     # totp_key = open('my_data_firstock/totp_key.txt', 'r').read()
#     # user_id = open('my_data_firstock/userId.txt', 'r').read()
#     # passw = open('my_data_firstock/password.txt', 'r').read()
#     # vendor_code = open('my_data_firstock/vendorCode.txt', 'r').read()
#     # api_key = open('my_data_firstock/apiKey.txt', 'r').read()

#     authkey = pyotp.TOTP(totp_key)
#     authkey = authkey.now()
#     send_logs(authkey)
#     # logoutt = thefirstock.firstock_logout()
#     # send_logs(logoutt)
#     login = thefirstock.firstock_login(
#         userId='TEST',
#         password='TEST',
#         TOTP=str(authkey),
#         vendorCode='TEST',
#         apiKey='TEST',
#     )

#     # login = thefirstock.firstock_login(
#     #     userId = user_id,
#     #     password= passw,
#     #     TOTP=str(authkey),
#     #     vendorCode = vendor_code,
#     #     apiKey=api_key,
#     # )

#     send_logs("____________________FIRSTOCK LOGIN__________________________________________")
#     pprint(login)


def login_in_firstock_mummy():
    totp_key = 'TEST'

    authkey = pyotp.TOTP(totp_key)
    authkey = authkey.now()
    send_logs(authkey)
    # logoutt = thefirstock.firstock_logout()
    # send_logs(logoutt)
    login = thefirstock.firstock_login(
        userId='TEST',
        password='TEST',
        TOTP=str(authkey),
        vendorCode='TEST',
        apiKey='TEST',
    )
    logger.info("____________________FIRSTOCK LOGIN__________________________________________")
    pprint(login)


# def login_in_firstock():
#     totp_key = 'TEST'
# 
#     authkey = pyotp.TOTP(totp_key)
#     authkey = authkey.now()
#     send_logs(authkey)
#     # logoutt = thefirstock.firstock_logout()
#     # send_logs(logoutt)
#     login = thefirstock.firstock_login(
#         userId='TEST',
#         password='TEST',
#         TOTP=str(authkey),
#         vendorCode='TEST',
#         apiKey='TEST',
#     )
#     send_logs("_____________________FIRSTOCK LOGIN___________________________________________")
#     pprint(login)
# 

def login_kite(api_key, api_secret):
    global kite, kws, access_token, test, is_login
    kite = KiteConnect(api_key=my_api_key)
    if is_login == 1:
        print("Generate Request Token Now with this URL-", kite.login_url())
    # test="zero"
    # print(test)

    if is_login == 1:
        request_token = input("Enter your request token here: ")
        data = kite.generate_session(request_token, api_secret=my_api_secret)
        access_token = data["access_token"]

    kite.set_access_token(access_token)

    kws = KiteTicker(my_api_key, access_token)
    if is_login == 1:
        print("Access Token is :", access_token)
    # pprint(kite.positions())


def last_price_of_zerodha_symbol_using_firstock(symbol, index):
    """

    :param index: "bn", "nifty", "midcap_nifty" , "fin_nifty"
    :param symbol: 	Ex : NIFTY2381719250PE , NIFTY2381719450CE	 (Symbols are taken from the orders file)
    :return:
    """
    if index == "bn":
        COP = symbol[-2:]
        STRIKE = int(symbol[-7:-2])
        if COP == "CE":
            token_a = firstock_banknifty_strike_to_symbol(STRIKE, 'CALL')
            return float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=token_a)['data']['lastTradedPrice'])
        elif COP == "PE":
            token_a = firstock_banknifty_strike_to_symbol(STRIKE, 'PUT')
            return float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=token_a)['data']['lastTradedPrice'])

    elif index == "nifty":
        COP = symbol[-2:]
        STRIKE = int(symbol[-7:-2])
        if COP == "CE":
            token_a = firstock_nifty_strike_to_symbol(STRIKE, 'CALL')
            return float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=token_a)['data']['lastTradedPrice'])
        elif COP == "PE":
            token_a = firstock_nifty_strike_to_symbol(STRIKE, 'PUT')
            return float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=token_a)['data']['lastTradedPrice'])

    elif index == "midcap_nifty":
        COP = symbol[-2:]
        STRIKE = int(symbol[-6:-2])
        if COP == "CE":
            token_a = firstock_nifty_strike_to_symbol(STRIKE, 'CALL')
            return float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=token_a)['data']['lastTradedPrice'])
        elif COP == "PE":
            token_a = firstock_nifty_strike_to_symbol(STRIKE, 'PUT')
            return float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=token_a)['data']['lastTradedPrice'])

    elif index == "fin_nifty":
        COP = symbol[-2:]
        STRIKE = int(symbol[-7:-2])
        if COP == "CE":
            token_a = firstock_fin_nifty_strike_to_symbol(STRIKE, 'CALL')
            return float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=token_a)['data']['lastTradedPrice'])
        elif COP == "PE":
            token_a = firstock_fin_nifty_strike_to_symbol(STRIKE, 'PUT')
            return float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=token_a)['data']['lastTradedPrice'])


def last_price_firstock(symbols, symbol_index="NFO"):
    """

    :param symbols: List or String Symbol
    :param symbol_index: "NSE, NFO, BFO"
    :return: ltp array if list given , else ltp symbol
    """
    # print(ltp_dict)
    if (type(symbols) is list):
        exch_symbols = []
        lastprice = []
        num_of_symbols = len(symbols)
        # print(num_of_symbols)

        for i in range(num_of_symbols):
            # TODO : PLACE TRY AND CATCH THING , ERROR MANAGEMENT
            time.sleep(0.2)
            symbol_token = symbols[i]
            ltp = float(
                thefirstock.firstock_getQuoteLTP(exchange=symbol_index, token=symbol_token)['data']['lastTradedPrice'])
            lastprice.append(ltp)

        return lastprice
    else:
        try:
            ltp = float(
                thefirstock.firstock_getQuoteLTP(exchange=symbol_index, token=symbols)['data']['lastTradedPrice'])
        except Exception as e:
            time.sleep(0.3)
            ltp = float(
                thefirstock.firstock_getQuoteLTP(exchange=symbol_index, token=symbols)['data']['lastTradedPrice'])
        return ltp
        # return ltp_dict[exch_symbol]['last_price']


def last_price(symbols):  # Only for derivatives NFO

    # print(ltp_dict)
    if (type(symbols) is list):
        exch_symbols = []
        lastprice = []
        num_of_symbols = len(symbols)
        # print(num_of_symbols)
        for i in range(num_of_symbols):
            exch_symbols.append('NFO:' + symbols[i])
        # print(exch_symbols)
        ltp_dict = kite.ltp(exch_symbols)
        # print(ltp_dict)
        for i in range(num_of_symbols):
            lastprice.append(ltp_dict[exch_symbols[i]]['last_price'])

        return lastprice
    else:
        exch_symbol = 'NFO:' + symbols
        return kite.ltp(exch_symbol)[exch_symbol]['last_price']
        # return ltp_dict[exch_symbol]['last_price']


def last_price_sensex(symbols):  # Only for derivatives BFO

    # print(ltp_dict)
    if (type(symbols) is list):
        exch_symbols = []
        lastprice = []
        num_of_symbols = len(symbols)
        # print(num_of_symbols)
        for i in range(num_of_symbols):
            exch_symbols.append('BFO:' + symbols[i])
        # print(exch_symbols)
        ltp_dict = kite.ltp(exch_symbols)
        # print(ltp_dict)
        for i in range(num_of_symbols):
            lastprice.append(ltp_dict[exch_symbols[i]]['last_price'])

        return lastprice
    else:
        exch_symbol = 'BFO:' + symbols
        return kite.ltp(exch_symbol)[exch_symbol]['last_price']
        # return ltp_dict[exch_symbol]['last_price']


def nifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'

    if curday <= expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = expiryday - curday
    elif curday > expiryday:
        days_remaining = expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
        symbol = "NIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "NIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix

    return (symbol)


def midcap_nifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'

    if curday <= midcap_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = midcap_expiryday - curday
    elif curday > midcap_expiryday:
        days_remaining = midcap_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
        symbol = "MIDCPNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "MIDCPNIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix

    return (symbol)


def sensex_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'

    if curday <= sensex_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = sensex_expiryday - curday
    elif curday > sensex_expiryday:
        days_remaining = sensex_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
        symbol = "SENSEX" + expiryyear + months[int(expirym)][0] + expiryd + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "SENSEX" + expiryyear + months[int(expirym)] + str(strike) + suffix

    return (symbol)


def fin_nifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'

    if curday <= 1:  # 0 Is Monday, 3 is Thursday
        days_remaining = fin_expiryday - curday
    elif curday > expiryday:
        days_remaining = fin_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
        symbol = "FINNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "FINNIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix

    return (symbol)


def monthly_nifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'

    if curday <= expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = expiryday - curday
    elif curday > expiryday:
        days_remaining = expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        symbol = "NIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "NIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix

    return (symbol)


def firstock_banknifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    suffix = ''

    if (type == "PUT"):
        suffix = 'P'
    elif (type == "CALL"):
        suffix = 'C'

    if curday <= expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = expiryday - curday
    elif curday > expiryday:
        days_remaining = expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    # nextexpirydate = expirydate + datetime.timedelta(days=7)
    # nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    # if (expirymonth == nextexpirymonth):
    #     # print("Current upcoming expiry is a Weekly Expiry")
    #     expirytype = 'Weekly'
    # else:
    #     # print("Current upcoming expiry is a Monthly Expiry")
    #     expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    # if (expirytype == 'Weekly'):
    #     symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
    #     # symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix

    # elif (expirytype == 'Monthly'):
    symbol = "BANKNIFTY" + expiryd + months[int(expirym)] + expiryyear + suffix + str(strike)

    return (symbol)


def firstock_strike_to_symbol(expiry_name, strike, type):  # For weekly expiry
    """

        :param expiry_name: "banknifty", "nifty", "finnifty", "midcap", "sensex"
        :param strike: Integer Strike (19500 , 18500 etc)
        :param type: "CALL"/ "PUT"
        :return: Symbol for the given Strike:  Eg. NIFTY24AUG23C19000 , MIDCPNIFTY04SEP23C8000, FINNIFTY05SEP23C44000, SENSEX2390165000CE
        """
    global months, exp_day
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    suffix = ''

    if (type == "PUT"):
        suffix = 'P'
    elif (type == "CALL"):
        suffix = 'C'

    if expiry_name == "sensex":
        exp_day = sensex_expiryday
    elif expiry_name == "midcap":
        exp_day = midcap_expiryday
    elif expiry_name == "banknifty":
        exp_day = bn_expiryday
    elif expiry_name == "nifty":
        exp_day = expiryday
    elif expiry_name == "finnifty":
        exp_day = fin_expiryday

    if curday <= exp_day:  # 0 Is Monday, 3 is Thursday
        days_remaining = exp_day - curday
    elif curday > exp_day:
        days_remaining = exp_day - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    # if (expirytype == 'Weekly'):
    #     symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
    #     # symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix

    # elif (expirytype == 'Monthly'):
    prefix = ""
    if expiry_name == "sensex":
        prefix = "SENSEX"
    elif expiry_name == "midcap":
        prefix = "MIDCPNIFTY"
    elif expiry_name == "banknifty":
        prefix = "BANKNIFTY"
    elif expiry_name == "nifty":
        prefix = "NIFTY"
    elif expiry_name == "finnifty":
        prefix = "FINNIFTY"
    else:
        prefix = None

    if expiry_name == "sensex":
        # "SENSEX2390166000CE"
        # for monthly, sensex23SEP66000CE
        if type == "CALL":
            suffix = "CE"
        else:
            suffix = "PE"
        #         symbol = prefix + expiryd + months[int(expirym)] + expiryyear + suffix + str(strike)
        if expirytype == 'Monthly':
            symbol = prefix + expiryyear + months[int(expirym)] + str(strike) + suffix
        else:
            # symbol = prefix + expiryyear + str(int(expirym)) + expiryd + str(strike) + suffix
            symbol = prefix + expiryyear + months[int(expirym)][0] + expiryd + str(strike) + suffix
    else:
        symbol = prefix + expiryd + months[int(expirym)] + expiryyear + suffix + str(strike)

    return (symbol)


def firstock_nifty_strike_to_symbol(strike, type):  # For weekly expiry
    """
    :param strike: Integer Strike (19500 , 18500 etc)
    :param type: "CALL"/ "PUT"
    :return: Symbol for the given Strike:  Eg. NIFTY24AUG23C19000 , NIFTY24AUG23P19000
    """
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    suffix = ''

    if (type == "PUT"):
        suffix = 'P'
    elif (type == "CALL"):
        suffix = 'C'

    if curday <= expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = expiryday - curday
    elif curday > expiryday:
        days_remaining = expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    # nextexpirydate = expirydate + datetime.timedelta(days=7)
    # nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    # if (expirymonth == nextexpirymonth):
    #     # print("Current upcoming expiry is a Weekly Expiry")
    #     expirytype = 'Weekly'
    # else:
    #     # print("Current upcoming expiry is a Monthly Expiry")
    #     expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    # if (expirytype == 'Weekly'):
    #     symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
    #     # symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix

    # elif (expirytype == 'Monthly'):
    symbol = "NIFTY" + expiryd + months[int(expirym)] + expiryyear + suffix + str(strike)

    return (symbol)


def firstock_fin_nifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    suffix = ''

    if (type == "PUT"):
        suffix = 'P'
    elif (type == "CALL"):
        suffix = 'C'

    if curday <= fin_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = fin_expiryday - curday
    elif curday > fin_expiryday:
        days_remaining = fin_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    # nextexpirydate = expirydate + datetime.timedelta(days=7)
    # nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    # if (expirymonth == nextexpirymonth):
    #     # print("Current upcoming expiry is a Weekly Expiry")
    #     expirytype = 'Weekly'
    # else:
    #     # print("Current upcoming expiry is a Monthly Expiry")
    #     expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    # if (expirytype == 'Weekly'):
    #     symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
    #     # symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix

    # elif (expirytype == 'Monthly'):
    symbol = "FINNIFTY" + expiryd + months[int(expirym)] + expiryyear + suffix + str(strike)

    return (symbol)


def firstock_midcap_nifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    suffix = ''

    if (type == "PUT"):
        suffix = 'P'
    elif (type == "CALL"):
        suffix = 'C'

    if curday <= midcap_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = midcap_expiryday - curday
    elif curday > midcap_expiryday:
        days_remaining = midcap_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    # nextexpirydate = expirydate + datetime.timedelta(days=7)
    # nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    # if (expirymonth == nextexpirymonth):
    #     # print("Current upcoming expiry is a Weekly Expiry")
    #     expirytype = 'Weekly'
    # else:
    #     # print("Current upcoming expiry is a Monthly Expiry")
    #     expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    # if (expirytype == 'Weekly'):
    #     symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
    #     # symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix

    # elif (expirytype == 'Monthly'):
    symbol = "MIDCPNIFTY" + expiryd + months[int(expirym)] + expiryyear + suffix + str(strike)

    return (symbol)


def banknifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, bn_expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'

    if curday <= bn_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = bn_expiryday - curday  # Hi
    elif curday > bn_expiryday:
        days_remaining = bn_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        symbol = "BANKNIFTY" + expiryyear + months[int(expirym)][0] + expiryd + str(strike) + suffix
        # symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "BANKNIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix

    return (symbol)


def finnifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday, fin_expiryday
    # fin_expiryday = 1
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'

    if curday <= expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = fin_expiryday - curday
    elif curday > expiryday:
        days_remaining = fin_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        symbol = "FINNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
        # symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "FINNIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix

    return (symbol)


def monthly_banknifty_strike_to_symbol(strike, type):  # For weekly expiry
    global months, expiryday
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'

    if curday <= expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = expiryday - curday
    elif curday > expiryday:
        days_remaining = expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # send_logs(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "BANKNIFTY" + expiryyear + expirym + expiryd + str(strike) + suffix
        symbol = "BANKNIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "BANKNIFTY" + expiryyear + months[int(expirym)] + str(strike) + suffix

    return (symbol)


'''
23082300011595	SELL	NIFTY24AUG23P19300	40	6.60
23082300011596	SELL	NIFTY24AUG23C19600	40	4.10

'''


def symbol_to_strike_firstock(symbol, expiry_name="nifty"):
    """
    :param symbol: String: EX NIFTY24AUG23P19300, SENSEX2391566000CE
    :param expiry_name: String: "nifty","banknifty", "sensex", "midcap", "finnifty"
    :return: String strike 19300 or 0
    """
    if symbol == None or type(symbol) != str:
        send_logs(
            "Incorrect Symbol !!!" + "You are trying to reference Symbol: " + str(symbol) + " which is wrong!")
        return 0

    if expiry_name == "sensex":
        instrument_type = symbol[-2:]
    else:
        instrument_type = symbol[-6:-5]

    # instrument_type = symbol[-6:-5]
    # For midcap , make someother function! since it is near 10000 (5 digit number ) but still is 4 digit number
    OPTION_strike = 0
    if ((instrument_type == 'C') or (instrument_type == 'P')) and (
            expiry_name == "nifty" or expiry_name == "banknifty" or expiry_name == "finnifty"):
        # calculate greeks using pyvollib
        OPTION_strike = symbol[-5:]
        OPTION_strike = int(OPTION_strike)
        return OPTION_strike
    elif instrument_type == "CE" or instrument_type == "PE":
        OPTION_strike = symbol[-7:-2]
        OPTION_strike = int(OPTION_strike)
        return OPTION_strike
    else:
        send_logs(
            "Incorrect Symbol !!!" + "You are trying to reference Symbol: " + str(symbol) + " which is wrong!")
        return OPTION_strike


def nifty_symbol_to_strike_firstock(symbol):
    """
    :param symbol: String: EX NIFTY24AUG23P19300
    :return: String strike 19300 or 0
    """
    if symbol == None or type(symbol) != str:
        send_logs(
            "Incorrect Symbol !!!" + "You are trying to reference Symbol: " + str(symbol) + " which is wrong!")
        return 0
    instrument_type = symbol[-6:-5]
    OPTION_strike = 0
    if (instrument_type == 'C') or (instrument_type == 'P'):
        # calculate greeks using pyvollib
        OPTION_strike = symbol[-5:]
        OPTION_strike = int(OPTION_strike)
        return OPTION_strike
    else:
        send_logs(
            "Incorrect Symbol !!!" + "You are trying to reference Symbol: " + str(symbol) + " which is wrong!")
        return OPTION_strike


def nifty_symbol_to_strike(symbol):
    pos = symbol.find('CE')
    strike = 0  # add this
    if (pos > 0):
        strike = int(symbol[pos - 5:pos])
    else:
        pos = symbol.find('PE')
        if (pos > 0):
            strike = int(symbol[pos - 5:pos])
        else:
            send_logs(
                "Incorrect Symbol !!!" + "You are trying to reference Symbol: " + str(symbol) + " which is wrong!")

    return strike


def midcap_nifty_symbol_to_strike(symbol):
    pos = symbol.find('CE')
    strike = 0
    if (pos > 0):
        strike = int(symbol[pos - 4:pos])
    else:
        pos = symbol.find('PE')
        if (pos > 0):
            strike = int(symbol[pos - 4:pos])
        else:
            send_logs("Incorrect Symbol !!!")

    return strike


def sensex_symbol_to_strike(symbol):
    pos = symbol.find('CE')
    strike = 0
    if (pos > 0):
        strike = int(symbol[pos - 5:pos])
    else:
        pos = symbol.find('PE')
        if (pos > 0):
            strike = int(symbol[pos - 5:pos])
        else:
            send_logs("Incorrect Symbol !!!")

    return strike


def banknifty_symbol_to_strike(symbol):
    pos = symbol.find('CE')
    strike = 0
    if (pos > 0):
        strike = int(symbol[pos - 5:pos])
    else:
        pos = symbol.find('PE')
        if (pos > 0):
            strike = int(symbol[pos - 5:pos])
        else:
            send_logs("Incorrect Symbol !!!")

    return strike


def fin_nifty_symbol_to_strike(symbol):
    pos = symbol.find('CE')
    strike = 0
    if (pos > 0):
        strike = int(symbol[pos - 5:pos])
    else:
        pos = symbol.find('PE')
        if (pos > 0):
            strike = int(symbol[pos - 5:pos])
        else:
            send_logs("Incorrect Symbol !!!")

    return strike


def execute_order_firstock_v2(symbol, type_, quant, price, trig_price, product, expiry_name="nifty"):
    """

    :param symbol: Symbol to sell EX: 'NIFTY24AUG23C19600' , 'SENSEX2391566600PE'
    :param type_: BUY or SELL
    :param quant: quantity to sell / buy
    :param price: price to buy or sell (can be none)
    :param trig_price: For SL orders: price to buy or sell (can be none)
    :param product: NRML or MIS for zerodha
    :param expiry_name: STRING "sensex", "nifty", "banknifty", "finnifty", "midcap"
    :return: Order Id for the successful orders
    """
    #     global kite

    sl_limit_error = "Trigger price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with trigger price below"
    limit_lower_circuit_error = "Your order price is lower than the current [lower circuit limit]"
    error3 = "Trigger price for stoploss buy orders should be higher than the last traded price "
    error4 = "Price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with Price below"

    if type_ == "BUY":
        txn_type = 'B'
    elif type_ == "SELL":
        txn_type = 'S'

    product_type = 'I'  # C / M / I C -> Cash and Carry, M -> F&O Normal, I -> Intraday

    if expiry_name == "sensex":
        exchange = "BFO"
    else:
        exchange = "NFO"
    orderid = None
    if price == None and trig_price == None:  # It means Market order but I need to place my range checks in place an convert it into SL order
        order_type = "LMT"
        strike_lastprice = 0
        try:

            symbol_current_details = thefirstock.firstock_getQuote(exchange=exchange, token=symbol)
            strike_lastprice = float(symbol_current_details['data']['lastTradedPrice'])  # throws error if not fetched
        except Exception as e:
            time.sleep(0.3)
            try:
                symbol_current_details = thefirstock.firstock_getQuoteLTP(exchange=exchange, token=symbol)
                strike_lastprice = float(
                    symbol_current_details['data']['lastTradedPrice'])  # throws error if not fetched
            except Exception as e:
                send_logs(e)
                send_logs("Exception raised at execute_order() function, order was not executed. Check immediately...")
                return None

        # print(symbol_current_details)
        # print()
        upper_circuit_limit = float(symbol_current_details['data']['upperCircuit'])
        lower_circuit_limit = float(symbol_current_details['data']['lowerCircuit'])
        if (strike_lastprice > upper_circuit_limit) or (strike_lastprice < lower_circuit_limit):
            send_logs("Tried to place order above upper circuit limit or lower circuit limit!!!")
            send_logs("Returning without taking any trade. Potential FAT FINGER TRADE Detected!!!")
            return None

        trig_price = 0
        price = 0

        if strike_lastprice < 800:  # Improve this range check
            if type_ == "BUY":  # Giving 15 % room to execute on all orders
                price = round(1.15 * strike_lastprice, 1)
                # price = strike_lastprice
            elif type_ == "SELL":
                price = round(0.85 * strike_lastprice, 1)
                # price = strike_lastprice

            # Here Trig Price will remain None
            # print("Placing Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", strike_lastprice)
            logging.info("Placing Order %s  %s for Quantity %s at Rs. %s", str(type_), symbol, str(quant),
                         strike_lastprice)
        else:
            logging.info("Price out of range detected. Not placing the order!!!")
            return None

        if firstock_testing_mode:
            price = strike_lastprice

    elif (price != None and trig_price != None):
        order_type = "SL-LMT"  # Order type stop loss  and SL orders.
        # print("Placing SL Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", trig_price)
        logging.info("Placing SL Order %s  %s for Quantity %s at Rs. %s", str(type_), symbol, str(quant), trig_price)
    elif (price != None and trig_price == None):
        order_type = "LMT"  # Order type Limit.
        # print("Placing Limit Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", price)
        logging.info("Placing Limit Order %s  %s for Quantity %s at Rs. %s", str(type_), symbol, str(quant), price)

    # logging.info("trig price is %s price is %s", trig_price, price)
    send_logs("Taking Trade for Symbol: " + str(symbol) + " Trade Type: " + type_)

    try:
        order_execution_result = thefirstock.firstock_placeOrder(
            exchange=exchange,
            tradingSymbol=symbol,
            quantity=quant,
            price=price,
            product=product_type,
            transactionType=txn_type,
            priceType=order_type,
            retention="DAY",
            triggerPrice=trig_price,
            remarks="Python Package Order"
        )

        if (order_execution_result["status"] == "Failed"):
            raise Exception(
                "Exception raised at execute_order() function, order was not executed. Check immediately...")
        send_logs("Order Id is - " + str(order_execution_result['data']["orderNumber"]))
        orderid = str(order_execution_result['data']["orderNumber"])
        # Place orders for hedges as well
    except Exception as e:
        send_logs(e)
        send_logs("Exception raised at execute_order() function, order was not executed. Check immediately...")
    finally:
        pass
        # send_logs("Exception Caught")

    return orderid


def execute_order_firstock(symbol, type_, quant, price, trig_price, product):
    """

    :param symbol: Symbol to sell EX: 'NIFTY24AUG23C19600'
    :param type_: BUY or SELL
    :param quant: quantity to sell / buy
    :param price: price to buy or sell (can be none)
    :param trig_price: For SL orders: price to buy or sell (can be none)
    :param product: NRML or MIS for zerodha
    :return: Order Id for the successful orders
    """
    #     global kite

    sl_limit_error = "Trigger price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with trigger price below"
    limit_lower_circuit_error = "Your order price is lower than the current [lower circuit limit]"
    error3 = "Trigger price for stoploss buy orders should be higher than the last traded price "
    error4 = "Price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with Price below"

    if type_ == "BUY":
        txn_type = 'B'
    elif type_ == "SELL":
        txn_type = 'S'

    product_type = 'I'  # C / M / I C -> Cash and Carry, M -> F&O Normal, I -> Intraday

    orderid = None
    if price == None and trig_price == None:  # It means Market order but I need to place my range checks in place an convert it into SL order
        order_type = "MKT"
        # strike_lastprice = float(
        #     thefirstock.firstock_getQuoteLTP(exchange="NFO", token=symbol)['data']['lastTradedPrice'])
        trig_price = 0
        price = 0
        # if (strike_lastprice < 800):  # Improve this range check
        #     pass
        #     # if type_ == "BUY":  # Giving 15 % room to execute on all orders
        #     #     # price = round(1.15 * strike_lastprice, 1)
        #     #     price = strike_lastprice
        #     # elif type_ == "SELL":
        #     #     # price = round(0.85 * strike_lastprice, 1)
        #     #     price = strike_lastprice
        # 
        # 
        #     # Here Trig Price will remain None
        #     # print("Placing Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", strike_lastprice)
        #     logging.info("Placing Order %s  %s for Quantity %s at Rs. %s", str(type_), symbol, str(quant),
        #                  strike_lastprice)
        # else:
        #     logging.info("Price out of range detected. Not placing the order")
        #     return
    elif (price != None and trig_price != None):
        order_type = "SL-LMT"  # Order type stop loss  and SL orders.
        # print("Placing SL Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", trig_price)
        logging.info("Placing SL Order %s  %s for Quantity %s at Rs. %s", str(type_), symbol, str(quant), trig_price)
    elif (price != None and trig_price == None):
        order_type = "LMT"  # Order type Limit.
        # print("Placing Limit Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", price)
        logging.info("Placing Limit Order %s  %s for Quantity %s at Rs. %s", str(type_), symbol, str(quant), price)

    # logging.info("trig price is %s price is %s", trig_price, price)
    send_logs("Taking Trade for Symbol: " + str(symbol) + " Trade Type: " + type_)
    try:
        order_execution_result = thefirstock.firstock_placeOrder(
            exchange="NFO",
            tradingSymbol=symbol,
            quantity=quant,
            price=price,
            product=product_type,
            transactionType=txn_type,
            priceType=order_type,
            retention="DAY",
            triggerPrice=trig_price,
            remarks="Python Package Order"
        )
        print(order_execution_result)
        if (order_execution_result["status"] == "Failed"):
            raise Exception(
                "Exception raised at execute_order() function, order was not executed. Check immediately...")
        send_logs("Order Id is - " + str(order_execution_result['data']["orderNumber"]))
        orderid = str(order_execution_result['data']["orderNumber"])
        # Place orders for hedges as well
    except Exception as e:
        send_logs(e)

    finally:
        pass
        # send_logs("Exception Caught")

    return orderid


def execute_order(symbol, type, quant, price, trig_price, product):
    global kite

    sl_limit_error = "Trigger price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with trigger price below"
    limit_lower_circuit_error = "Your order price is lower than the current [lower circuit limit]"
    error3 = "Trigger price for stoploss buy orders should be higher than the last traded price "
    error4 = "Price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with Price below"

    if type == "BUY":
        txn_type = kite.TRANSACTION_TYPE_BUY
    elif type == "SELL":
        txn_type = kite.TRANSACTION_TYPE_SELL

    if product == "MIS":
        product_type = kite.PRODUCT_MIS
    elif product == "NRML":
        product_type = kite.PRODUCT_NRML

    if price == None and trig_price == None:  # It means Market order but I need to place my range checks in place an convert it into SL order

        order_type = kite.ORDER_TYPE_LIMIT
        if (symbol.startswith('SENSEX') == True):
            exch_symbol = 'BFO:' + symbol
        else:
            exch_symbol = 'NFO:' + symbol
        strike_lastprice = kite.ltp(exch_symbol)[exch_symbol]['last_price']
        # print("Placing Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", strike_lastprice)

        if (strike_lastprice < 800):  # Improve this range check

            if type == "BUY":  # Giving 15 % room to execute on all orders
                price = round(1.15 * strike_lastprice, 1)
            elif type == "SELL":
                price = round(0.85 * strike_lastprice, 1)

            # Here Trig Price will remain None
            # print("Placing Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", strike_lastprice)
            logging.info("Placing Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant),
                         strike_lastprice)
        else:
            logging.info("Price out of range detected. Not placing the order")
            return
    elif (price != None and trig_price != None):
        order_type = kite.ORDER_TYPE_SL  # Order type stop loss  and SL orders.
        # print("Placing SL Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", trig_price)
        logging.info("Placing SL Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant), trig_price)
    elif (price != None and trig_price == None):
        order_type = kite.ORDER_TYPE_LIMIT  # Order type Limit.
        # print("Placing Limit Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", price)
        logging.info("Placing Limit Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant), price)

    logging.info("trig price is %s price is %s", trig_price, price)
    try:
        if (symbol.startswith('SENSEX') == True):
            orderid = kite.place_order(variety=kite.VARIETY_REGULAR,  # regular, bo, co or amo.
                                       exchange=kite.EXCHANGE_BFO,
                                       tradingsymbol=symbol,
                                       transaction_type=txn_type,  # BUY/SELL
                                       quantity=quant,  # QUANTITY
                                       product=product_type,  # MIS/NRML/CNC/BO/CO
                                       order_type=order_type,  # MARKET/LIMIT/SL/SL-M
                                       price=price,  # Price if required (e.g. for limit orders).
                                       validity=None,  # Validity period of the order (DAY/IOC), defaults to DAY.
                                       disclosed_quantity=None,  # Quantity to disclosed publicly.
                                       trigger_price=trig_price,
                                       #    stoploss=None,
                                       #    trailing_stoploss=None,
                                       tag=None)
        else:
            orderid = kite.place_order(variety=kite.VARIETY_REGULAR,  # regular, bo, co or amo.
                                       exchange=kite.EXCHANGE_NFO,
                                       tradingsymbol=symbol,
                                       transaction_type=txn_type,  # BUY/SELL
                                       quantity=quant,  # QUANTITY
                                       product=product_type,  # MIS/NRML/CNC/BO/CO
                                       order_type=order_type,  # MARKET/LIMIT/SL/SL-M
                                       price=price,  # Price if required (e.g. for limit orders).
                                       validity=None,  # Validity period of the order (DAY/IOC), defaults to DAY.
                                       disclosed_quantity=None,  # Quantity to disclosed publicly.
                                       trigger_price=trig_price,
                                       #    stoploss=None,
                                       #    trailing_stoploss=None,
                                       tag=None)

        send_logs("Order Id is - " + str(orderid))
        # Place orders for hedges as well
    except Exception as e:
        send_logs(e)
        if sl_limit_error in str(e):
            send_logs("SL Limit error, Re Triggering with reduced value")
            # Extracting the circuit limit
            pos1 = str(e).index("below")
            pos2 = str(e).index("[")
            # send_logs("pos", pos1)
            # send_logs("pos", pos2)
            circuit_limit = float(str(e)[pos1 + 6:pos2 - 2])
            # send_logs(circuit_limit)
            trig_price = circuit_limit - 0.5
            orderid = execute_order(symbol, type, quant, price, trig_price, product)
        elif limit_lower_circuit_error in str(e):
            send_logs("Limit lower circuit error, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index(") of")
            pos2 = str(e).index("You can")
            send_logs("pos" + str(pos1))
            send_logs("pos" + str(pos2))
            circuit_limit = float(str(e)[pos1 + 5:pos2 - 2])
            send_logs(circuit_limit)
            price = circuit_limit
            orderid = execute_order(symbol, type, quant, price, trig_price, product)
        elif error3 in str(e):
            send_logs(
                "Error -Trigger price for stoploss buy orders should be higher than the last traded price, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index("price (")
            pos2 = str(e).index("). Use")
            send_logs("pos" + str(pos1))
            send_logs("pos" + str(pos2))
            extracted_value = float(str(e)[pos1 + 7:pos2])
            send_logs(extracted_value)
            # input("Hello")
            trig_price = extracted_value + 0.5
            orderid = execute_order(symbol, type, quant, price, trig_price, product)
        elif error4 in str(e):
            send_logs(
                "Error -Price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with Price below, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index("below ")
            pos2 = str(e).index(". [")
            send_logs("pos" + str(pos1))
            send_logs("pos" + str(pos2))
            extracted_value = float(str(e)[pos1 + 6:pos2])
            send_logs(extracted_value)
            # input("Hello")
            price = extracted_value - 0.1
            orderid = execute_order(symbol, type, quant, price, trig_price, product)
    finally:
        pass
        # send_logs("Exception Caught")

    return orderid


def execute_order_multiple_times(symbol, type, quant, price, trig_price, product):
    global kite

    sl_limit_error = "Trigger price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with trigger price below"
    limit_lower_circuit_error = "Your order price is lower than the current [lower circuit limit]"
    error3 = "Trigger price for stoploss buy orders should be higher than the last traded price "
    error4 = "Price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with Price below"

    if type == "BUY":
        txn_type = kite.TRANSACTION_TYPE_BUY
    elif type == "SELL":
        txn_type = kite.TRANSACTION_TYPE_SELL

    if product == "MIS":
        product_type = kite.PRODUCT_MIS
    elif product == "NRML":
        product_type = kite.PRODUCT_NRML

    if price == None and trig_price == None:  # It means Market order but I need to place my range checks in place an convert it into SL order

        order_type = kite.ORDER_TYPE_LIMIT
        exch_symbol = 'NFO:' + symbol
        strike_lastprice = kite.ltp(exch_symbol)[exch_symbol]['last_price']
        # send_logs("Placing Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", strike_lastprice)

        if (strike_lastprice < 800):  # Improve this range check

            if type == "BUY":  # Giving 15 % room to execute on all orders
                price = round(1.15 * strike_lastprice, 1)
            elif type == "SELL":
                price = round(0.85 * strike_lastprice, 1)

            # Here Trig Price will remain None
            # send_logs("Placing Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", strike_lastprice)
            logging.info("Placing Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant),
                         strike_lastprice)
        else:
            logging.info("Price out of range detected. Not placing the order")
            return
    elif (price != None and trig_price != None):
        order_type = kite.ORDER_TYPE_SL  # Order type stop loss  and SL orders.
        # send_logs("Placing SL Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", trig_price)
        logging.info("Placing SL Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant), trig_price)
    elif (price != None and trig_price == None):
        order_type = kite.ORDER_TYPE_LIMIT  # Order type Limit.
        # send_logs("Placing Limit Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", price)
        logging.info("Placing Limit Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant), price)

    logging.info("trig price is %s price is %s", trig_price, price)

    multiple = 1

    values = range(multiple)

    try:

        if quant > 0 and quant <= 1800:
            orderid = kite.place_order(variety=kite.VARIETY_REGULAR,  # regular, bo, co or amo.
                                       exchange=kite.EXCHANGE_NFO,
                                       tradingsymbol=symbol,
                                       transaction_type=txn_type,  # BUY/SELL
                                       quantity=quant,  # QUANTITY

                                       product=product_type,  # MIS/NRML/CNC/BO/CO
                                       order_type=order_type,  # MARKET/LIMIT/SL/SL-M
                                       price=price,  # Price if required (e.g. for limit orders).
                                       validity=None,  # Validity period of the order (DAY/IOC), defaults to DAY.
                                       disclosed_quantity=None,  # Quantity to disclosed publicly.
                                       trigger_price=trig_price,
                                       squareoff=None,  # Price difference for profit booking (bracker orders).
                                       stoploss=None,
                                       trailing_stoploss=None,
                                       tag=None)

            send_logs("Order Id is - " + str(orderid))
        elif quant > 1800 and quant <= 3600:
            orderid = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                       transaction_type=txn_type, quantity=1800, product=product_type,
                                       order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                       trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                       tag=None)

            quant2 = quant - 1800
            orderid2 = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                        transaction_type=txn_type, quantity=quant2, product=product_type,
                                        order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                        trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                        tag=None)

            print("Order Id 1 is - ", orderid)
            print("Order Id 2 is - ", orderid2)

        elif quant > 3600 and quant <= 5400:
            orderid = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                       transaction_type=txn_type, quantity=1800, product=product_type,
                                       order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                       trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                       tag=None)

            quant2 = quant - 1800
            orderid2 = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                        transaction_type=txn_type, quantity=1800, product=product_type,
                                        order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                        trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                        tag=None)

            quant3 = quant - 3600
            orderid3 = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                        transaction_type=txn_type, quantity=quant3, product=product_type,
                                        order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                        trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                        tag=None)

            print("Order Id 1 is - ", orderid)
            print("Order Id 2 is - ", orderid2)
            print("Order Id 3 is - ", orderid3)


        elif quant > 5400 and quant <= 7200:
            orderid = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                       transaction_type=txn_type, quantity=1800, product=product_type,
                                       order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                       trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                       tag=None)

            quant2 = quant - 1800
            orderid2 = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                        transaction_type=txn_type, quantity=1800, product=product_type,
                                        order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                        trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                        tag=None)

            quant3 = quant - 3600
            orderid3 = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                        transaction_type=txn_type, quantity=1800, product=product_type,
                                        order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                        trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                        tag=None)

            quant4 = quant - 5400
            orderid4 = kite.place_order(variety=kite.VARIETY_REGULAR, exchange=kite.EXCHANGE_NFO, tradingsymbol=symbol,
                                        transaction_type=txn_type, quantity=quant4, product=product_type,
                                        order_type=order_type, price=price, validity=None, disclosed_quantity=None,
                                        trigger_price=trig_price, squareoff=None, stoploss=None, trailing_stoploss=None,
                                        tag=None)

            print("Order Id 1 is - ", orderid)
            print("Order Id 2 is - ", orderid2)
            print("Order Id 3 is - ", orderid3)
            print("Order Id 4 is - ", orderid4)

        # Place orders for hedges as well
    except Exception as e:
        print(e)
        if sl_limit_error in str(e):
            print("SL Limit error, Re Triggering with reduced value")
            # Extracting the circuit limit
            pos1 = str(e).index("below")
            pos2 = str(e).index("[")
            # print("pos", pos1)
            # print("pos", pos2)
            circuit_limit = float(str(e)[pos1 + 6:pos2 - 2])
            # print(circuit_limit)
            trig_price = circuit_limit - 0.5
            orderid = execute_order(symbol, type, quant, price, trig_price, product)
        elif limit_lower_circuit_error in str(e):
            print("Limit lower circuit error, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index(") of")
            pos2 = str(e).index("You can")
            print("pos", pos1)
            print("pos", pos2)
            circuit_limit = float(str(e)[pos1 + 5:pos2 - 2])
            print(circuit_limit)
            price = circuit_limit
            orderid = execute_order(symbol, type, quant, price, trig_price, product)
        elif error3 in str(e):
            print(
                "Error -Trigger price for stoploss buy orders should be higher than the last traded price, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index("price (")
            pos2 = str(e).index("). Use")
            print("pos", pos1)
            print("pos", pos2)
            extracted_value = float(str(e)[pos1 + 7:pos2])
            print(extracted_value)
            # input("Hello")
            trig_price = extracted_value + 0.5
            orderid = execute_order(symbol, type, quant, price, trig_price, product)
        elif error4 in str(e):
            print(
                "Error -Price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with Price below, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index("below ")
            pos2 = str(e).index(". [")
            print("pos", pos1)
            print("pos", pos2)
            extracted_value = float(str(e)[pos1 + 6:pos2])
            print(extracted_value)
            # input("Hello")
            price = extracted_value - 0.1
            orderid = execute_order(symbol, type, quant, price, trig_price, product)
    finally:
        pass
        # print("Exception Caught")

    return orderid


def execute_order_multiple(kite_of_person, name, symbol, type, quant, price, trig_price, product):
    global kite
    print("kite of person isssssssssss" + str(kite_of_person))
    print("___________________________")
    print("kite isssssssss" + str(kite))
    kite = kite_of_person

    sl_limit_error = "Trigger price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with trigger price below"
    limit_lower_circuit_error = "Your order price is lower than the current [lower circuit limit]"
    error3 = "Trigger price for stoploss buy orders should be higher than the last traded price "
    error4 = "Price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with Price below"

    if type == "BUY":
        txn_type = kite.TRANSACTION_TYPE_BUY
    elif type == "SELL":
        txn_type = kite.TRANSACTION_TYPE_SELL

    if product == "MIS":
        product_type = kite.PRODUCT_MIS
    elif product == "NRML":
        product_type = kite.PRODUCT_NRML

    if price == None and trig_price == None:  # It means Market order but I need to place my range checks in place an convert it into SL order

        order_type = kite.ORDER_TYPE_LIMIT
        exch_symbol = 'NFO:' + symbol
        strike_lastprice = kite.ltp(exch_symbol)[exch_symbol]['last_price']
        # print("Placing Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", strike_lastprice)

        if (strike_lastprice < 800):  # Improve this range check

            if type == "BUY":  # Giving 15 % room to execute on all orders
                price = round(1.15 * strike_lastprice, 1)
            elif type == "SELL":
                price = round(0.85 * strike_lastprice, 1)

            # Here Trig Price will remain None
            # print("Placing Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", strike_lastprice)
            logging.info("Placing Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant),
                         strike_lastprice)
        else:
            logging.info("Price out of range detected. Not placing the order")
            return
    elif (price != None and trig_price != None):
        order_type = kite.ORDER_TYPE_SL  # Order type stop loss  and SL orders.
        # print("Placing SL Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", trig_price)
        logging.info("Placing SL Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant), trig_price)
    elif (price != None and trig_price == None):
        order_type = kite.ORDER_TYPE_LIMIT  # Order type Limit.
        # print("Placing Limit Order ", str(type), " ", symbol, "for Quantity ", str(quant), "at Rs. ", price)
        logging.info("Placing Limit Order %s  %s for Quantity %s at Rs. %s", str(type), symbol, str(quant), price)

    logging.info("trig price is %s price is %s", trig_price, price)
    quant = 50
    try:
        orderid = kite.place_order(variety=kite.VARIETY_REGULAR,  # regular, bo, co or amo.
                                   exchange=kite.EXCHANGE_NFO,
                                   tradingsymbol=symbol,
                                   transaction_type=txn_type,  # BUY/SELL
                                   quantity=quant,  # QUANTITY
                                   product=product_type,  # MIS/NRML/CNC/BO/CO
                                   order_type=order_type,  # MARKET/LIMIT/SL/SL-M
                                   price=price,  # Price if required (e.g. for limit orders).
                                   validity=None,  # Validity period of the order (DAY/IOC), defaults to DAY.
                                   disclosed_quantity=None,  # Quantity to disclosed publicly.
                                   trigger_price=trig_price,
                                   stoploss=None,
                                   trailing_stoploss=None,
                                   tag=None)

        print("Order Id is - ", orderid, " name is ", name)

        # Place orders for hedges as well
    except Exception as e:
        print(e)
        if sl_limit_error in str(e):
            print("SL Limit error, Re Triggering with reduced value")
            # Extracting the circuit limit
            pos1 = str(e).index("below")
            pos2 = str(e).index("[")
            # print("pos", pos1)
            # print("pos", pos2)
            circuit_limit = float(str(e)[pos1 + 6:pos2 - 2])
            # print(circuit_limit)
            trig_price = circuit_limit - 0.5
            orderid = execute_order_multiple(kite, "destination", symbol, type, quant, price, trig_price, product)
        elif limit_lower_circuit_error in str(e):
            print("Limit lower circuit error, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index(") of")
            pos2 = str(e).index("You can")
            print("pos", pos1)
            print("pos", pos2)
            circuit_limit = float(str(e)[pos1 + 5:pos2 - 2])
            print(circuit_limit)
            price = circuit_limit
            orderid = execute_order_multiple(kite, "destination", symbol, type, quant, price, trig_price, product)
        elif error3 in str(e):
            print(
                "Error -Trigger price for stoploss buy orders should be higher than the last traded price, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index("price (")
            pos2 = str(e).index("). Use")
            print("pos", pos1)
            print("pos", pos2)
            extracted_value = float(str(e)[pos1 + 7:pos2])
            print(extracted_value)
            # input("Hello")
            trig_price = extracted_value + 0.5
            orderid = execute_order_multiple(kite, "destination", symbol, type, quant, price, trig_price, product)
        elif error4 in str(e):
            print(
                "Error -Price for stoploss buy orders cannot be above the upper circuit price. Please try placing the order with Price below, Re Triggering with appropriate value")
            # Extracting the circuit limit
            pos1 = str(e).index("below ")
            pos2 = str(e).index(". [")
            print("pos", pos1)
            print("pos", pos2)
            extracted_value = float(str(e)[pos1 + 6:pos2])
            print(extracted_value)
            # input("Hello")
            price = extracted_value - 0.1
            orderid = execute_order_multiple(kite, "destination", symbol, type, quant, price, trig_price, product)
    finally:
        pass
        # print("Exception Caught")

    return orderid


def fetch_order_firstock(order_id):
    """
    :param order_id: order id to fetch order with: INT
    :return: Order Details for given (PLACED) order with order_id  \ String  -=> order has "Status" and Data Array with history of order(pending, mordify, success etc)
    """
    # order id is string
    error_msg = "Couldn\'t find that `order_id`"
    singleOrderHistory = None
    count = 0
    while True:
        try:
            count += 1
            singleOrderHistory = thefirstock.firstock_SingleOrderHistory(
                orderNumber=order_id
            )
        except Exception as e:
            if count > 5:
                print("Fetch Order Max attempts crossed ...Exiting")
                return None
            elif error_msg in str(e):
                print("Order id not found")
                print("Count-", count, "Exception Caught Running again!")
                time.sleep(1)

        if (len(singleOrderHistory) != 0):
            break

    return singleOrderHistory


def fetch_order(order_id):  # Fetches Order object with latest status for given order id
    error_msg = "Couldn\'t find that `order_id`"
    orderhistory = None
    count = 0
    while True:
        try:
            count += 1
            orderhistory = kite.order_history(order_id)
        except Exception as e:
            if count > 5:
                print("Fetch Order Max attempts crossed ...Exiting")
                return None
            elif error_msg in str(e):
                print("Order id not found")
                print("Count-", count, "Exception Caught Running again!")
                time.sleep(1)

        if (orderhistory != None):
            break

    orderhistory_len = len(orderhistory)
    fetched_order_id = orderhistory[orderhistory_len - 1]
    return fetched_order_id


def fetch_order_multiple(kite_of_person, name, order_id):  # Fetches Order object with latest status for given order id
    error_msg = "Couldn\'t find that `order_id`"
    orderhistory = None
    count = 0
    kite = kite_of_person

    while True:
        try:
            count += 1
            orderhistory = kite.order_history(order_id)
        except Exception as e:
            if count > 5:
                print("Fetch Order Max attempts crossed ...Exiting")
                return None
            elif error_msg in str(e):
                print("Order id not found")
                print("Count-", count, "Exception Caught Running again!")
                time.sleep(1)

        if (orderhistory != None):
            break

    orderhistory_len = len(orderhistory)
    fetched_order_id = orderhistory[orderhistory_len - 1]
    return fetched_order_id


def monitor_nifty_moving_strangle(product_type):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            print("Call symbol and quantity is", callsymbol, callquantity)

    pprint(symbol_dict)
    print("Step 4")
    print("Total pnl is ", round(pnl, 1))

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = 300
        call_min_range = 200
        put_max_range = 350
        put_min_range = 250
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        #     call_max_range = 160
        #     call_min_range = 80
        #     put_min_range = 100
        #     put_max_range = 180
        # elif(cur_hour==12 or cur_hour==13 ):
        #     call_max_range = 150
        #     call_min_range = 70
        #     put_max_range = 170
        #     put_min_range = 90
        # if((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        #     call_max_range = 150
        #     call_min_range = 70
        #     put_max_range = 180
        #     put_min_range = 100
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = 550
        call_min_range = 450
        put_max_range = 550
        put_min_range = 450
    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = 400
        call_min_range = 300
        put_max_range = 400
        put_min_range = 300
    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = 350
        call_min_range = 250
        put_max_range = 400
        put_min_range = 300
    elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
        call_max_range = 500
        call_min_range = 400
        put_max_range = 550
        put_min_range = 450

    nifty_cur_price = weekly_nifty_future()

    if (callsymbol == "" and putsymbol == ""):
        print("Found No Positions to Monitor...Exiting!!")
        return 0
    else:
        callstrike = nifty_symbol_to_strike(callsymbol)
        putstrike = nifty_symbol_to_strike(putsymbol)

        put_diff = nifty_cur_price - putstrike
        call_diff = callstrike - nifty_cur_price

        if (call_diff > call_max_range):
            time.sleep(10)
            nifty_cur_price = weekly_nifty_future()
            call_diff = callstrike - nifty_cur_price
            if (call_diff > call_max_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Down")
                call_strike_down_moving_strangle(callstrike, abs(callquantity), product_type)
        elif (call_diff < call_min_range):
            time.sleep(10)
            nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
            call_diff = callstrike - nifty_cur_price
            if (call_diff < call_min_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Up")
                call_strike_up_moving_strangle(callstrike, abs(callquantity), product_type)
        else:
            print("Call Strike Diff is ", int(call_diff), "Nothing to do right now !!")
            print("Will Move Calls Up At ", callstrike - call_min_range)
            print("Will Move Calls Down At ", callstrike - call_max_range)

        if (put_diff > put_max_range):
            time.sleep(10)
            nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
            put_diff = nifty_cur_price - putstrike
            if (put_diff > put_max_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Up")
                put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type)
        elif (put_diff < put_min_range):
            time.sleep(10)
            nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
            if (put_diff < put_min_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Down")
                put_strike_down_moving_strangle(putstrike, abs(putquantity), product_type)
        else:
            print("Put Strike Diff is ", int(put_diff), "Nothing to do right now !!")
            print("Will Move Puts Up At ", putstrike + put_max_range)
            print("Will Move Puts Down At ", putstrike + put_min_range)

    return pnl


def exit_nifty_moving_strangle_multiple_firstock(product_type, filename, expiry_name="nifty"):  # Based on Orderid
    """
    Quits all open positions (BUY OR SELL) from order file only
    :param product_type: "NRML" or "MIS"
    :param filename: Order File
    """
    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    curdate = datetime.datetime.today()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Read mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Net Quantity Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")

    f = open(filename, "a")  # Append Mode
    for symbol in symbol_dict:  # Exit Sell Positions
        quantity = symbol_dict[symbol][0]
        if quantity < 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order_firstock(symbol=symbol, type_="BUY", quant=abs(quantity), price=None,
                                             trig_price=None,
                                             product=product_type)
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order_firstock(orderid)['data'][0]['price']) + "\t" + str(curtime) + "\n")

    for symbol in symbol_dict:  # Exit Buy Positions
        quantity = symbol_dict[symbol][0]
        if quantity > 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order_firstock(symbol=symbol, type_="SELL", quant=abs(quantity), price=None,
                                             trig_price=None,
                                             product=product_type)
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order_firstock(orderid)['data'][0]['price']) + "\t" + str(curtime) + "\n")

    f.close()


def exit_nifty_moving_strangle_multiple(product_type, filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    curdate = datetime.datetime.today()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Read mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Net Quantity Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")

    f = open(filename, "a")  # Append Mode
    for symbol in symbol_dict:  # Exit Sell Positions
        quantity = symbol_dict[symbol][0]
        if quantity < 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=product_type)
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")

    for symbol in symbol_dict:  # Exit Buy Positions
        quantity = symbol_dict[symbol][0]
        if quantity > 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=product_type)
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")

    f.close()


def exit_nifty_moving_strangle_multiple_times(product_type, filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    curdate = datetime.datetime.today()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Read mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Net Quantity Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")

    f = open(filename, "a")  # Append Mode
    for symbol in symbol_dict:  # Exit Sell Positions
        quantity = symbol_dict[symbol][0]
        if quantity < 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order_multiple_times(symbol=symbol, type="BUY", quant=abs(quantity), price=None,
                                                   trig_price=None,
                                                   product=product_type)
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")

    for symbol in symbol_dict:  # Exit Buy Positions
        quantity = symbol_dict[symbol][0]
        if quantity > 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order_multiple_times(symbol=symbol, type="SELL", quant=abs(quantity), price=None,
                                                   trig_price=None,
                                                   product=product_type)
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")

    f.close()


def exit_nifty_moving_strangle(product_type, filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    curdate = datetime.datetime.today()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Read mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Net Quantity Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")

    f = open(filename, "a")  # Append Mode
    for symbol in symbol_dict:  # Exit Sell Positions
        quantity = symbol_dict[symbol][0]
        if quantity < 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=product_type)
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")

    for symbol in symbol_dict:  # Exit Buy Positions
        quantity = symbol_dict[symbol][0]
        if quantity > 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=product_type)
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")

    f.close()


# print("HDFC bank price ltp is :" , kite.ltp('NSE:NIFTY BANK'))
# print("\nHDFC bank price quate is :" , kite.quote('NSE:NIFTY BANK'))

# print(kite.ltp('NFO:BANKNIFTY2180532000CE'))

def exit_nifty_positions_of_producttype(producttype):  # All Nifty Positions whether MIS or normal

    today_positions = kite.positions()

    num_positions = len(today_positions['net'])

    for i in range(num_positions):  # Exit Sell positions first
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        product = today_positions['net'][i]['product']
        if (symbol.startswith('NIFTY') == True):
            if quantity < 0 and product == producttype:
                execute_order(symbol=symbol, type="BUY", quant=(quantity * -1), price=None, trig_price=None,
                              product=product)

    for i in range(num_positions):  # Exit Buy positions later
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        product = today_positions['net'][i]['product']
        if (symbol.startswith('NIFTY') == True):
            if quantity > 0 and product == producttype:
                execute_order(symbol=symbol, type="SELL", quant=quantity, price=None, trig_price=None, product=product)


def exit_nifty_positions():  # All Nifty Positions whether MIS or normal

    today_positions = kite.positions()

    num_positions = len(today_positions['net'])

    for i in range(num_positions):  # Exit Sell positions first
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        product = today_positions['net'][i]['product']
        if (symbol.startswith('NIFTY') == True):
            if quantity < 0:
                execute_order(symbol=symbol, type="BUY", quant=(quantity * -1), price=None, trig_price=None,
                              product=product)

    for i in range(num_positions):  # Exit Buy positions later
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        product = today_positions['net'][i]['product']
        if (symbol.startswith('NIFTY') == True):
            if quantity > 0:
                execute_order(symbol=symbol, type="SELL", quant=quantity, price=None, trig_price=None, product=product)


def exit_banknifty_positions_of_producttype(producttype):
    today_positions = kite.positions()

    num_positions = len(today_positions['net'])

    for i in range(num_positions):  # Exit Sell positions first
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        product = today_positions['net'][i]['product']
        # product=producttype
        if (symbol.startswith('BANK') == True):
            if quantity < 0 and product == producttype:
                execute_order(symbol=symbol, type="BUY", quant=(quantity * -1), price=None, trig_price=None,
                              product=product)

    for i in range(num_positions):  # Exit Buy positions later
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        product = today_positions['net'][i]['product']
        if (symbol.startswith('BANK') == True):
            if quantity > 0 and product == producttype:
                execute_order(symbol=symbol, type="SELL", quant=quantity, price=None, trig_price=None, product=product)


def exit_banknifty_positions():  # All Nifty Positions whether MIS or normal
    today_positions = kite.positions()

    num_positions = len(today_positions['net'])

    for i in range(num_positions):  # Exit Sell positions first
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        product = today_positions['net'][i]['product']
        if (symbol.startswith('BANK') == True):
            if quantity < 0:
                execute_order(symbol=symbol, type="BUY", quant=(quantity * -1), price=None, trig_price=None,
                              product=product)

    for i in range(num_positions):  # Exit Buy positions later
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        product = today_positions['net'][i]['product']
        if (symbol.startswith('BANK') == True):
            if quantity > 0:
                execute_order(symbol=symbol, type="SELL", quant=quantity, price=None, trig_price=None, product=product)


def exit_mis_positions():
    today_positions = kite.positions()
    # pprint(kite.ltp('NFO:BANKNIFTY2181232500PE'))
    # pprint(today_positions)
    # putstrike_lastprice = kite.ltp(putside)[putside]['last_price']
    # pprint(today_positions['day'][0]['tradingsymbol'])
    num_positions = len(today_positions['net'])

    for i in range(num_positions):
        # print(today_positions['net'][i]['tradingsymbol'], today_positions['net'][i]['quantity'])
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if (quantity < 0 and today_positions['net'][i]['product'] == 'MIS'):  # Exit Sell Positions First
            execute_order(symbol=symbol, type="BUY", quant=(quantity * -1), price=None, trig_price=None, product='MIS')

    for i in range(num_positions):
        # print(today_positions['net'][i]['tradingsymbol'], today_positions['net'][i]['quantity'])
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if (quantity > 0 and today_positions['net'][i]['product'] == 'MIS'):  # Now Exit Buy Positions
            execute_order(symbol=symbol, type="SELL", quant=quantity, price=None, trig_price=None, product='MIS')


def exit_call_mis_positions():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    for i in range(num_positions):
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if (symbol.find('CE') > 0 and quantity < 0 and today_positions['net'][i][
            'product'] == 'MIS'):  # Exit Sell Positions First
            execute_order(symbol=symbol, type="BUY", quant=(quantity * -1), price=None, trig_price=None, product='MIS')

    for i in range(num_positions):
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if (symbol.find('CE') > 0 and quantity > 0 and today_positions['net'][i][
            'product'] == 'MIS'):  # Now Exit Buy Positions
            execute_order(symbol=symbol, type="SELL", quant=quantity, price=None, trig_price=None, product='MIS')


def exit_put_mis_positions():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    for i in range(num_positions):
        # print(today_positions['net'][i]['tradingsymbol'], today_positions['net'][i]['quantity'])
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if (symbol.find('PE') > 0 and quantity < 0 and today_positions['net'][i][
            'product'] == 'MIS'):  # Exit Sell Positions First
            execute_order(symbol=symbol, type="BUY", quant=(quantity * -1), price=None, trig_price=None, product='MIS')

    for i in range(num_positions):
        # print(today_positions['net'][i]['tradingsymbol'], today_positions['net'][i]['quantity'])
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if (symbol.find('PE') > 0 and quantity > 0 and today_positions['net'][i][
            'product'] == 'MIS'):  # Now Exit Buy Positions
            execute_order(symbol=symbol, type="SELL", quant=quantity, price=None, trig_price=None, product='MIS')


def exit_sell_mis_positions():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    for i in range(num_positions):
        # print(today_positions['net'][i]['tradingsymbol'], today_positions['net'][i]['quantity'])
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if (quantity < 0 and today_positions['net'][i]['product'] == 'MIS'):  # Exit Sell Positions First
            execute_order(symbol=symbol, type="BUY", quant=(quantity * -1), price=None, trig_price=None, product='MIS')


def exit_buy_mis_positions():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    for i in range(num_positions):
        # print(today_positions['net'][i]['tradingsymbol'], today_positions['net'][i]['quantity'])
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if (quantity > 0 and today_positions['net'][i]['product'] == 'MIS'):  # Exit Sell Positions First
            execute_order(symbol=symbol, type="SELL", quant=(quantity * -1), price=None, trig_price=None, product='MIS')


# get_login(my_api_key,my_api_secret)
# print(kite.positions())

# Expiry Fucntions
def is_cur_expiry_weekly(expiry_name="nifty"):  # Returns True for a weekly expiry and False for a monthly expiry
    global months
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    symbol_expiryday = 0

    if expiry_name == "nifty":
        symbol_expiryday = nifty_expiryday
    elif expiry_name == "banknifty":
        symbol_expiryday = bn_expiryday
    elif expiry_name == "sensex":
        symbol_expiryday = sensex_expiryday
    elif expiry_name == 'midcap':
        symbol_expiryday = midcap_expiryday
    elif expiry_name == 'finnifty':
        symbol_expiryday = fin_expiryday
    else:
        raise Exception("Invalid Expiry Name")

    if curday <= symbol_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = symbol_expiryday - curday
    elif curday > symbol_expiryday:
        days_remaining = symbol_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)

    nextexpirymonth = nextexpirydate.strftime("%m")
    expirymonth = expirydate.strftime("%m")

    if (expirymonth == nextexpirymonth):
        return True
    else:
        return False


# def is_cur_expiry_weekly(expiry_name = "nifty"):  # Returns True for a weekly expiry and False for a monthly expiry
#     global months
#     curdate = datetime.datetime.today()
#     curday = curdate.weekday()

#     if curday <= expiryday:  # 0 Is Monday, 3 is Thursday
#         days_remaining = expiryday - curday
#     elif curday > expiryday:
#         days_remaining = expiryday - curday + 7

#     expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
#     nextexpirydate = expirydate + datetime.timedelta(days=7)

#     nextexpirymonth = nextexpirydate.strftime("%m")
#     expirymonth = expirydate.strftime("%m")

#     if (expirymonth == nextexpirymonth):
#         return True
#     else:
#         return False


def is_cur_sensex_expiry_weekly():  # Returns True for a weekly expiry and False for a monthly expiry
    global months
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= sensex_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = sensex_expiryday - curday
    elif curday > sensex_expiryday:
        days_remaining = sensex_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)

    nextexpirymonth = nextexpirydate.strftime("%m")
    expirymonth = expirydate.strftime("%m")

    if (expirymonth == nextexpirymonth):
        return True
    else:
        return False


def calculate_pnl():  # Total pnl of all current positions whether MIS or NRML
    today_positions = kite.positions()
    # pprint(today_positions['net'])
    num_positions = len(today_positions['net'])
    pnl = 0
    for i in range(num_positions):
        symbol = today_positions['net'][i]['tradingsymbol']
        exch_symbol = 'NFO:' + symbol
        symbol_lastprice = kite.ltp(exch_symbol)[exch_symbol]['last_price']

        quantity = today_positions['net'][i]['quantity']

        if (quantity != 0):  # Unrealised Gains # Active Positions
            pnl += (today_positions['net'][i]['sell_value'] - today_positions['net'][i]['buy_value']) \
                   + (quantity * symbol_lastprice * today_positions['net'][i]['multiplier'])
        else:  # Realised Gains # Booked Positions
            pnl += today_positions['net'][i]['pnl']

    print("Current P/L is ", int(pnl))
    return pnl


def calculate_mis_pnl():
    today_positions = kite.positions()
    # pprint(today_positions['net'])
    num_positions = len(today_positions['net'])
    pnl = 0
    for i in range(num_positions):
        if (today_positions['net'][i]['product'] == 'MIS'):
            symbol = today_positions['net'][i]['tradingsymbol']
            exch_symbol = 'NFO:' + symbol
            symbol_lastprice = kite.ltp(exch_symbol)[exch_symbol]['last_price']

            quantity = today_positions['net'][i]['quantity']

            if (
                    quantity != 0):  # Unrealised Gains # Active Positions  #pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
                pnl += (today_positions['net'][i]['sell_value'] - today_positions['net'][i]['buy_value']) \
                       + (quantity * symbol_lastprice * today_positions['net'][i]['multiplier'])
            else:  # Realised Gains # Booked Positions
                pnl += today_positions['net'][i]['pnl']

    print("Current P/L is ", int(pnl))
    return pnl


def calculate_nrml_pnl():
    today_positions = kite.positions()
    # pprint(today_positions['net'])
    num_positions = len(today_positions['net'])
    pnl = 0
    for i in range(num_positions):
        if (today_positions['net'][i]['product'] == 'NRML'):
            symbol = today_positions['net'][i]['tradingsymbol']
            exch_symbol = 'NFO:' + symbol
            symbol_lastprice = kite.ltp(exch_symbol)[exch_symbol]['last_price']

            quantity = today_positions['net'][i]['quantity']

            if (
                    quantity != 0):  # Unrealised Gains # Active Positions  #pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
                pnl += (today_positions['net'][i]['sell_value'] - today_positions['net'][i]['buy_value']) \
                       + (quantity * symbol_lastprice * today_positions['net'][i]['multiplier'])
            else:  # Realised Gains # Booked Positions
                pnl += today_positions['net'][i]['pnl']

    print("Current P/L is ", int(pnl))
    return pnl


def deploy_nifty_straddle(quantity, producttype,
                          filename):  # Part of Tripple Straddle #Deploys nifty straddle with 25% stop loss #returns strike price

    curdate = datetime.datetime.today()

    # orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "TripleStraddleOrders.txt"
    orders_filename = filename

    niftyprice = weekly_nifty_future()

    if (niftyprice % 50 <= 25):
        straddle_strike = int(niftyprice - (niftyprice % 50))
    else:
        straddle_strike = int(niftyprice - (niftyprice % 50) + 50)

    callsymbol = nifty_strike_to_symbol(straddle_strike, "CALL")
    putsymbol = nifty_strike_to_symbol(straddle_strike, "PUT")

    curtime1 = datetime.datetime.now()
    orderid1 = execute_order(symbol=callsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)

    curtime2 = datetime.datetime.now()
    orderid2 = execute_order(symbol=putsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)

    time.sleep(1)

    f = open(orders_filename, "a")  # For Writing Orders
    f.write(str(orderid1) + "\t" + "SELL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid1)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

    f.write(str(orderid2) + "\t" + "SELL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")

    callstrike_lastprice = kite.ltp('NFO:' + callsymbol)['NFO:' + callsymbol]['last_price']
    callstrike_stoploss = round(callstrike_lastprice * 1.25, 1)

    putstrike_lastprice = kite.ltp('NFO:' + putsymbol)['NFO:' + putsymbol]['last_price']
    putstrike_stoploss = round(putstrike_lastprice * 1.25, 1)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=round(putstrike_stoploss * 1.15, 1),
                            trig_price=putstrike_stoploss, product=producttype)
    f.write(
        str(orderid) + "\t" + "SLL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + "0" + "\t" + str(curtime) + "\n")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=round(callstrike_stoploss * 1.15, 1),
                            trig_price=callstrike_stoploss, product=producttype)
    f.write(str(orderid) + "\t" + "SLL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + "0" + "\t" + str(
        curtime) + "\n")
    f.close()
    return straddle_strike


def deploy_banknifty_straddle(quantity, producttype,
                              filename):  # Part of Tripple Straddle #Deploys nifty straddle with 25% stop loss #returns strike price

    curdate = datetime.datetime.today()

    # orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BNTripleStraddle.txt"
    orders_filename = filename

    bankniftyprice = weekly_banknifty_future()

    if (bankniftyprice % 100 <= 50):
        straddle_strike = int(bankniftyprice - (bankniftyprice % 100))
    else:
        straddle_strike = int(bankniftyprice - (bankniftyprice % 100) + 100)

    callsymbol = banknifty_strike_to_symbol(straddle_strike, "CALL")
    putsymbol = banknifty_strike_to_symbol(straddle_strike, "PUT")

    curtime1 = datetime.datetime.now()
    orderid1 = execute_order(symbol=callsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)

    curtime2 = datetime.datetime.now()
    orderid2 = execute_order(symbol=putsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)

    time.sleep(1)

    f = open(orders_filename, "a")  # For Writing Orders
    f.write(str(orderid1) + "\t" + "SELL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid1)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

    f.write(str(orderid2) + "\t" + "SELL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")

    callstrike_lastprice = kite.ltp('NFO:' + callsymbol)['NFO:' + callsymbol]['last_price']
    callstrike_stoploss = round(callstrike_lastprice * 1.25, 1)

    putstrike_lastprice = kite.ltp('NFO:' + putsymbol)['NFO:' + putsymbol]['last_price']
    putstrike_stoploss = round(putstrike_lastprice * 1.25, 1)

    curtime = datetime.datetime.now()

    orderid = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=round(putstrike_stoploss * 1.15, 1),
                            trig_price=putstrike_stoploss, product=producttype)

    f.write(
        str(orderid) + "\t" + "SLL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + "0" + "\t" + str(curtime) + "\n")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=round(callstrike_stoploss * 1.15, 1),
                            trig_price=callstrike_stoploss, product=producttype)

    f.write(str(orderid) + "\t" + "SLL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + "0" + "\t" + str(
        curtime) + "\n")
    f.close()

    return straddle_strike


def deploy_banknifty_straddle_with_sl(quantity, producttype, filename, stoploss_percentage):
    curdate = datetime.datetime.today()

    # orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BNTripleStraddle.txt"
    orders_filename = filename

    bankniftyprice = weekly_banknifty_future()
    stoploss = stoploss_percentage / 100  # in decimals

    if (bankniftyprice % 100 <= 50):
        straddle_strike = int(bankniftyprice - (bankniftyprice % 100))
    else:
        straddle_strike = int(bankniftyprice - (bankniftyprice % 100) + 100)

    callsymbol = banknifty_strike_to_symbol(straddle_strike, "CALL")
    putsymbol = banknifty_strike_to_symbol(straddle_strike, "PUT")

    curtime1 = datetime.datetime.now()
    orderid1 = execute_order(symbol=callsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)

    curtime2 = datetime.datetime.now()
    orderid2 = execute_order(symbol=putsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)

    time.sleep(1)

    f = open(orders_filename, "a")  # For Writing Orders
    f.write(str(orderid1) + "\t" + "SELL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid1)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

    f.write(str(orderid2) + "\t" + "SELL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")

    callstrike_lastprice = kite.ltp('NFO:' + callsymbol)['NFO:' + callsymbol]['last_price']
    callstrike_stoploss = round(callstrike_lastprice * (1 + stoploss), 1)

    putstrike_lastprice = kite.ltp('NFO:' + putsymbol)['NFO:' + putsymbol]['last_price']
    putstrike_stoploss = round(putstrike_lastprice * (1 + stoploss), 1)

    curtime = datetime.datetime.now()

    orderid = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=round(putstrike_stoploss * 1.15, 1),
                            trig_price=putstrike_stoploss, product=producttype)

    f.write(
        str(orderid) + "\t" + "SLL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + "0" + "\t" + str(curtime) + "\n")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=round(callstrike_stoploss * 1.15, 1),
                            trig_price=callstrike_stoploss, product=producttype)

    f.write(str(orderid) + "\t" + "SLL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + "0" + "\t" + str(
        curtime) + "\n")
    f.close()

    return straddle_strike


def monitor_nifty_triple_straddle(producttype):  # based on order data

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "TripleStraddleOrders.txt"

    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    deploy_new_straddle = False
    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    symbol_dict = {}
    sl_hit = 0
    num_sell_orders = 0
    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl
        if (processed_order_data[i][
            txn_type_index] == 'SLL'):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                print("Stop loss hit at average price", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                sl_hit = 1
            if (cur_order_status == "OPEN"):  # SLL Jumped Handle here
                print("Stop Loss jumped!! Waiting for 3 seconds now")
                time.sleep(3)
                symbol_lastprice = last_price(symbol)
                print("New Price fetched is", symbol_lastprice)
                quantity = processed_order_data[i][quantity_index]
                print("Placing new order at", round(symbol_lastprice * 1.15, 1))

                orderid = execute_order(symbol=symbol, type="BUY", quant=quantity,
                                        price=round(symbol_lastprice * 1.15, 1),
                                        trig_price=None, product=producttype)
                time.sleep(1)
                order = fetch_order(order_id=orderid)
                if (order['status'] == 'COMPLETE'):
                    print("Stop Loss Order executed at second attempt")
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][0])

                    # Adding data to our local variable and turning on sl_hit=1
                    # In next step this data will be written to the file

                    # Adding a new record at the end
                    processed_order_data[num_orders][order_index] = orderid
                    processed_order_data[num_orders][txn_type_index] = 'BUY'
                    processed_order_data[num_orders][symbol_index] = symbol
                    processed_order_data[num_orders][quantity_index] = quantity
                    processed_order_data[num_orders][price_index] = order['average_price']
                    num_orders += 1

                    processed_order_data[i][txn_type_index] = 'CANCELED'
                    sl_hit = 1
                elif (order['status'] == 'OPEN'):
                    print("Stop Loss Order Still in Open State even after 2nd attempt...Do Something")
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][order_index])

                    # Adding data to our local variable and turning on sl_hit=1
                    # In next step this data will be written to the file
                    processed_order_data[num_orders][order_index] = orderid
                    processed_order_data[num_orders][txn_type_index] = 'OPEN'
                    processed_order_data[num_orders][symbol_index] = symbol
                    processed_order_data[num_orders][quantity_index] = quantity
                    processed_order_data[num_orders][price_index] = '0'
                    processed_order_data[i][1] = 'CANCELED'
                    sl_hit = 1
                else:
                    print("Unrecognised Stop Loss Order state")
                # Place next order at symbol_last_price *1.15

        elif (processed_order_data[i][txn_type_index] == 'SELL'):
            num_sell_orders += 1

    num_straddles = num_sell_orders / 2  # Divide by 2 bcoz CE PE both sold at same strike
    print("Step 1")
    pprint(processed_order_data)
    if (sl_hit == 1):  # 3. File to be updated only if SL hit
        print("Updating File")
        f = open(orders_filename, "w")  # For Overwriting Existing Date
        for i in range(num_orders):
            num_parameters = len(processed_order_data[i])
            for j in range(num_parameters):
                f.write(processed_order_data[i][j])
                if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                    f.write("\t")

            f.write("\n")
        f.close()
    print("Step 2")
    if (num_straddles == 0):  # No Straddle found...so returning
        print("No Straddle Deployed...Nothing to Monitor")
        deploy_new_straddle = False
    elif (num_straddles == 3):  # All 3 straddles executed....nothing to do now...so returning
        print("All 3 straddles executed....nothing to do now...")
        deploy_new_straddle = False
    elif (1 <= num_straddles <= 2):
        if (sl_hit == 1):
            deploy_new_straddle = True

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
    pprint(symbol_dict)
    print("Step 4")
    print("Total pnl for Nifty Triple Straddle is ", round(pnl, 1))
    return deploy_new_straddle, pnl


def monitor_banknifty_triple_straddle(producttype):  # based on order data

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    orders_filename = "datafiles\\" + curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "BNTripleStraddle.txt"

    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    deploy_new_straddle = False

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    symbol_dict = {}
    sl_hit = 0
    num_sell_orders = 0
    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl
        if (processed_order_data[i][
            txn_type_index] == 'SLL'):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                print("Stop loss hit at average price", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                sl_hit = 1
            if (cur_order_status == "OPEN"):  # SLL Jumped Handle here
                print("Stop Loss jumped!! Waiting for 3 seconds now")
                time.sleep(3)
                symbol_lastprice = last_price(symbol)
                print("New Price fetched is", symbol_lastprice)
                quantity = processed_order_data[i][quantity_index]
                print("Placing new order at", round(symbol_lastprice * 1.15, 1))

                orderid = execute_order(symbol=symbol, type="BUY", quant=quantity,
                                        price=round(symbol_lastprice * 1.15, 1),
                                        trig_price=None, product=producttype)
                time.sleep(1)
                order = fetch_order(order_id=orderid)
                if (order['status'] == 'COMPLETE'):
                    print("Stop Loss Order executed at second attempt")
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][0])

                    # Adding data to our local variable and turning on sl_hit=1
                    # In next step this data will be written to the file

                    # Adding a new record at the end
                    processed_order_data[num_orders][order_index] = orderid
                    processed_order_data[num_orders][txn_type_index] = 'BUY'
                    processed_order_data[num_orders][symbol_index] = symbol
                    processed_order_data[num_orders][quantity_index] = quantity
                    processed_order_data[num_orders][price_index] = order['average_price']
                    num_orders += 1

                    processed_order_data[i][txn_type_index] = 'CANCELED'
                    sl_hit = 1
                elif (order['status'] == 'OPEN'):
                    print("Stop Loss Order Still in Open State even after 2nd attempt...Do Something")
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][order_index])

                    # Adding data to our local variable and turning on sl_hit=1
                    # In next step this data will be written to the file
                    processed_order_data[num_orders][order_index] = orderid
                    processed_order_data[num_orders][txn_type_index] = 'OPEN'
                    processed_order_data[num_orders][symbol_index] = symbol
                    processed_order_data[num_orders][quantity_index] = quantity
                    processed_order_data[num_orders][price_index] = '0'
                    processed_order_data[i][1] = 'CANCELED'
                    sl_hit = 1
                else:
                    print("Unrecognised Stop Loss Order state")
                # Place next order at symbol_last_price *1.15

        elif (processed_order_data[i][txn_type_index] == 'SELL'):
            num_sell_orders += 1

    num_straddles = num_sell_orders / 2  # Divide by 2 bcoz CE PE both sold at same strike
    # print("Step 1")
    # pprint(processed_order_data)
    if (sl_hit == 1):  # 3. File to be updated only if SL hit
        print("Updating File")
        f = open(orders_filename, "w")  # For Overwriting Existing Date
        for i in range(num_orders):
            num_parameters = len(processed_order_data[i])
            for j in range(num_parameters):
                f.write(processed_order_data[i][j])
                if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                    f.write("\t")

            f.write("\n")
        f.close()
    # print("Step 2")
    if (num_straddles == 0):  # No Straddle found...so returning
        print("No Straddle Deployed...Nothing to Monitor")
        deploy_new_straddle = False
    elif (num_straddles == 3):  # All 3 straddles executed....nothing to do now...so returning
        print("All 3 straddles executed....nothing to do now...")
        deploy_new_straddle = False
    elif (1 <= num_straddles <= 2):
        if (sl_hit == 1):
            deploy_new_straddle = True

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
    pprint(symbol_dict)
    print("Step 4")
    print("Total pnl for Nifty Triple Straddle is ", round(pnl, 1))
    return deploy_new_straddle, pnl


def monitor_banknifty_multiple_straddle(producttype):  # based on order data

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    orders_filename = "datafiles\\" + curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "BNMultipleStraddle.txt"

    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    deploy_new_straddle = False

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    symbol_dict = {}
    sl_hit = 0
    num_sell_orders = 0
    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl
        if (processed_order_data[i][
            txn_type_index] == 'SLL'):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                print("Stop loss hit at average price", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                sl_hit = 1
            if (cur_order_status == "OPEN"):  # SLL Jumped Handle here
                print("Stop Loss jumped!! Waiting for 3 seconds now")
                time.sleep(3)
                symbol_lastprice = last_price(symbol)
                print("New Price fetched is", symbol_lastprice)
                quantity = processed_order_data[i][quantity_index]
                print("Placing new order at", round(symbol_lastprice * 1.15, 1))

                orderid = execute_order(symbol=symbol, type="BUY", quant=quantity,
                                        price=round(symbol_lastprice * 1.15, 1),
                                        trig_price=None, product=producttype)
                time.sleep(1)
                order = fetch_order(order_id=orderid)
                if (order['status'] == 'COMPLETE'):
                    print("Stop Loss Order executed at second attempt")
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][0])

                    # Adding data to our local variable and turning on sl_hit=1
                    # In next step this data will be written to the file

                    # Adding a new record at the end
                    processed_order_data[num_orders][order_index] = orderid
                    processed_order_data[num_orders][txn_type_index] = 'BUY'
                    processed_order_data[num_orders][symbol_index] = symbol
                    processed_order_data[num_orders][quantity_index] = quantity
                    processed_order_data[num_orders][price_index] = order['average_price']
                    num_orders += 1

                    processed_order_data[i][txn_type_index] = 'CANCELED'
                    sl_hit = 1
                elif (order['status'] == 'OPEN'):
                    print("Stop Loss Order Still in Open State even after 2nd attempt...Do Something")
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][order_index])

                    # Adding data to our local variable and turning on sl_hit=1
                    # In next step this data will be written to the file
                    processed_order_data[num_orders][order_index] = orderid
                    processed_order_data[num_orders][txn_type_index] = 'OPEN'
                    processed_order_data[num_orders][symbol_index] = symbol
                    processed_order_data[num_orders][quantity_index] = quantity
                    processed_order_data[num_orders][price_index] = '0'
                    processed_order_data[i][1] = 'CANCELED'
                    sl_hit = 1
                else:
                    print("Unrecognised Stop Loss Order state")
                # Place next order at symbol_last_price *1.15

        elif (processed_order_data[i][txn_type_index] == 'SELL'):
            num_sell_orders += 1

    num_straddles = num_sell_orders / 2  # Divide by 2 bcoz CE PE both sold at same strike
    # print("Step 1")
    # pprint(processed_order_data)
    if (sl_hit == 1):  # 3. File to be updated only if SL hit
        print("Updating File")
        f = open(orders_filename, "w")  # For Overwriting Existing Date
        for i in range(num_orders):
            num_parameters = len(processed_order_data[i])
            for j in range(num_parameters):
                f.write(processed_order_data[i][j])
                if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                    f.write("\t")

            f.write("\n")
        f.close()
    # print("Step 2")
    if (num_straddles == 0):  # No Straddle found...so returning
        print("No Straddle Deployed...Nothing to Monitor")
        deploy_new_straddle = False
    elif (num_straddles == 7):  # All 3 straddles executed....nothing to do now...so returning
        print("All 3 straddles executed....nothing to do now...")
        deploy_new_straddle = False
    elif (1 <= num_straddles <= 6):
        if (sl_hit == 1):
            deploy_new_straddle = True

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
    pprint(symbol_dict)
    print("Step 4")
    print("Total pnl for Nifty Triple Straddle is ", round(pnl, 1))
    return deploy_new_straddle, pnl


def exit_nifty_triple_straddle(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "TripleStraddleOrders.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    symbol_dict = {}
    update_file = 0
    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

        if (processed_order_data[i][
            1] == 'SLL'):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            print("Order Status is:", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                processed_order_data[i][txn_type_index] = 'BUY'
                update_file = 1
            elif (cur_order_status == "TRIGGER PENDING" or cur_order_status == "OPEN"):
                print("Canceling Pending Orders")
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][order_index])
                processed_order_data[i][txn_type_index] = 'CANCELED'
                update_file = 1
    print("Step 1")
    if (update_file == 1):  # 3. File to be updated only if SL hit OR EXIT
        f = open(orders_filename, "w")  # For Overwriting Existing Date
        for i in range(num_orders):
            num_parameters = len(processed_order_data[i])
            for j in range(num_parameters):
                f.write(processed_order_data[i][j])
                if (j != num_parameters - 1):
                    f.write("\t")
            f.write("\n")
        f.close()
    print("Step 2")
    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TrippleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def exit_banknifty_triple_straddle(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BNTripleStraddle.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    symbol_dict = {}
    update_file = 0
    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

        if (processed_order_data[i][
            1] == 'SLL'):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            print("Order Status is:", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                processed_order_data[i][txn_type_index] = 'BUY'
                update_file = 1
            elif (cur_order_status == "TRIGGER PENDING" or cur_order_status == "OPEN"):
                print("Canceling Pending Orders")
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][order_index])
                processed_order_data[i][txn_type_index] = 'CANCELED'
                update_file = 1
    print("Step 1")
    if (update_file == 1):  # 3. File to be updated only if SL hit OR EXIT
        f = open(orders_filename, "w")  # For Overwriting Existing Date
        for i in range(num_orders):
            num_parameters = len(processed_order_data[i])
            for j in range(num_parameters):
                f.write(processed_order_data[i][j])
                if (j != num_parameters - 1):
                    f.write("\t")
            f.write("\n")
        f.close()
    print("Step 2")
    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            time.sleep(1)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TrippleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def exit_banknifty_multiple_straddle(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuandomains@mionlinemarketing.comtity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "BNMultipleStraddle.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    symbol_dict = {}
    update_file = 0
    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

        if (processed_order_data[i][
            1] == 'SLL'):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            print("Order Status is:", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                processed_order_data[i][txn_type_index] = 'BUY'
                update_file = 1
            elif (cur_order_status == "TRIGGER PENDING" or cur_order_status == "OPEN"):
                print("Canceling Pending Orders")
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=processed_order_data[i][order_index])
                processed_order_data[i][txn_type_index] = 'CANCELED'
                update_file = 1
    print("Step 1")
    if (update_file == 1):  # 3. File to be updated only if SL hit OR EXIT
        f = open(orders_filename, "w")  # For Overwriting Existing Date
        for i in range(num_orders):
            num_parameters = len(processed_order_data[i])
            for j in range(num_parameters):
                f.write(processed_order_data[i][j])
                if (j != num_parameters - 1):
                    f.write("\t")
            f.write("\n")
        f.close()
    print("Step 2")
    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            time.sleep(1)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TrippleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode):
    curtime = datetime.datetime.now()
    if firstock_testing_mode:
        executed_price = order['price']
    else:
        executed_price = order['averagePrice']
    f.write(f"{orderid}\t{buy_or_sell}\t{symbol}\t{quantity}\t{executed_price}\t{curtime}\n")


def put_strike_up_moving_strangle_firstock_v2(diff, putstrike, quantity, product_type, filename, expiry_name="nifty"):
    """

    :param diff: INT - HOW MUCH TO MOVE UP
    :param putstrike: INT/STRING - CURRENT PUT STRIKE
    :param quantity: INT
    :param product_type: NOT USED
    :param filename: ORDERS FILENAME
    :param expiry_name: "nifty" or "banknifty" or "finnifty" or "sensex" or "midcap"
    """

    f = open(filename, "a")  # Append mode
    newstrike = int(putstrike) + diff
    cursymbol = firstock_strike_to_symbol(expiry_name, putstrike, 'PUT')
    newsymbol = firstock_strike_to_symbol(expiry_name, newstrike, 'PUT')
    # send_logs("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock_v2(symbol=cursymbol, type_="BUY", quant=quantity, price=None, trig_price=None,
                                        product=product_type, expiry_name=expiry_name)
    time.sleep(0.5)
    order = fetch_order_firstock(orderid)['data'][0]

    if order['status'] == success_status_firstock:
        buy_or_sell = "BUY"
        symbol = cursymbol
        write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
    else:
        time.sleep(2)
        if order['status'] == success_status_firstock:

            buy_or_sell = "BUY"
            symbol = cursymbol
            write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock_v2(symbol=newsymbol, type_="SELL", quant=quantity, price=None, trig_price=None,
                                        product=product_type, expiry_name=expiry_name)
    time.sleep(0.3)
    order = fetch_order_firstock(orderid)['data'][0]
    if order['status'] == success_status_firstock:

        buy_or_sell = "SELL"
        symbol = newsymbol
        write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
    else:
        time.sleep(2)
        if order['status'] == success_status_firstock:

            buy_or_sell = "SELL"
            symbol = newsymbol
            write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_down_moving_strangle_firstock_v2(diff, callstrike, quantity, product_type, filename,
                                                 expiry_name="nifty"):
    """

        :param diff: INT - HOW MUCH TO MOVE UP
        :param putstrike: INT/STRING - CURRENT PUT STRIKE
        :param quantity: INT
        :param product_type: NOT USED
        :param filename: ORDERS FILENAME
        :param expiry_name: "nifty" or "banknifty" or "finnifty" or "sensex" or "midcap"
    """

    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - diff

    cursymbol = firstock_strike_to_symbol(expiry_name, callstrike, 'CALL')
    newsymbol = firstock_strike_to_symbol(expiry_name, newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock_v2(symbol=cursymbol, type_="BUY", quant=quantity, price=None, trig_price=None,
                                        product=product_type, expiry_name=expiry_name)

    time.sleep(0.5)
    order = fetch_order_firstock(orderid)['data'][0]

    if (order['status'] == success_status_firstock):

        buy_or_sell = "BUY"
        symbol = cursymbol
        write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)

    else:

        time.sleep(2)

        if (order['status'] == success_status_firstock):

            buy_or_sell = "BUY"
            symbol = cursymbol
            write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock_v2(symbol=newsymbol, type_="SELL", quant=quantity, price=None, trig_price=None,
                                        product=product_type, expiry_name=expiry_name)
    time.sleep(0.3)
    order = fetch_order_firstock(orderid)['data'][0]
    if (order['status'] == success_status_firstock):

        buy_or_sell = "SELL"
        symbol = newsymbol
        write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
    else:
        time.sleep(2)
        if (order['status'] == success_status_firstock):

            buy_or_sell = "SELL"
            symbol = newsymbol
            write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_up_moving_strangle_firstock_v2(diff, callstrike, quantity, product_type, filename, expiry_name="nifty"):
    """

        :param diff: INT - HOW MUCH TO MOVE UP
        :param putstrike: INT/STRING - CURRENT PUT STRIKE
        :param quantity: INT
        :param product_type: NOT USED
        :param filename: ORDERS FILENAME
        :param expiry_name: "nifty" or "banknifty" or "finnifty" or "sensex" or "midcap"
        """

    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + diff

    cursymbol = firstock_strike_to_symbol(expiry_name, callstrike, 'CALL')
    newsymbol = firstock_strike_to_symbol(expiry_name, newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock_v2(symbol=cursymbol, type_="BUY", quant=quantity, price=None, trig_price=None,
                                        product=product_type, expiry_name=expiry_name)

    time.sleep(0.5)
    order = fetch_order_firstock(orderid)['data'][0]
    print("Here \n Order fetched BUY Order")
    if (order['status'] == success_status_firstock):

        buy_or_sell = "BUY"
        symbol = cursymbol
        write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
    else:

        time.sleep(2)

        if (order['status'] == success_status_firstock):

            buy_or_sell = "BUY"
            symbol = cursymbol
            write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock_v2(symbol=newsymbol, type_="SELL", quant=quantity, price=None, trig_price=None,
                                        product=product_type, expiry_name=expiry_name)
    time.sleep(0.3)
    order = fetch_order_firstock(orderid)['data'][0]
    if (order['status'] == success_status_firstock):

        buy_or_sell = "SELL"
        symbol = newsymbol

        # def write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode):

        write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
    else:
        time.sleep(2)
        if (order['status'] == success_status_firstock):

            buy_or_sell = "SELL"
            symbol = newsymbol
            write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def put_strike_down_moving_strangle_firstock_v2(diff, putstrike, quantity, product_type, filename, expiry_name="nifty"):
    """

        :param diff: INT - HOW MUCH TO MOVE UP
        :param putstrike: INT/STRING - CURRENT PUT STRIKE
        :param quantity: INT
        :param product_type: NOT USED
        :param filename: ORDERS FILENAME
        :param expiry_name: "nifty" or "banknifty" or "finnifty" or "sensex" or "midcap"
    """

    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - diff

    cursymbol = firstock_strike_to_symbol(expiry_name, putstrike, 'PUT')
    newsymbol = firstock_strike_to_symbol(expiry_name, newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock_v2(symbol=cursymbol, type_="BUY", quant=quantity, price=None, trig_price=None,
                                        product=product_type, expiry_name=expiry_name)

    time.sleep(0.5)
    order = fetch_order_firstock(orderid)['data'][0]

    if (order['status'] == success_status_firstock):

        buy_or_sell = "BUY"
        symbol = cursymbol
        write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
    else:

        time.sleep(2)

        if (order['status'] == success_status_firstock):

            buy_or_sell = "BUY"
            symbol = cursymbol
            write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock_v2(symbol=newsymbol, type_="SELL", quant=quantity, price=None, trig_price=None,
                                        product=product_type, expiry_name=expiry_name)
    time.sleep(0.3)
    order = fetch_order_firstock(orderid)['data'][0]
    if (order['status'] == success_status_firstock):

        buy_or_sell = "SELL"
        symbol = newsymbol
        write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
    else:
        time.sleep(2)
        if (order['status'] == success_status_firstock):

            buy_or_sell = "SELL"
            symbol = newsymbol
            write_order_to_file(order, orderid, symbol, buy_or_sell, quantity, f, firstock_testing_mode)
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def exit_nifty_moving_strangle_multiple_firstock_v2(product_type, filename, expiry_name="nifty"):  # Based on Orderid
    """
    Quits all open positions (BUY OR SELL) from order file only
    :param product_type: "NRML" or "MIS"
    :param filename: Order File
    """
    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    curdate = datetime.datetime.today()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Read mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Net Quantity Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")

    f = open(filename, "a")  # Append Mode
    for symbol in symbol_dict:  # Exit Sell Positions
        quantity = symbol_dict[symbol][0]
        if quantity < 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order_firstock_v2(symbol=symbol, type_="BUY", quant=abs(quantity), price=None,
                                                trig_price=None,
                                                product=product_type, expiry_name=expiry_name)
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order_firstock(orderid)['data'][0]['price']) + "\t" + str(curtime) + "\n")

    for symbol in symbol_dict:  # Exit Buy Positions
        quantity = symbol_dict[symbol][0]
        if quantity > 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order_firstock_v2(symbol=symbol, type_="SELL", quant=abs(quantity), price=None,
                                                trig_price=None,
                                                product=product_type, expiry_name=expiry_name)
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order_firstock(orderid)['data'][0]['price']) + "\t" + str(curtime) + "\n")

    f.close()


def put_strike_up_moving_strangle_firstock(putstrike, quantity, product_type, filename, expiry_name="nifty"):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + 50

    cursymbol = firstock_nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = firstock_nifty_strike_to_symbol(newstrike, 'PUT')
    # send_logs("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock(symbol=cursymbol, type_="BUY", quant=quantity, price=None, trig_price=None,
                                     product=product_type)

    time.sleep(0.5)
    order = fetch_order_firstock(orderid)['data'][0]

    if (order['status'] == success_status_firstock):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == success_status_firstock):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock(symbol=newsymbol, type_="SELL", quant=quantity, price=None, trig_price=None,
                                     product=product_type)
    time.sleep(0.3)
    order = fetch_order_firstock(orderid)['data'][0]
    if (order['status'] == success_status_firstock):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == success_status_firstock):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_down_moving_strangle_firstock(callstrike, quantity, product_type, filename, expiry_name="nifty"):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - 50

    cursymbol = firstock_nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = firstock_nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock(symbol=cursymbol, type_="BUY", quant=quantity, price=None, trig_price=None,
                                     product=product_type)

    time.sleep(0.5)
    order = fetch_order_firstock(orderid)['data'][0]

    if (order['status'] == success_status_firstock):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == success_status_firstock):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock(symbol=newsymbol, type_="SELL", quant=quantity, price=None, trig_price=None,
                                     product=product_type)
    time.sleep(0.3)
    order = fetch_order_firstock(orderid)['data'][0]
    if (order['status'] == success_status_firstock):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == success_status_firstock):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_up_moving_strangle_firstock(callstrike, quantity, product_type, filename, expiry_name="nifty"):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + 50

    cursymbol = firstock_nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = firstock_nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock(symbol=cursymbol, type_="BUY", quant=quantity, price=None, trig_price=None,
                                     product=product_type)

    time.sleep(0.5)
    order = fetch_order_firstock(orderid)['data'][0]

    if (order['status'] == success_status_firstock):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == success_status_firstock):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock(symbol=newsymbol, type_="SELL", quant=quantity, price=None, trig_price=None,
                                     product=product_type)
    time.sleep(0.3)
    order = fetch_order_firstock(orderid)['data'][0]
    if (order['status'] == success_status_firstock):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == success_status_firstock):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def put_strike_down_moving_strangle_firstock(putstrike, quantity, product_type, filename, expiry_name="nifty"):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - 50

    cursymbol = firstock_nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = firstock_nifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock(symbol=cursymbol, type_="BUY", quant=quantity, price=None, trig_price=None,
                                     product=product_type)

    time.sleep(0.5)
    order = fetch_order_firstock(orderid)['data'][0]

    if (order['status'] == success_status_firstock):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == success_status_firstock):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_firstock(symbol=newsymbol, type_="SELL", quant=quantity, price=None, trig_price=None,
                                     product=product_type)
    time.sleep(0.3)
    order = fetch_order_firstock(orderid)['data'][0]
    if (order['status'] == success_status_firstock):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == success_status_firstock):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_down_moving_strangle(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - 50

    cursymbol = nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_up_moving_strangle(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + 50

    cursymbol = nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def put_strike_down_moving_strangle(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - 50

    cursymbol = nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = nifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def put_strike_up_moving_strangle(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + 50

    cursymbol = nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = nifty_strike_to_symbol(newstrike, 'PUT')
    # send_logs("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def nifty_nifty_call_strike_down_moving_strangle(diff, callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - diff

    cursymbol = nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def nifty_nifty_call_strike_up_moving_strangle(diff, callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + diff

    cursymbol = nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def nifty_nifty_put_strike_down_moving_strangle(diff, putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - diff

    cursymbol = nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = nifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def nifty_nifty_put_strike_up_moving_strangle(diff, putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + diff

    cursymbol = nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = nifty_strike_to_symbol(newstrike, 'PUT')
    # print("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def fin_nifty_nifty_call_strike_down_moving_strangle(diff, callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - diff

    cursymbol = fin_nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = fin_nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def fin_nifty_nifty_call_strike_up_moving_strangle(diff, callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + diff

    cursymbol = fin_nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = fin_nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def fin_nifty_nifty_put_strike_down_moving_strangle(diff, putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - diff

    cursymbol = fin_nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = fin_nifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def fin_nifty_nifty_put_strike_up_moving_strangle(diff, putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + diff

    cursymbol = fin_nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = fin_nifty_strike_to_symbol(newstrike, 'PUT')
    # send_logs("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def midcap_nifty_call_strike_down_moving_strangle(diff, callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - diff

    cursymbol = midcap_nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = midcap_nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def midcap_nifty_call_strike_up_moving_strangle(diff, callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + diff

    cursymbol = midcap_nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = midcap_nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def midcap_nifty_put_strike_down_moving_strangle(diff, putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - diff

    cursymbol = midcap_nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = midcap_nifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def midcap_nifty_put_strike_up_moving_strangle(diff, putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + diff

    cursymbol = midcap_nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = midcap_nifty_strike_to_symbol(newstrike, 'PUT')
    # send_logs("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def sensex_call_strike_down_moving_strangle(diff, callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - diff

    cursymbol = sensex_strike_to_symbol(callstrike, 'CALL')
    newsymbol = sensex_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def sensex_call_strike_up_moving_strangle(diff, callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + diff

    cursymbol = sensex_strike_to_symbol(callstrike, 'CALL')
    newsymbol = sensex_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def sensex_put_strike_down_moving_strangle(diff, putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - diff

    cursymbol = sensex_strike_to_symbol(putstrike, 'PUT')
    newsymbol = sensex_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def sensex_put_strike_up_moving_strangle(diff, putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + diff

    cursymbol = sensex_strike_to_symbol(putstrike, 'PUT')
    newsymbol = sensex_strike_to_symbol(newstrike, 'PUT')
    # send_logs("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def bank_call_strike_down_moving_strangle(diff, callstrike, quantity, product_type, filename, expiry_name="banknifty"):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - diff

    # cursymbol = banknifty_strike_to_symbol(callstrike, 'CALL')
    # newsymbol = banknifty_strike_to_symbol(newstrike, 'CALL')
    cursymbol = strike_to_symbol_zerodha(callstrike, 'CALL', expiry_name)
    newsymbol = strike_to_symbol_zerodha(newstrike, 'CALL', expiry_name)
    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def bank_call_strike_up_moving_strangle(diff, callstrike, quantity, product_type, filename, expiry_name="banknifty"):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + diff

    # cursymbol = banknifty_strike_to_symbol(callstrike, 'CALL')
    # newsymbol = banknifty_strike_to_symbol(newstrike, 'CALL')
    cursymbol = strike_to_symbol_zerodha(callstrike, 'CALL', expiry_name)
    newsymbol = strike_to_symbol_zerodha(newstrike, 'CALL', expiry_name)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def bank_put_strike_down_moving_strangle(diff, putstrike, quantity, product_type, filename, expiry_name="banknifty"):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - diff

    # cursymbol = banknifty_strike_to_symbol(putstrike, 'PUT')
    # newsymbol = banknifty_strike_to_symbol(newstrike, 'PUT')
    cursymbol = strike_to_symbol_zerodha(putstrike, 'PUT', expiry_name)
    newsymbol = strike_to_symbol_zerodha(newstrike, 'PUT', expiry_name)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def bank_put_strike_up_moving_strangle(diff, putstrike, quantity, product_type, filename, expiry_name="banknifty"):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + diff

    # cursymbol = banknifty_strike_to_symbol(putstrike, 'PUT')
    # newsymbol = banknifty_strike_to_symbol(newstrike, 'PUT')
    cursymbol = strike_to_symbol_zerodha(putstrike, 'PUT', expiry_name)
    newsymbol = strike_to_symbol_zerodha(newstrike, 'PUT', expiry_name)
    # print("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_down_moving_strangle_fin_nifty(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - 50

    cursymbol = fin_nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = fin_nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_up_moving_strangle_fin_nifty(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + 50

    cursymbol = fin_nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = fin_nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def put_strike_down_moving_strangle_fin_nifty(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - 50

    cursymbol = fin_nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = fin_nifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def put_strike_up_moving_strangle_fin_nifty(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + 50

    cursymbol = fin_nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = fin_nifty_strike_to_symbol(newstrike, 'PUT')
    # send_logs("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.5)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:

        time.sleep(2)

        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_down_moving_strangle_multiple_times(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - 50

    cursymbol = nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order_multiple_times(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=product_type)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_multiple_times(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                           product=product_type)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        send_logs("Something Wrong with Order CHeck Now")

    f.close()


def call_strike_up_moving_strangle_multiple_times(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + 50

    cursymbol = nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order_multiple_times(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=product_type)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_multiple_times(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                           product=product_type)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        send_logs("Something Wrong with Order CHeck Now")
    f.close()


def put_strike_down_moving_strangle_multiple_times(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - 50

    cursymbol = nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = nifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order_multiple_times(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=product_type)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_multiple_times(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                           product=product_type)
    order = fetch_order(orderid)
    time.sleep(1)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        send_logs("Something Wrong with Order CHeck Now")
    f.close()


def put_strike_up_moving_strangle_multiple_times(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + 50

    cursymbol = nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = nifty_strike_to_symbol(newstrike, 'PUT')
    # send_logs("Inside call up, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order_multiple_times(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=product_type)
    time.sleep(1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        send_logs("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order_multiple_times(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                           product=product_type)
    time.sleep(1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        send_logs("Something Wrong with Order CHeck Now")

    f.close()


def deploy_nifty_expiry_straddle(quantity,
                                 producttype):  # Part of Tripple Straddle #Deploys nifty straddle with 25% stop loss #returns strike price

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "ExpiryStraddle.txt"
    straddle_low_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "ExpiryStraddleLow.txt"

    niftyprice = weekly_nifty_future()

    if (niftyprice % 50 <= 25):
        straddle_strike = int(niftyprice - (niftyprice % 50))
    else:
        straddle_strike = int(niftyprice - (niftyprice % 50) + 50)

    callsymbol = nifty_strike_to_symbol(straddle_strike, "CALL")
    putsymbol = nifty_strike_to_symbol(straddle_strike, "PUT")

    curtime1 = datetime.datetime.now()
    callorderid = execute_order(symbol=callsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                                product=producttype)

    curtime2 = datetime.datetime.now()
    putorderid = execute_order(symbol=putsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                               product=producttype)

    time.sleep(1)

    call_sell_price = fetch_order(callorderid)['average_price']
    f = open(orders_filename, "a")  # For Writing Orders
    f.write(str(callorderid) + "\t" + "SELL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
        call_sell_price) + "\t" + str(datetime.datetime.now()) + "\n")

    put_sell_price = fetch_order(putorderid)['average_price']
    f.write(str(putorderid) + "\t" + "SELL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
        put_sell_price) + "\t" + str(curtime2) + "\n")
    f.close()

    straddle_sell_price = int(call_sell_price) + int(put_sell_price)
    send_logs("Straddle Price deployed is -" + str(straddle_sell_price))
    f = open(straddle_low_file, 'w')  # Write Mode
    f.write(str(straddle_sell_price))
    f.close

    return straddle_strike


def monitorExpiryStraddle(quantity, producttype):  # Returns True if stoploss hit

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curtime = datetime.datetime.now()
    curdate = datetime.datetime.today()

    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "ExpiryStraddle.txt"
    straddle_low_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "ExpiryStraddleLow.txt"

    # is_straddle=0
    # is_strangle=0
    callsymbol = ""
    putsymbol = ""

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        send_logs("No Data, Returning")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # send_logs("Data fetched from file is- \n" )
    # psend_logs(processed_order_data)

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # send_logs("Data fetched from file is- \n" )
    # psend_logs(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # send_logs(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # psend_logs(symbol_dict)
    print("Step 3")

    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            print("Put symbol  is", putsymbol)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            print("Call symbol  is", callsymbol)

    pnl = round(pnl, 1)

    if (callsymbol != "" and putsymbol == ""):
        print("Not monitoring....Only Put Side active now")
        return pnl
    elif (callsymbol == "" and putsymbol != ""):
        print("Not monitoring....Only Call Side active now")
        return pnl

    is_straddle = False
    callstrike = nifty_symbol_to_strike(callsymbol)  # symbol of 3rd Order
    putstrike = nifty_symbol_to_strike(putsymbol)  # symbol of 3rd Order

    if (callstrike == putstrike):
        print("Straddle is active right now!")
        is_straddle = True
        deployed_strike = callstrike

    print("Call Strike is ", callstrike)
    print("Put Strike is ", putstrike)

    print("No. of Orders is ", num_orders)
    if (is_straddle == True and num_orders < 10):
        nifty_cur_val = weekly_nifty_future()
        print("Nifty Weekly Future - ", nifty_cur_val)

        if abs(nifty_cur_val - deployed_strike) > 40:
            print("Changing the straddle")

            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=abs(quantity), price=None,
                                     trig_price=None, product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=abs(quantity), price=None,
                                     trig_price=None, product=producttype)

            time.sleep(1)

            call_buy_price = fetch_order(orderid1)['average_price']
            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(abs(quantity)) + "\t" + str(
                call_buy_price) + "\t" + str(datetime.datetime.now()) + "\n")

            put_buy_price = fetch_order(orderid2)['average_price']
            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(abs(quantity)) + "\t" + str(
                put_buy_price) + "\t" + str(curtime2) + "\n")
            f.close()

            deploy_nifty_expiry_straddle(abs(quantity), producttype)

            return pnl

    f = open(straddle_low_file, 'r')  # readmode
    filedata = f.read()
    f.close()
    if (filedata != ''):
        call_put_combined_low = float(filedata)
    else:
        print("Straddle/Strangle Low value not found")

    print("Current Straddle/Strangle Price Low is ", call_put_combined_low)

    symbols = [callsymbol, putsymbol]
    symbols_ltp = last_price(symbols)
    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]
    call_put_combined_price = round(callprice + putprice, 2)
    print("Current Straddle/Strangle price is ", call_put_combined_price)

    if (call_put_combined_price < call_put_combined_low):
        print(" Straddle/Strangle price has hit a new low of", call_put_combined_price)
        call_put_combined_low = call_put_combined_price
        f = open(straddle_low_file, 'w')
        f.write(str(call_put_combined_low))
        f.close()

    call_put_combined_stoploss = round(0.8 * call_put_combined_low, 1)

    print("Straddle/Strangle stoploss is at ", call_put_combined_stoploss)
    if (callprice >= call_put_combined_stoploss):
        print("Call Price is ", callprice)
        print("Call Stop Loss Hit!!")
        curtime = datetime.datetime.now()
        orderid = execute_order(symbol=callsymbol, type='BUY', quant=abs(quantity), price=None, trig_price=None,
                                product=producttype)
        time.sleep(1)
        f = open(filename, "a")  # Append mode
        f.write(str(orderid) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(abs(quantity)) + "\t" + str(
            fetch_order(orderid)["average_price"]) + "\t" + str(curtime) + "\n")
        f.close()
        # Now convert to Strangle
        up_strike = int(callstrike)
        putprice = last_price(putsymbol)

        while (True):
            up_strike = up_strike + 50
            callsymbol_up_strike = nifty_strike_to_symbol(up_strike, "CALL")
            if (last_price(callsymbol_up_strike) < putprice):
                callsymbol = callsymbol_up_strike
                curtime = datetime.datetime.now()
                orderid = execute_order(symbol=callsymbol_up_strike, type='SELL', quant=abs(quantity), price=None,
                                        trig_price=None,
                                        product=producttype)
                time.sleep(1)
                call_sell_price = fetch_order(orderid)['average_price']
                f = open(filename, "a")  # Append mode
                f.write(
                    str(orderid) + "\t" + "SELL" + "\t" + callsymbol_up_strike + "\t" + str(abs(quantity)) + "\t" + str(
                        call_sell_price) + "\t" + str(curtime) + "\n")
                f.close()
                break


    elif (putprice >= call_put_combined_stoploss):

        print("Put Price is ", putprice)
        print("Put Stop Loss Hit!!")
        curtime = datetime.datetime.now()
        orderid = execute_order(symbol=putsymbol, type='BUY', quant=abs(quantity), price=None, trig_price=None,
                                product=producttype)
        time.sleep(1)
        f = open(filename, "a")  # Append mode
        f.write(str(orderid) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(abs(quantity)) + "\t" + str(
            fetch_order(orderid)["average_price"]) + "\t" + str(curtime) + "\n")
        f.close()
        callprice = last_price(callsymbol)
        down_strike = int(putstrike)
        # if(call_put_combined_stoploss>=5):
        while (True):
            down_strike = down_strike - 50
            putsymbol_down_strike = nifty_strike_to_symbol(down_strike, "PUT")
            if (last_price(putsymbol_down_strike) < callprice):
                curtime = datetime.datetime.now()
                orderid = execute_order(symbol=putsymbol_down_strike, type='SELL', quant=abs(quantity), price=None,
                                        trig_price=None, product=producttype)
                time.sleep(1)
                f = open(filename, "a")  # Append mode
                f.write(str(orderid) + "\t" + "SELL" + "\t" + putsymbol_down_strike + "\t" + str(
                    abs(quantity)) + "\t" + str(fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
                f.close()
                break
        # else:
        #     orderid = execute_order(symbol=callsymbol, type='BUY', quant=abs(quantity), price=callprice*2+1,
        #                             trig_price=callprice*2, product=producttype)
        #     f = open(filename, "a")  # Append mode
        #     f.write(
        #         str(orderid) + "\t" + "SLL" + "\t" + callsymbol + "\t" + str(abs(quantity)) + "\t" + str(
        #             callprice*2) + "\t" + str(curtime) + "\n")
        #     f.close()

    return pnl


def deploy_banknifty_far_otm_strangle(bnquantity, producttype, CallRange, PutRange):
    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BNFarOTMStrangle.txt"

    banknifty_price = kite.ltp('NSE:NIFTY BANK')['NSE:NIFTY BANK']['last_price']
    print("Current bank nifty price is ", banknifty_price)

    callstrike = banknifty_price + CallRange
    if (callstrike % 500) < 250:
        callstrike = int(callstrike - (callstrike % 500))
    else:
        callstrike = int(callstrike - (callstrike % 500) + 500)
    print("Callstrike for today is ", callstrike)

    putstrike = banknifty_price - PutRange
    if (putstrike % 500) < 250:
        putstrike = int(putstrike - (putstrike % 500))
    else:
        putstrike = int(putstrike - (putstrike % 500) + 500)

    print("Putstrike for today  is ", putstrike)

    putsymbol = banknifty_strike_to_symbol(putstrike, 'PUT')
    callsymbol = banknifty_strike_to_symbol(callstrike, 'CALL')

    curtime = datetime.datetime.now()
    putorderid = execute_order(symbol=putsymbol, type="SELL", quant=bnquantity, price=None, trig_price=None,
                               product=producttype)
    putstrike_price = fetch_order(putorderid)['average_price']

    f = open(filename, "a")  # Append mode
    if (fetch_order(putorderid)['status'] == 'COMPLETE'):
        f.write(str(putorderid) + "\t" + "SELL" + "\t" + putsymbol + "\t" + str(bnquantity) + "\t" + str(
            putstrike_price) + "\t" + str(curtime) + "\n")
    else:
        print("Something wrong with Put order...Check It!")

    curtime = datetime.datetime.now()
    callorderid = execute_order(symbol=callsymbol, type="SELL", quant=bnquantity, price=None, trig_price=None,
                                product=producttype)
    callstrike_price = fetch_order(callorderid)['average_price']
    if (fetch_order(callorderid)['status'] == 'COMPLETE'):
        f.write(str(callorderid) + "\t" + "SELL" + "\t" + callsymbol + "\t" + str(bnquantity) + "\t" + str(
            callstrike_price) + "\t" + str(curtime) + "\n")
    else:
        print("Something wrong with Call order...Check It!")

    time.sleep(1)
    # Place Order for SL
    # SL Orders COmmented for Now Dont Delete it!

    # callstrike_stoploss = round(callstrike_price * 1.8, 1)
    # putstrike_stoploss = round(putstrike_price * 1.8, 1)
    #
    # curtime = datetime.datetime.now()
    # putorderid = execute_order(symbol=putsymbol, type="BUY", quant=bnquantity, price=putstrike_stoploss + 0.5,
    #               trig_price=putstrike_stoploss, product=producttype)
    # f.write(str(putorderid) + "\t" + "SLL" + "\t" + putsymbol + "\t" + str(bnquantity) +"\t"+ '0' +"\t"+str(curtime)+ "\n")

    # curtime = datetime.datetime.now()
    # callorderid =execute_order(symbol=callsymbol, type="BUY", quant=bnquantity, price=callstrike_stoploss + 0.5,
    #               trig_price=callstrike_stoploss, product=producttype)
    # f.write(str(callorderid) + "\t" + "SLL" + "\t" + callsymbol + "\t" + str(bnquantity)+"\t"+ '0' +"\t"+str(curtime)+ "\n")
    f.close()


def monitor_banknifty_far_otm_strangle(producttype, CallRange, PutRange):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    callsymbol = ""
    putsymbol = ""

    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BNFarOTMStrangle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                print("Call symbol is", callsymbol, "Quantity is ", quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                print("Put symbol is", putsymbol, "Quantity is ", quantity)

    pprint(symbol_dict)
    bnquantity = abs(callquantity)

    TotalRange = CallRange + PutRange
    if (callsymbol == "" or putsymbol == ""):
        print("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return round(pnl, 1)

    # CHeck if any adjustment needed
    bn_spot_price = weekly_banknifty_future()
    call_diff = int(banknifty_symbol_to_strike(callsymbol)) - bn_spot_price

    put_diff = TotalRange - call_diff
    print("Call DIff is ", int(call_diff), "\t Put DIff is ", int(put_diff))

    if (CallRange - 500 < call_diff < CallRange + 500):
        print("Strangle in Range as expected!!")
    elif (call_diff <= CallRange - 500 or put_diff <= PutRange - 500):  # Adjust the strangle
        if (call_diff <= CallRange - 500):
            print("Call Diff less than 2000, Moving BN strangle up 500 points")
        elif (put_diff <= PutRange - 500):
            print("Put Diff less than 2500, Moving BN strangle down 500 points")
        # Handling is the same in both the above cases

        # Cancel Stop Loss Orders if any
        # Exit Old Positions
        curtime1 = datetime.datetime.now()
        putorderid = execute_order(symbol=putsymbol, type="BUY", quant=bnquantity, price=None, trig_price=None,
                                   product=producttype)

        curtime2 = datetime.datetime.now()
        callorderid = execute_order(symbol=callsymbol, type="BUY", quant=bnquantity, price=None, trig_price=None,
                                    product=producttype)
        time.sleep(1)

        put_buy_price = fetch_order(putorderid)['average_price']
        call_buy_price = fetch_order(callorderid)['average_price']

        f = open(filename, "a")  # Append mode
        if (fetch_order(putorderid)['status'] == 'COMPLETE'):
            f.write(str(putorderid) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(bnquantity) + "\t" + str(
                put_buy_price) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            print("Something wrong with Put order...Check It!")

        if (fetch_order(callorderid)['status'] == 'COMPLETE'):
            f.write(str(callorderid) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(bnquantity) + "\t" + str(
                call_buy_price) + "\t" + str(curtime2) + "\n")
        else:
            print("Something wrong with Call order...Check It!")
        f.close()

        deploy_banknifty_far_otm_strangle(bnquantity, producttype, CallRange, PutRange)

    return round(pnl, 1)


def exit_banknifty_far_otm_strangle(producttype):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BNFarOTMStrangle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Checking active positions

        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][quantity_dict_index] += quantity
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        symbol_quantity = symbol_dict[symbol][quantity_dict_index]
        if (symbol_quantity < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                print("Call symbol is", callsymbol, "Quantity is ", symbol_quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                print("Put symbol is", putsymbol, "Quantity is ", symbol_quantity)

    curtime = datetime.datetime.now()
    putorderid = execute_order(symbol=putsymbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                               product=producttype)

    callorderid = execute_order(symbol=callsymbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                product=producttype)

    time.sleep(1)

    f = open(filename, "a")  # Append mode
    if (fetch_order(putorderid)['status'] == 'COMPLETE'):
        f.write(str(putorderid) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(abs(quantity)) + "\t" + str(
            fetch_order(putorderid)['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something wrong with Put order...Check It!")

    curtime = datetime.datetime.now()
    if (fetch_order(callorderid)['status'] == 'COMPLETE'):
        f.write(str(callorderid) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(abs(quantity)) + "\t" + str(
            fetch_order(callorderid)['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something wrong with Call order...Check It!")

    f.close()


def exit_banknifty_strangle(producttype, filename):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    curdate = datetime.datetime.today()
    # filename = "datafiles\\" + curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
    #     "%y") + "BN_Strangle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        logging.info("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Checking active positions

        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][quantity_dict_index] += quantity
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        symbol_quantity = symbol_dict[symbol][quantity_dict_index]
        if (symbol_quantity < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = int(symbol_quantity)
                logging.info("Call symbol is %s Quantity is %s", callsymbol, symbol_quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = int(symbol_quantity)
                logging.info("Put symbol is %s Quantity is %s", putsymbol, symbol_quantity)

    putexit = 0
    callexit = 0

    for i in range(num_orders - 1, 0, -1):
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        symbol_order_id = processed_order_data[i][order_index]
        if (symbol == putsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            putexit = 1
        elif (symbol == callsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            callexit = 1
        if (putexit == 1 and callexit == 1):
            break

    time.sleep(2)

    curtime = datetime.datetime.now()
    putorderid = execute_order(symbol=putsymbol, type="BUY", quant=abs(putquantity), price=None, trig_price=None,
                               product=producttype)

    callorderid = execute_order(symbol=callsymbol, type="BUY", quant=abs(callquantity), price=None, trig_price=None,
                                product=producttype)

    time.sleep(2)

    f = open(filename, "a")  # Append mode
    if (fetch_order(putorderid)['status'] == 'COMPLETE'):
        f.write(str(putorderid) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(abs(putquantity)) + "\t" + str(
            fetch_order(putorderid)['average_price']) + "\t" + str(curtime) + "\n")
    else:
        logging.info("Something wrong with Put order...Check It!")

    curtime = datetime.datetime.now()
    if (fetch_order(callorderid)['status'] == 'COMPLETE'):
        f.write(str(callorderid) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(abs(callquantity)) + "\t" + str(
            fetch_order(callorderid)['average_price']) + "\t" + str(curtime) + "\n")
    else:
        logging.info("Something wrong with Call order...Check It!")

    f.close()

    # Hedge Exits
    hedge_callsymbol = None
    hedge_putsymbol = None
    for symbol in symbol_dict:
        symbol_quantity = symbol_dict[symbol][quantity_dict_index]
        if (symbol_quantity > 0):
            if (symbol.find('CE') > 0):
                hedge_callsymbol = symbol
                hedge_callquantity = int(symbol_quantity)
                logging.info("Call Hedge symbol is %s Quantity is %s", callsymbol, symbol_quantity)
            elif (symbol.find('PE') > 0):
                hedge_putsymbol = symbol
                hedge_putquantity = int(symbol_quantity)
                logging.info("Put Hedge symbol is %s Quantity is %s", putsymbol, symbol_quantity)

    curtime = datetime.datetime.now()

    if hedge_putsymbol != None and hedge_callsymbol != None:
        hedge_putorderid = execute_order(symbol=hedge_putsymbol, type="SELL", quant=abs(hedge_putquantity), price=None,
                                         trig_price=None,
                                         product=producttype)

        hedge_callorderid = execute_order(symbol=hedge_callsymbol, type="SELL", quant=abs(hedge_callquantity),
                                          price=None, trig_price=None,
                                          product=producttype)

        time.sleep(2)

        f = open(filename, "a")  # Append mode
        if (fetch_order(hedge_putorderid)['status'] == 'COMPLETE'):
            f.write(str(hedge_putorderid) + "\t" + "SELL" + "\t" + hedge_putsymbol + "\t" + str(
                abs(hedge_putquantity)) + "\t" + str(
                fetch_order(hedge_putorderid)['average_price']) + "\t" + str(curtime) + "\n")
        else:
            logging.info("Something wrong with Put order...Check It!")

        curtime = datetime.datetime.now()
        if (fetch_order(hedge_callorderid)['status'] == 'COMPLETE'):
            f.write(str(hedge_callorderid) + "\t" + "SELL" + "\t" + hedge_callsymbol + "\t" + str(
                abs(hedge_callquantity)) + "\t" + str(
                fetch_order(hedge_callorderid)['average_price']) + "\t" + str(curtime) + "\n")
        else:
            logging.info("Something wrong with Call order...Check It!")

        f.close()


def deploy_nifty_straddle_no_sl(quantity, producttype,
                                filename):  # Part of Tripple Straddle #Deploys nifty straddle with 25% stop loss #returns strike price

    curdate = datetime.datetime.today()

    # orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "TripleStraddleOrders.txt"
    orders_filename = filename

    niftyprice = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']

    if (niftyprice % 50 <= 10):
        straddle_strike = int(niftyprice - (niftyprice % 50))
    else:
        straddle_strike = int(niftyprice - (niftyprice % 50) + 50)

    callsymbol = nifty_strike_to_symbol(straddle_strike, "CALL")
    putsymbol = nifty_strike_to_symbol(straddle_strike, "PUT")

    curtime1 = datetime.datetime.now()
    orderid1 = execute_order(symbol=callsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)

    curtime2 = datetime.datetime.now()
    orderid2 = execute_order(symbol=putsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)
    time.sleep(1)

    f = open(orders_filename, "a")  # For Writing Orders
    f.write(str(orderid1) + "\t" + "SELL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid1)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")
    f.write(str(orderid2) + "\t" + "SELL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
    f.close()
    return straddle_strike


def deploy_nifty_straddle_strike_no_sl(strike, quantity, producttype,
                                       filename):  # Part of Tripple Straddle #Deploys nifty straddle with 25% stop loss #returns strike price

    curdate = datetime.datetime.today()

    # orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "TripleStraddleOrders.txt"
    orders_filename = filename
    straddle_strike = int(strike)

    callsymbol = nifty_strike_to_symbol(straddle_strike, "CALL")
    putsymbol = nifty_strike_to_symbol(straddle_strike, "PUT")

    curtime1 = datetime.datetime.now()
    orderid1 = execute_order(symbol=callsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)

    curtime2 = datetime.datetime.now()
    orderid2 = execute_order(symbol=putsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                             product=producttype)
    time.sleep(1)

    f = open(orders_filename, "a")  # For Writing Orders
    f.write(str(orderid1) + "\t" + "SELL" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid1)['average_price']) + "\t" + str(datetime.datetime.now()) + "\t" + "0" + "\n")
    f.write(str(orderid2) + "\t" + "SELL" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
        fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\t" + "0" + "\n")
    f.close()
    return straddle_strike


def monitor_nifty_moving_straddle(producttype):  # based on order data

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    DownMaxDiff = 35
    DownReversalDiff = 40  # from lower strike
    UpMaxDiff = 15
    UpReversalDiff = 60  # from upper strike
    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0

    for i in range(
            num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}
    sl_hit = 0
    num_sell_orders = 0
    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity
    pprint(symbol_dict)
    prev_strike = None

    deployed_strike = nifty_symbol_to_strike(putsymbol)
    quantity = abs(putquantity)
    nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
    print("Nifty - ", round(nifty_cur_price, 1))
    lower_strike = nifty_cur_price - (nifty_cur_price % 50)
    higher_strike = lower_strike + 50

    if (deployed_strike == lower_strike):
        next_strike = int(higher_strike)
    elif (deployed_strike == int(higher_strike)):
        next_strike = int(lower_strike)
    else:
        print("Strike Changed...Lets change the straddle immediately")
        if (higher_strike - nifty_cur_price <= nifty_cur_price - lower_strike):
            next_strike = int(higher_strike)
        else:
            next_strike = int(lower_strike)

    find_prev = 0
    counter = 0
    reversal = False
    for i in range(num_orders - 1, 0, -1):
        cursymbol = processed_order_data[i][symbol_index]
        if (processed_order_data[i][txn_type_index] == 'BUY' and cursymbol.find(
                'PE') > 0 and find_prev == 0):  # We can check for Put Or Call anyone
            prev_strike = nifty_symbol_to_strike(processed_order_data[i][symbol_index])
            print("Prev Strike is ", prev_strike)
            find_prev += 1
        elif (processed_order_data[i][txn_type_index] == 'SELL' and cursymbol.find('PE') > 0):
            if (nifty_symbol_to_strike(cursymbol) == next_strike or
                    nifty_symbol_to_strike(cursymbol) == deployed_strike):
                counter += 1
            else:
                break
    if (counter % 2 == 0):  # if Even it is reversal code
        reversal = True
    print("Counter", counter, "Reversal", reversal)

    nifty_spot_diff = nifty_cur_price - deployed_strike
    print("Nifty Spot DIff is ", round(nifty_spot_diff, 1))
    change_straddle = False

    if (prev_strike == next_strike and reversal == True):  # Reversal Case
        if (next_strike < deployed_strike and nifty_spot_diff <= -UpReversalDiff):
            print("Reversal - Now Market Going Down, Moving Straddle Down")
            change_straddle = True
        elif (next_strike > deployed_strike and nifty_spot_diff >= DownReversalDiff):
            print("Reversal - Now Market Going Up, Moving Straddle Up")
            change_straddle = True
        else:
            print("Straddle Currently in range !")
            print("No signs of reversal yet")
    elif (nifty_spot_diff <= -DownMaxDiff or nifty_spot_diff >= UpMaxDiff):  # Trending Case
        print("Trending Case")
        change_straddle = True
        if (nifty_spot_diff <= -DownMaxDiff):
            print("Moving Straddle down 50 points")
        elif (nifty_spot_diff >= UpMaxDiff):
            print("Moving Straddle up 50 points")

    else:
        print("Straddle Currently in range !")
        print("Will Move Straddle Up at  !", deployed_strike + UpMaxDiff)
        print("Will Move Straddle down at !", deployed_strike - DownMaxDiff)

    if (change_straddle == True):
        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        curtime2 = datetime.datetime.now()
        orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        deploy_nifty_straddle_strike_no_sl(next_strike, quantity, producttype, filename)

        time.sleep(1)
        f = open(filename, "a")  # For Writing Orders
        f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
            fetch_order(orderid1)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

        f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
            fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
        f.close()

    print("Step 4")
    print("Total pnl for Nifty Moving Straddle is ", round(pnl, 1))
    return pnl


def monitor_nifty_moving_straddle2(producttype):  # based on order data
    # Two things to be done
    # First starting straddle to be deployed based on combined straddle proce
    # Change code for reversal if market stays intact for half n hour
    global order_index, txn_type_index, symbol_index, quantity_index, price_index
    Min_Straddle_Gap = 3
    Max_Straddle_Gap = 7

    reversal_filename = "reversal.txt"
    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle2.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity

    pprint(symbol_dict)

    is_straddle = False
    is_strangle = False

    if (nifty_symbol_to_strike(putsymbol) == nifty_symbol_to_strike(callsymbol)):
        is_straddle = True
    else:
        is_strangle = True

    if is_straddle == True:
        prev_to_prev_strike = None
        prev_strike = None

        deployed_strike = nifty_symbol_to_strike(putsymbol)
        print("Deployed Strike is ", deployed_strike)
        quantity = abs(putquantity)

        # nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
        nifty_cur_price = weekly_nifty_future()
        print("Nifty Future- ", round(nifty_cur_price, 1))
        lower_strike = int(nifty_cur_price - (nifty_cur_price % 50))
        higher_strike = int(lower_strike + 50)

        if (deployed_strike == lower_strike):
            next_strike = int(higher_strike)
        elif (deployed_strike == int(higher_strike)):
            next_strike = int(lower_strike)
        else:
            print("Strike has Changed...")

            instruments = [nifty_strike_to_symbol(higher_strike, "PUT"), nifty_strike_to_symbol(higher_strike, "CALL"),
                           nifty_strike_to_symbol(lower_strike, "PUT"), nifty_strike_to_symbol(lower_strike, "CALL")]
            # print(instruments)
            instrument_prices = last_price(instruments)
            # print(instrument_prices)
            higher_strike_straddle_price = instrument_prices[0] + instrument_prices[1]
            print("Straddle - ", higher_strike, "is at ", higher_strike_straddle_price)
            lower_strike_straddle_price = instrument_prices[2] + instrument_prices[3]
            print("Straddle - ", lower_strike, "is at ", lower_strike_straddle_price)

            if (
                    abs(higher_strike_straddle_price - lower_strike_straddle_price) < Min_Straddle_Gap):  # Move to farther strike
                print("Skipping one strike in between and moving straddle to farther strike")
                if (abs(higher_strike - deployed_strike) > abs(lower_strike - deployed_strike)):
                    next_strike = int(higher_strike)
                else:
                    next_strike = int(lower_strike)
            else:  # Move to nearer strike
                if (abs(higher_strike - deployed_strike) < abs(lower_strike - deployed_strike)):
                    next_strike = int(higher_strike)
                else:
                    next_strike = int(lower_strike)

        # Check for reversal
        find_prev = 0
        counter = 0
        reversal = False

        if (num_orders == 2):  # Only first straddle deployed till now
            f = open(reversal_filename, "r")  # Append mode
            filedata = f.read()
            f.close()
            if (filedata != ''):
                reversal = True
                prev_strike = int(filedata)
                print("Reversal True after First Straddle")
        else:
            for i in range(num_orders - 1, 0, -1):
                cursymbol = processed_order_data[i][symbol_index]
                if (processed_order_data[i][txn_type_index] == 'BUY' and cursymbol.find(
                        'PE') > 0 and find_prev == 0):  # We can check for Put Or Call anyone
                    prev_strike = nifty_symbol_to_strike(processed_order_data[i][symbol_index])
                    print("Prev Strike is ", prev_strike)
                    find_prev += 1
                elif (processed_order_data[i][txn_type_index] == 'SELL' and cursymbol.find('PE') > 0):
                    if (nifty_symbol_to_strike(cursymbol) == next_strike or nifty_symbol_to_strike(
                            cursymbol) == deployed_strike):
                        counter += 1
                    else:
                        if (abs(nifty_symbol_to_strike(cursymbol) - nifty_symbol_to_strike(
                                processed_order_data[i + 1][symbol_index])) > 50):
                            counter += 1
                        break
            if (counter % 2 == 0):  # if Even it is reversal code
                reversal = True
            if (abs(deployed_strike - prev_strike) > 50):  # Strike Jump in between case
                if (deployed_strike > prev_strike):
                    prev_strike += 50
                elif (deployed_strike < prev_strike):
                    prev_strike -= 50

        print("Counter", counter, "Reversal", reversal)
        print("Next Strike", next_strike)
        instruments = [nifty_strike_to_symbol(deployed_strike, "PUT"), nifty_strike_to_symbol(deployed_strike, "CALL"),
                       nifty_strike_to_symbol(next_strike, "PUT"), nifty_strike_to_symbol(next_strike, "CALL")]
        # print(instruments)
        instrument_prices = last_price(instruments)
        # print(instrument_prices)
        cur_strike_straddle_price = instrument_prices[0] + instrument_prices[1]
        next_strike_straddle_price = instrument_prices[2] + instrument_prices[3]

        print("Current Straddle  - ", deployed_strike, "Price is \t", cur_strike_straddle_price)
        print("Next Straddle  - ", next_strike, "Price is \t", next_strike_straddle_price)

        change_straddle = False
        convert_straddle_to_strangle = False

        if ((next_strike_straddle_price - cur_strike_straddle_price) >= Min_Straddle_Gap):
            print("Current straddle is the best, not changing anything!!")
            # DO Nothing
        elif ((next_strike_straddle_price - cur_strike_straddle_price < Min_Straddle_Gap)):
            print("Exiting Current Straddle and moving to ", next_strike, " if its not a reversal")

            if (reversal == True and prev_strike == next_strike):

                # if counter==4 and (next_strike_straddle_price - cur_strike_straddle_price) < -(Min_Straddle_Gap-1): # Repetitive Ping- Pong - Convert to Strangle
                #     print("Repetitive Ping-Pong, convert to strangle")
                #     # convert_straddle_to_strangle=True
                if ((next_strike_straddle_price - cur_strike_straddle_price) < -Max_Straddle_Gap):
                    print("Market Reversing, changing position")
                    change_straddle = True

                else:
                    pass  # do nothing

            else:
                print("Move to Next Strike")
                change_straddle = True

            if (change_straddle == True):
                print("Change Straddle is True, moving straddle to ", next_strike)
                curtime1 = datetime.datetime.now()
                orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                deploy_nifty_straddle_strike_no_sl(next_strike, quantity, producttype, filename)

                time.sleep(1)

                f = open(filename, "a")  # For Writing Orders
                f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid1)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

                f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
                f.close()
            elif (convert_straddle_to_strangle == True):
                print("Change Straddle To Strangle is  True")
                curtime1 = datetime.datetime.now()
                orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                if (deployed_strike > prev_strike):
                    higher_strike = deployed_strike
                    lower_strike = prev_strike
                else:
                    higher_strike = prev_strike
                    lower_strike = deployed_strike

                curtime3 = datetime.datetime.now()
                orderid3 = execute_order(symbol=nifty_strike_to_symbol(higher_strike + 50, "CALL"), type='SELL',
                                         quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                curtime4 = datetime.datetime.now()
                orderid4 = execute_order(symbol=nifty_strike_to_symbol(lower_strike - 50, "PUT"), type='SELL',
                                         quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                time.sleep(1)

                f = open(filename, "a")  # For Writing Orders
                f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid1)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

                f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")

                f.write(
                    str(orderid3) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(higher_strike, "CALL") + "\t" + str(
                        quantity) + "\t" + str(
                        fetch_order(orderid3)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

                f.write(str(orderid4) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(lower_strike - 50,
                                                                                      "PUT") + "\t" + str(
                    quantity) + "\t" + str(
                    fetch_order(orderid4)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
    elif (is_strangle == True):
        print("We are in a strangle...handle it here")

    print("Step 4")
    print("Total pnl for Nifty Moving Straddle is ", round(pnl, 1))
    return pnl


def monitor_nifty_moving_straddle4(producttype):  # based on order data
    # Two things to be done
    # First starting straddle to be deployed based on combined straddle proce
    # Change code for reversal if market stays intact for half n hour
    global order_index, txn_type_index, symbol_index, quantity_index, price_index
    Min_Straddle_Gap = 0
    Max_Straddle_Gap = 9

    reversal_filename = "reversal.txt"
    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle4.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity

    pprint(symbol_dict)

    is_straddle = False
    is_strangle = False

    if (nifty_symbol_to_strike(putsymbol) == nifty_symbol_to_strike(callsymbol)):
        is_straddle = True
    else:
        is_strangle = True

    if is_straddle == True:
        prev_to_prev_strike = None
        prev_strike = None

        deployed_strike = nifty_symbol_to_strike(putsymbol)
        print("Deployed Strike is ", deployed_strike)
        quantity = abs(putquantity)

        # nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
        nifty_cur_price = weekly_nifty_future()
        print("Nifty Future- ", round(nifty_cur_price, 1))
        lower_strike = int(nifty_cur_price - (nifty_cur_price % 100))
        higher_strike = int(lower_strike + 100)

        if (deployed_strike == lower_strike):
            next_strike = int(higher_strike)
        elif (deployed_strike == int(higher_strike)):
            next_strike = int(lower_strike)
        else:
            print("Strike has Changed...")

            instruments = [nifty_strike_to_symbol(higher_strike, "PUT"), nifty_strike_to_symbol(higher_strike, "CALL"),
                           nifty_strike_to_symbol(lower_strike, "PUT"), nifty_strike_to_symbol(lower_strike, "CALL")]
            # print(instruments)
            instrument_prices = last_price(instruments)
            # print(instrument_prices)
            higher_strike_straddle_price = instrument_prices[0] + instrument_prices[1]
            print("Straddle - ", higher_strike, "is at ", higher_strike_straddle_price)
            lower_strike_straddle_price = instrument_prices[2] + instrument_prices[3]
            print("Straddle - ", lower_strike, "is at ", lower_strike_straddle_price)

            if (
                    abs(higher_strike_straddle_price - lower_strike_straddle_price) < Min_Straddle_Gap):  # Move to farther strike
                print("Skipping one strike in between and moving straddle to farther strike")
                if (abs(higher_strike - deployed_strike) > abs(lower_strike - deployed_strike)):
                    next_strike = int(higher_strike)
                else:
                    next_strike = int(lower_strike)
            else:  # Move to nearer strike
                if (abs(higher_strike - deployed_strike) < abs(lower_strike - deployed_strike)):
                    next_strike = int(higher_strike)
                else:
                    next_strike = int(lower_strike)

            print("Next strike is ", next_strike)
        # Check for reversal
        find_prev = 0
        counter = 0
        reversal = False

        if (num_orders == 2):  # Only first straddle deployed till now
            f = open(reversal_filename, "r")  # Append mode
            filedata = f.read()
            f.close()
            if (filedata != '0'):
                reversal = True
                prev_strike = int(filedata)
                print("Reversal True after First Straddle")
            elif (filedata == '0'):
                print("Not a reversal")
        else:
            for i in range(num_orders - 1, 0, -1):
                cursymbol = processed_order_data[i][symbol_index]
                if (processed_order_data[i][txn_type_index] == 'BUY' and cursymbol.find(
                        'PE') > 0 and find_prev == 0):  # We can check for Put Or Call anyone
                    prev_strike = nifty_symbol_to_strike(processed_order_data[i][symbol_index])
                    print("Prev Strike is ", prev_strike)
                    find_prev += 1
                elif (processed_order_data[i][txn_type_index] == 'SELL' and cursymbol.find('PE') > 0):
                    if (nifty_symbol_to_strike(cursymbol) == next_strike or nifty_symbol_to_strike(
                            cursymbol) == deployed_strike):
                        counter += 1

                    else:
                        # if(abs(nifty_symbol_to_strike(cursymbol)-nifty_symbol_to_strike(processed_order_data[i+1][symbol_index]))>50):
                        #     counter += 1
                        break
            if (counter % 2 == 0):  # if Even it is reversal code
                reversal = True
            # if(abs(deployed_strike-prev_strike)>50): #Strike Jump in between case
            #     if(deployed_strike>prev_strike):
            #         prev_strike+=50
            #     elif(deployed_strike<prev_strike):
            #         prev_strike -= 50

        print("Counter", counter, "Reversal", reversal)
        print("Next Strike", next_strike)
        instruments = [nifty_strike_to_symbol(deployed_strike, "PUT"),
                       nifty_strike_to_symbol(deployed_strike, "CALL"),
                       nifty_strike_to_symbol(next_strike, "PUT"),
                       nifty_strike_to_symbol(next_strike, "CALL")]
        if (prev_strike != None):
            instruments.append(nifty_strike_to_symbol(prev_strike, "PUT"))
            instruments.append(nifty_strike_to_symbol(prev_strike, "CALL"))
        # print(instruments)
        instrument_prices = last_price(instruments)
        # print(instrument_prices)
        cur_strike_straddle_price = instrument_prices[0] + instrument_prices[1]
        next_strike_straddle_price = instrument_prices[2] + instrument_prices[3]
        prev_strike_straddle_price = 0
        if (prev_strike != None):
            prev_strike_straddle_price = instrument_prices[4] + instrument_prices[5]
        print("Current Straddle  - ", deployed_strike, "Price is \t", cur_strike_straddle_price)
        print("Next Straddle  - ", next_strike, "Price is \t", next_strike_straddle_price)
        print("Prev Straddle  - ", prev_strike, "Price is \t", prev_strike_straddle_price)

        change_straddle = False
        convert_straddle_to_strangle = False

        if ((next_strike_straddle_price - cur_strike_straddle_price) >= Min_Straddle_Gap):
            print("Current straddle is the best, not changing anything!!")
            # DO Nothing
        elif ((next_strike_straddle_price - cur_strike_straddle_price < Min_Straddle_Gap)):
            print("Exiting Current Straddle and moving to ", next_strike, " if its not a reversal")

            if (reversal == True and prev_strike == next_strike):

                if counter == 4 and (next_strike_straddle_price - cur_strike_straddle_price) < -(
                        Max_Straddle_Gap - 1):  # Repetitive Ping- Pong - Convert to Strangle
                    print("Repetitive Ping-Pong, convert to strangle")
                    # convert_straddle_to_strangle=True
                    change_straddle = True
                elif ((next_strike_straddle_price - cur_strike_straddle_price) < -Max_Straddle_Gap):
                    print("Market Reversing, changing position")
                    change_straddle = True

                else:
                    pass  # do nothing

            else:
                print("Move to Next Strike")
                change_straddle = True

            if (change_straddle == True):
                print("Change Straddle is True, moving straddle to ", next_strike)
                curtime1 = datetime.datetime.now()
                orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                deploy_nifty_straddle_strike_no_sl(next_strike, quantity, producttype, filename)

                time.sleep(1)

                f = open(filename, "a")  # For Writing Orders
                f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

                f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
                f.close()
            elif (convert_straddle_to_strangle == True):
                print("Change Straddle To Strangle is  True")
                curtime1 = datetime.datetime.now()
                orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                if (deployed_strike > prev_strike):
                    higher_strike = deployed_strike
                    lower_strike = prev_strike
                else:
                    higher_strike = prev_strike
                    lower_strike = deployed_strike

                curtime3 = datetime.datetime.now()
                orderid3 = execute_order(symbol=nifty_strike_to_symbol(higher_strike + 50, "CALL"), type='SELL',
                                         quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                curtime4 = datetime.datetime.now()
                orderid4 = execute_order(symbol=nifty_strike_to_symbol(lower_strike - 50, "PUT"), type='SELL',
                                         quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                time.sleep(1)

                f = open(filename, "a")  # For Writing Orders
                f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

                f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")

                f.write(str(orderid3) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(higher_strike + 50,
                                                                                      "CALL") + "\t" + str(
                    quantity) + "\t" + str(
                    fetch_order(orderid3)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

                f.write(str(orderid4) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(lower_strike - 50,
                                                                                      "PUT") + "\t" + str(
                    quantity) + "\t" + str(
                    fetch_order(orderid4)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
    elif (is_strangle == True):
        print("We are in a strangle...handle it here")
        nifty_cur_price = weekly_nifty_future()
        print("Nifty Future -", nifty_cur_price)
        putstrike = nifty_symbol_to_strike(putsymbol)
        print("Putstrike - ", putstrike)
        callstrike = nifty_symbol_to_strike(callsymbol)
        print("Callstrike - ", callstrike)
        quantity = abs(putquantity)  # or can be callquantity
        if ((putstrike + 50) < nifty_cur_price < (callstrike - 50)):
            print("Strangle in expected range...Doing Nothing")
        elif (nifty_cur_price > (callstrike - 50)):
            # Move to Straddle
            print("Changing Straddle to Strangle")
            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime3 = datetime.datetime.now()
            orderid3 = execute_order(symbol=nifty_strike_to_symbol(callstrike - 50, "CALL"), type='SELL',
                                     quant=abs(callquantity), price=None, trig_price=None,
                                     product=producttype)

            curtime4 = datetime.datetime.now()
            orderid4 = execute_order(symbol=nifty_strike_to_symbol(callstrike - 50, "PUT"), type='SELL',
                                     quant=abs(putquantity), price=None, trig_price=None,
                                     product=producttype)

            time.sleep(1)

            f = open(filename, "a")  # For Writing Orders
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")

            f.write(
                str(orderid3) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(callstrike - 50, "CALL") + "\t" + str(
                    quantity) + "\t" + str(
                    fetch_order(orderid3)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(
                str(orderid4) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(callstrike - 50, "PUT") + "\t" + str(
                    quantity) + "\t" + str(
                    fetch_order(orderid4)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (nifty_cur_price < (putstrike + 50)):
            # Move to Straddle
            print("Changing Straddle to Strangle")
            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime3 = datetime.datetime.now()
            orderid3 = execute_order(symbol=nifty_strike_to_symbol(putstrike + 50, "CALL"), type='SELL',
                                     quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime4 = datetime.datetime.now()
            orderid4 = execute_order(symbol=nifty_strike_to_symbol(putstrike + 50, "PUT"), type='SELL',
                                     quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            time.sleep(1)

            f = open(filename, "a")  # For Writing Orders
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")

            f.write(
                str(orderid3) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(putstrike + 50, "CALL") + "\t" + str(
                    quantity) + "\t" + str(
                    fetch_order(orderid3)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(
                str(orderid4) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(putstrike + 50, "PUT") + "\t" + str(
                    quantity) + "\t" + str(
                    fetch_order(orderid4)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()

    print("Step 4")
    print("Total pnl for Nifty Moving Straddle is ", round(pnl, 1))
    return pnl


def monitor_nifty_moving_straddle6(producttype):  # based on order data
    # Two things to be done
    # First starting straddle to be deployed based on combined straddle proce
    # Change code for reversal if market stays intact for half n hour
    global order_index, txn_type_index, symbol_index, quantity_index, price_index
    Min_Straddle_Gap = 0
    Max_Straddle_Gap = 9

    reversal_filename = "reversal.txt"
    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle6.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity

    pprint(symbol_dict)

    is_straddle = False
    is_strangle = False

    if (nifty_symbol_to_strike(putsymbol) == nifty_symbol_to_strike(callsymbol)):
        is_straddle = True
    else:
        is_strangle = True

    if is_straddle == True:
        prev_to_prev_strike = None
        prev_strike = None

        deployed_strike = nifty_symbol_to_strike(putsymbol)
        print("Deployed Strike is ", deployed_strike)
        quantity = abs(putquantity)

        # nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
        nifty_cur_price = weekly_nifty_future()
        print("Nifty Future- ", round(nifty_cur_price, 1))

        if nifty_cur_price < deployed_strike:
            next_strike = deployed_strike - 100
        else:
            next_strike = deployed_strike + 100

        print("Next strike is ", next_strike)

        # Check for reversal
        find_prev = 0
        counter = 0
        reversal = False
        if (num_orders == 2):  # Only first straddle deployed till now
            prev_strike = None
            prev_strike_index = None
        else:
            for i in range(num_orders - 1, 0, -1):
                cursymbol = processed_order_data[i][symbol_index]
                if (processed_order_data[i][txn_type_index] == 'BUY'
                        and cursymbol.find('PE') > 0
                        and find_prev == 0):  # We can check for Put Or Call anyone

                    prev_strike = nifty_symbol_to_strike(processed_order_data[i][symbol_index])
                    prev_strike_index = i - 2  # Index of sell position
                    print("Prev Strike is ", prev_strike)
                    find_prev += 1
                elif (processed_order_data[i][txn_type_index] == 'SELL' and cursymbol.find('PE') > 0):
                    if (nifty_symbol_to_strike(cursymbol) == next_strike or nifty_symbol_to_strike(
                            cursymbol) == deployed_strike) \
                            and processed_order_data[i][6] == '0':
                        counter += 1
                    else:
                        break

            if (counter % 2 == 0):  # if Even it is reversal code
                reversal = True

            prev_counter = 0
            for i in range(num_orders - 1, 0, -1):
                cursymbol = processed_order_data[i][symbol_index]
                if (processed_order_data[i][txn_type_index] == 'SELL' and cursymbol.find('PE') > 0):
                    if (nifty_symbol_to_strike(cursymbol) == prev_strike or nifty_symbol_to_strike(
                            cursymbol) == deployed_strike) \
                            and processed_order_data[i][6] == '0':
                        prev_counter += 1
                    else:
                        break

            print("Prev Counter", prev_counter)
        print("Counter", counter, "Reversal", reversal)
        print("Next Strike", next_strike)
        instruments = [nifty_strike_to_symbol(deployed_strike, "PUT"),
                       nifty_strike_to_symbol(deployed_strike, "CALL"),
                       nifty_strike_to_symbol(next_strike, "PUT"),
                       nifty_strike_to_symbol(next_strike, "CALL")]
        if (prev_strike != None):
            instruments.append(nifty_strike_to_symbol(prev_strike, "PUT"))
            instruments.append(nifty_strike_to_symbol(prev_strike, "CALL"))
        # print(instruments)
        instrument_prices = last_price(instruments)
        # print(instrument_prices)
        cur_strike_straddle_price = instrument_prices[0] + instrument_prices[1]
        next_strike_straddle_price = instrument_prices[2] + instrument_prices[3]
        prev_strike_straddle_price = 0

        if (prev_strike != None):
            prev_strike_straddle_price = instrument_prices[4] + instrument_prices[5]
            if (cur_strike_straddle_price - prev_strike_straddle_price < -Max_Straddle_Gap) \
                    and processed_order_data[prev_strike_index][6] == '0' \
                    and abs(prev_strike - deployed_strike) == 100 \
                    and prev_counter % 2 == 0:  # Dont need to mark 1 immediately after a reversal

                processed_order_data[prev_strike_index][6] = '1'
                processed_order_data[prev_strike_index - 1][6] = '1'
                # Write Data back to file
                print("Current strike has crossed max straddle gap as compared to prev strike ")
                print("Updating File")
                f = open(filename, "w")  # For Overwriting Existing Date
                for i in range(num_orders):
                    num_parameters = len(processed_order_data[i])
                    for j in range(num_parameters):
                        f.write(processed_order_data[i][j])
                        if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                            f.write("\t")
                    f.write("\n")
                f.close()

        print("Current Straddle  - ", deployed_strike, "Price is \t", cur_strike_straddle_price)
        print("Next Straddle  - ", next_strike, "Price is \t", next_strike_straddle_price)
        print("Prev Straddle  - ", prev_strike, "Price is \t", prev_strike_straddle_price)

        change_straddle = False
        convert_straddle_sequence = False
        if ((next_strike_straddle_price - cur_strike_straddle_price) >= Min_Straddle_Gap):
            print("Current straddle is the best, not changing anything!!")
            # DO Nothing
        elif ((next_strike_straddle_price - cur_strike_straddle_price < Min_Straddle_Gap)):
            print("Exiting Current Straddle and moving to ", next_strike, " if its not a reversal")

            if (reversal == True and prev_strike == next_strike):
                if counter == 4 and (next_strike_straddle_price - cur_strike_straddle_price) < -(
                        Max_Straddle_Gap - 3):  # Repetitive Ping- Pong - Convert to Strangle
                    print("Repetitive Ping-Pong, convert to strangle")
                    convert_straddle_sequence = True
                elif ((next_strike_straddle_price - cur_strike_straddle_price) < -Max_Straddle_Gap):
                    print("Market Reversing, changing position")
                    change_straddle = True
                else:
                    pass  # do nothing
            else:
                print("Move to Next Strike")
                change_straddle = True

            if (change_straddle == True or convert_straddle_sequence == True):
                print("Change Straddle is True, moving straddle to ", next_strike)
                curtime1 = datetime.datetime.now()
                orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)

                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                         product=producttype)
                time.sleep(1)

                f = open(filename, "a")  # For Writing Orders
                f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\t" + "0" + "\n")

                f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\t" + "0" + "\n")
                f.close()

                if (change_straddle == True):
                    deploy_nifty_straddle_strike_no_sl(next_strike, quantity, producttype, filename)
                elif (convert_straddle_sequence == True):
                    new_strike = int((deployed_strike + next_strike) / 2)
                    deploy_nifty_straddle_strike_no_sl(new_strike, quantity, producttype, filename)

    print("Step 4")
    print("Total pnl for Nifty Moving Straddle is ", round(pnl, 1))
    return pnl


def exit_nifty_moving_straddle(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(
            num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TripleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def exit_nifty_moving_straddle2(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle2.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(
            num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TripleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def exit_nifty_moving_straddle3(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle3.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(
            num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TripleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def exit_nifty_moving_straddle4(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle4.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(
            num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TripleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def exit_nifty_moving_straddle6(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle6.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(
            num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TripleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def exit_nifty_expiry_straddle(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "ExpiryStraddle.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(
            num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TripleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def move_nifty_straddle_down():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])
    callsymbol = ""
    putsymbol = ""
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('NIFTY') == True) and symbol.find('CE') > 0 and quantity < 0):
            print("Call symbol is", symbol)
            callsymbol = symbol
            callquantity = abs(quantity)
        elif ((symbol.startswith('NIFTY') == True) and symbol.find('PE') > 0 and quantity < 0):
            print("Put symbol is", symbol)
            putsymbol = symbol
            putquantity = abs(quantity)

    if (callsymbol == "" and putsymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:

        curstrike = nifty_symbol_to_strike(callsymbol)
        quantity = callquantity

        newstrike = int(curstrike - 50)

        new_putsymbol = nifty_strike_to_symbol(newstrike, "PUT")
        new_callsymbol = nifty_strike_to_symbol(newstrike, "CALL")

        print("Placing BUY Order", quantity, callsymbol)
        execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None, product='NRML')
        print("Placing BUY Order", quantity, putsymbol)
        execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None, product='NRML')

        print("Placing SELL Order", quantity, putsymbol)
        execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", quantity, callsymbol)
        execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None, product='NRML')


def move_nifty_straddle_up():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])
    callsymbol = ""
    putsymbol = ""
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('NIFTY') == True) and symbol.find('CE') > 0 and quantity < 0):
            print("Call symbol is", symbol)
            callsymbol = symbol
            callquantity = abs(quantity)
        elif ((symbol.startswith('NIFTY') == True) and symbol.find('PE') > 0 and quantity < 0):
            print("Put symbol is", symbol)
            putsymbol = symbol
            putquantity = abs(quantity)

    if (callsymbol == "" and putsymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:

        curstrike = nifty_symbol_to_strike(callsymbol)
        quantity = callquantity

        newstrike = int(curstrike + 50)

        new_putsymbol = nifty_strike_to_symbol(newstrike, "PUT")
        new_callsymbol = nifty_strike_to_symbol(newstrike, "CALL")

        print("Placing BUY Order", quantity, callsymbol)
        execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None, product='NRML')
        print("Placing BUY Order", quantity, putsymbol)
        execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None, product='NRML')

        print("Placing SELL Order", quantity, putsymbol)
        execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", quantity, callsymbol)
        execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None, product='NRML')


def get_nifty_monthly_future_symbol():
    curdate = datetime.datetime.today()
    curyear = curdate.strftime("%y")
    curmonth = curdate.strftime("%m")

    if (curmonth[0] == "0"):
        expirym = curmonth[1]
    else:
        expirym = curmonth

    future_symbol = "NIFTY" + curyear + months[int(expirym)] + "FUT"

    return future_symbol


def get_banknifty_monthly_future_symbol():
    curdate = datetime.datetime.today()
    curyear = curdate.strftime("%y")
    curmonth = curdate.strftime("%m")

    if (curmonth[0] == "0"):
        expirym = curmonth[1]
    else:
        expirym = curmonth

    future_symbol = "BANKNIFTY" + curyear + months[int(expirym)] + "FUT"

    return future_symbol


def get_midcap_nifty_monthly_future_symbol():
    curdate = datetime.datetime.today()
    curyear = curdate.strftime("%y")
    curmonth = curdate.strftime("%m")

    if (curmonth[0] == "0"):
        expirym = curmonth[1]
    else:
        expirym = curmonth

    future_symbol = "MIDCPNIFTY" + curyear + months[int(expirym)] + "FUT"

    return future_symbol


def get_sensex_monthly_future_symbol():
    curdate = datetime.datetime.today()
    curyear = curdate.strftime("%y")
    curmonth = curdate.strftime("%m")

    if (curmonth[0] == "0"):
        expirym = curmonth[1]
    else:
        expirym = curmonth

    future_symbol = "SENSEX" + curyear + months[int(expirym)] + "FUT"

    return future_symbol


def get_finnifty_monthly_future_symbol():
    curdate = datetime.datetime.today()
    curyear = curdate.strftime("%y")
    curmonth = curdate.strftime("%m")

    if (curmonth[0] == "0"):
        expirym = curmonth[1]
    else:
        expirym = curmonth

    future_symbol = "FINNIFTY" + curyear + months[int(expirym)] + "FUT"

    return future_symbol


def weekly_nifty_future():
    if is_cur_expiry_weekly() == True:
        nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']

        mod = nifty_cur_price % 50

        lower_strike = int(nifty_cur_price - mod)
        higher_strike = int(lower_strike + 50)

        if (mod <= 25):
            nearer_strike = lower_strike
        else:
            nearer_strike = higher_strike

        putsymbol = nifty_strike_to_symbol(nearer_strike, "PUT")
        callsymbol = nifty_strike_to_symbol(nearer_strike, "CALL")

        symbol_list = [putsymbol, callsymbol]
        ltp_list = last_price(symbol_list)
        callprice = ltp_list[1]
        putprice = ltp_list[0]

        weekly_future_value = nearer_strike + callprice - putprice

    else:
        print("Its a monthly expiry")
        weekly_future_value = last_price(get_nifty_monthly_future_symbol())

    return weekly_future_value


def getDetailsFromExpiryName_Zerodha(expiry_name):
    """
    Returns the Zerodha symbol name and difference between strikes for a given expiry name.

    Parameters:
    expiry_name (str): The name of the expiry.

    Returns:
    tuple: A tuple containing the Zerodha symbol name and difference between strikes.
    """

    zerodha_symbol_name = None
    difference_between_strikes = None

    if expiry_name == "nifty":
        zerodha_symbol_name = "NSE:NIFTY 50"
        difference_between_strikes = 50
    elif expiry_name == "banknifty":
        zerodha_symbol_name = "NSE:NIFTY BANK"
        difference_between_strikes = 100
    elif expiry_name == "finnifty":
        zerodha_symbol_name = "NSE:NIFTY FIN SERVICE"
        difference_between_strikes = 50
    elif expiry_name == "midcapnifty" or expiry_name == 'midcap':
        zerodha_symbol_name = "NSE:NIFTY MID SELECT"
        difference_between_strikes = 25
    elif expiry_name == "sensex":
        zerodha_symbol_name = "BSE:SENSEX"
        difference_between_strikes = 100

    return zerodha_symbol_name, difference_between_strikes


def get_expiry_type_zerodha(expiry_name):
    """
    Determines whether the current upcoming expiry is a weekly or monthly expiry for a given instrument.

    Args:
    expiry_name (str): The name of the instrument for which to determine the expiry type.

    Returns:
    str: The type of expiry, either 'Weekly' or 'Monthly'.
    """
    global months, exp_day
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'
    exp_day = {
        "sensex": sensex_expiryday,
        "midcap": midcap_expiryday,
        "banknifty": bn_expiryday,
        "nifty": expiryday,
        "finnifty": fin_expiryday
    }.get(expiry_name)

    if curday <= exp_day:  # 0 Is Monday, 3 is Thursday
        days_remaining = exp_day - curday
    elif curday > exp_day:
        days_remaining = exp_day - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'
    return expirytype


def is_cur_expiry_weekly_for_symbol_zerodha(expiry_name):
    """Checks if the current upcoming expiry for a given symbol is weekly.
    
    Args:
        expiry_name (str): The name of the symbol's expiry to check.
        
    Returns:
        bool: True if the current upcoming expiry is weekly, False otherwise.
    """
    global months, exp_day
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    suffix = ''
    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'
    exp_day = {
        "sensex": sensex_expiryday,
        "midcap": midcap_expiryday,
        "banknifty": bn_expiryday,
        "nifty": expiryday,
        "finnifty": fin_expiryday
    }.get(expiry_name)

    if curday <= exp_day:  # 0 Is Monday, 3 is Thursday
        days_remaining = exp_day - curday
    elif curday > exp_day:
        days_remaining = exp_day - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        return True
    else:
        return False


def get_current_expiry_symbol_prefix(expiry_name):
    """
    This function takes an expiry name as input and returns the corresponding symbol prefix for the current upcoming expiry.
    The symbol prefix is used to identify the type of derivative contract being traded.
    The function calculates the current upcoming expiry based on the current date and the expiry day for the given expiry name.
    It then constructs the symbol prefix based on the expiry type (weekly or monthly) and the expiry month and year.
    If the expiry name is not recognized, the function returns None.
    
    Args:
    - expiry_name (str): The name of the expiry for which the symbol prefix is required. Valid values are "sensex", "midcap", "banknifty", "nifty", and "finnifty".
    
    Returns:
    - symbol (str): The symbol prefix for the current upcoming expiry. The symbol is constructed as "<exchange>:<prefix><expiryyear><expirymonth><expiryday>" for weekly expiries, and "<exchange>:<prefix><expiryyear><month_alphabet>" for monthly expiries. If the expiry name is not recognized, the function returns None.
    """

    global months, exp_day
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'
    exp_day = {
        "sensex": sensex_expiryday,
        "midcap": midcap_expiryday,
        "banknifty": bn_expiryday,
        "nifty": expiryday,
        "finnifty": fin_expiryday
    }.get(expiry_name)

    prefix = {
        "sensex": "SENSEX",
        "midcap": "MIDCPNIFTY",
        "banknifty": "BANKNIFTY",
        "nifty": "NIFTY",
        "finnifty": "FINNIFTY"
    }.get(expiry_name, None)

    if curday <= exp_day:  # 0 Is Monday, 3 is Thursday
        days_remaining = exp_day - curday
    elif curday > exp_day:
        days_remaining = exp_day - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth
    exchange = "NFO"
    if expiry_name == "sensex":
        exchange = "BFO"

    month_number = int(expirym)
    if month_number == 10:
        month_alphabet = 'O'
    elif month_number == 11:
        month_alphabet = 'N'
    elif month_number == 12:
        month_alphabet = 'D'
    else:
        month_alphabet = None

    if expirytype == "Weekly":
        if month_alphabet == None:
            symbol = exchange + ":" + prefix + expiryyear + expirym + expiryd
        else:
            symbol = exchange + ":" + prefix + expiryyear + month_alphabet + expiryd
    elif expirytype == "Monthly":
        symbol = exchange + ":" + prefix + expiryyear + months[int(expirym)]
    else:
        symbol = None
    return symbol


def get_symbol_monthly_future_symbol_zerodha(expiry_name):
    """
    Returns the symbol for the monthly future for a given expiry name.

    Parameters:
    expiry_name (str): The name of the expiry.

    Returns:
    str: The symbol for the monthly future for the given expiry name.
    """

    curdate = datetime.datetime.today()
    curyear = curdate.strftime("%y")
    curmonth = curdate.strftime("%m")

    if (curmonth[0] == "0"):
        expirym = curmonth[1]
    else:
        expirym = curmonth

    prefix = {
        "sensex": "SENSEX",
        "midcap": "MIDCPNIFTY",
        "banknifty": "BANKNIFTY",
        "nifty": "NIFTY",
        "finnifty": "FINNIFTY"
    }.get(expiry_name, None)

    future_symbol = prefix + curyear + months[int(expirym)] + "FUT"
    return future_symbol


def strike_to_symbol_zerodha(strike, type, expiry_name):
    """
    This function takes in the strike price, option type (PUT or CALL), and expiry name (sensex, midcap, banknifty, nifty, or finnifty) as input parameters.
    It then calculates the upcoming expiry date based on the current date and the expiry day of the given expiry name.
    Using this expiry date, it generates a symbol for the given strike price, option type, and expiry name.
    The generated symbol is returned as the output of the function.
    """
    global months, exp_day
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    suffix = ''
    if (type == "PUT"):
        suffix = 'PE'
    elif (type == "CALL"):
        suffix = 'CE'
    exp_day = {
        "sensex": sensex_expiryday,
        "midcap": midcap_expiryday,
        "banknifty": bn_expiryday,
        "nifty": expiryday,
        "finnifty": fin_expiryday
    }.get(expiry_name)

    if curday <= exp_day:  # 0 Is Monday, 3 is Thursday
        days_remaining = exp_day - curday
    elif curday > exp_day:
        days_remaining = exp_day - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    # print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    prefix = {
        "sensex": "SENSEX",
        "midcap": "MIDCPNIFTY",
        "banknifty": "BANKNIFTY",
        "nifty": "NIFTY",
        "finnifty": "FINNIFTY"
    }.get(expiry_name, None)

    month_number = int(expirym)
    if month_number == 10:
        month_alphabet = 'O'
    elif month_number == 11:
        month_alphabet = 'N'
    elif month_number == 12:
        month_alphabet = 'D'
    else:
        month_alphabet = None

    if (expirytype == "Weekly"):
        if month_alphabet == None:
            symbol = prefix + expiryyear + expirym + expiryd + str(strike) + suffix
        else:
            symbol = prefix + expiryyear + month_alphabet + expiryd + str(strike) + suffix
    elif (expirytype == "Monthly"):
        symbol = prefix + expiryyear + months[int(expirym)] + str(strike) + suffix
    else:
        symbol = None
    return symbol


def synthetic_symbol_future(expiry_name):
    """
    Calculates the weekly future value of a given expiry name.

    Parameters:
    expiry_name (str): The name of the expiry.

    Returns:
    float: The weekly future value of the given expiry name.
    """

    expiry_type = get_expiry_type_zerodha(expiry_name)
    symbol_token_zerodha, difference_between_strikes = getDetailsFromExpiryName_Zerodha(expiry_name)

    if expiry_type == "Weekly":
        symbol_current_price = kite.ltp(symbol_token_zerodha)[symbol_token_zerodha]['last_price']
        mod = symbol_current_price % difference_between_strikes
        lower_strike = int(symbol_current_price - mod)
        higher_strike = int(lower_strike + difference_between_strikes)

        if (mod <= (difference_between_strikes / 2.0)):
            nearer_strike = lower_strike
        else:
            nearer_strike = higher_strike

        putsymbol = strike_to_symbol_zerodha(nearer_strike, "PUT", expiry_name)
        callsymbol = strike_to_symbol_zerodha(nearer_strike, "CALL", expiry_name)

        symbol_list = [putsymbol, callsymbol]
        if expiry_name == "sensex":
            ltp_list = last_price_sensex(symbol_list)
        else:
            ltp_list = last_price(symbol_list)
        callprice = ltp_list[1]
        putprice = ltp_list[0]

        weekly_future_value = nearer_strike + callprice - putprice

    else:
        print("Its a monthly expiry")

        if expiry_name == "sensex":

            weekly_future_value = last_price_sensex(get_symbol_monthly_future_symbol_zerodha(expiry_name))
        else:
            weekly_future_value = last_price(get_symbol_monthly_future_symbol_zerodha(expiry_name))
        # weekly_future_value = last_price(get_expiry_type_zerodha(expiry_name))

    return weekly_future_value


def weekly_banknifty_future():
    if is_cur_expiry_weekly() == True:
        banknifty_cur_price = kite.ltp('NSE:NIFTY BANK')['NSE:NIFTY BANK']['last_price']

        mod = banknifty_cur_price % 100

        lower_strike = int(banknifty_cur_price - mod)
        higher_strike = int(lower_strike + 100)

        if (mod <= 50):
            nearer_strike = lower_strike
        else:
            nearer_strike = higher_strike

        putsymbol = banknifty_strike_to_symbol(nearer_strike, "PUT")
        callsymbol = banknifty_strike_to_symbol(nearer_strike, "CALL")

        symbol_list = [putsymbol, callsymbol]
        ltp_list = last_price(symbol_list)
        callprice = ltp_list[1]
        putprice = ltp_list[0]

        weekly_future_value = nearer_strike + callprice - putprice

    else:
        print("Its a monthly expiry")
        weekly_future_value = last_price(get_banknifty_monthly_future_symbol())

    return weekly_future_value


def weekly_midcap_nifty_future():
    if is_cur_expiry_weekly() == True:
        midcap_nifty_cur_price = kite.ltp('NSE:NIFTY MID SELECT')['NSE:NIFTY MID SELECT']['last_price']

        mod = midcap_nifty_cur_price % 50

        lower_strike = int(midcap_nifty_cur_price - mod)
        higher_strike = int(lower_strike + 50)

        if (mod <= 25):
            nearer_strike = lower_strike
        else:
            nearer_strike = higher_strike

        putsymbol = midcap_nifty_strike_to_symbol(nearer_strike, "PUT")
        callsymbol = midcap_nifty_strike_to_symbol(nearer_strike, "CALL")

        symbol_list = [putsymbol, callsymbol]
        ltp_list = last_price(symbol_list)
        callprice = ltp_list[1]
        putprice = ltp_list[0]

        weekly_future_value = nearer_strike + callprice - putprice

    else:
        print("Its a monthly expiry")
        weekly_future_value = last_price(get_midcap_nifty_monthly_future_symbol())

    return weekly_future_value


def weekly_sensex_future():
    if is_cur_sensex_expiry_weekly() == True:
        sensex_cur_price = kite.ltp('BSE:SENSEX')['BSE:SENSEX']['last_price']

        mod = sensex_cur_price % 100

        lower_strike = int(sensex_cur_price - mod)
        higher_strike = int(lower_strike + 100)

        if (mod <= 50):
            nearer_strike = lower_strike
        else:
            nearer_strike = higher_strike

        putsymbol = sensex_strike_to_symbol(nearer_strike, "PUT")
        callsymbol = sensex_strike_to_symbol(nearer_strike, "CALL")

        symbol_list = [putsymbol, callsymbol]
        ltp_list = last_price_sensex(symbol_list)
        callprice = ltp_list[1]
        putprice = ltp_list[0]

        weekly_future_value = nearer_strike + callprice - putprice

    else:
        print("Its a monthly expiry")
        weekly_future_value = last_price_sensex(get_sensex_monthly_future_symbol())

    return weekly_future_value


def weekly_banknifty_future_using_firstock():
    # if is_cur_expiry_weekly() == True:
    banknifty_cur_price = float(
        thefirstock.firstock_getQuoteLTP(exchange="NSE", token="Nifty Bank")['data']['lastTradedPrice'])

    mod = banknifty_cur_price % 100

    lower_strike = int(banknifty_cur_price - mod)
    higher_strike = int(lower_strike + 100)

    if (mod <= 50):
        nearer_strike = lower_strike
    else:
        nearer_strike = higher_strike

    # putsymbol = banknifty_strike_to_symbol(nearer_strike, "PUT")
    # callsymbol = banknifty_strike_to_symbol(nearer_strike, "CALL")

    # symbol_list = [putsymbol, callsymbol]
    # ltp_list = last_price(symbol_list)
    # callprice = ltp_list[1]
    # putprice = ltp_list[0]

    putsymbol = firstock_banknifty_strike_to_symbol(nearer_strike, "PUT")
    callsymbol = firstock_banknifty_strike_to_symbol(nearer_strike, "CALL")

    callprice = float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=callsymbol)['data']['lastTradedPrice'])
    putprice = float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=putsymbol)['data']['lastTradedPrice'])

    weekly_future_value = nearer_strike + callprice - putprice

    # ppp.set_trace()

    # else:
    #     print("Its a monthly expiry")
    #     weekly_future_value = last_price(get_banknifty_monthly_future_symbol())

    return weekly_future_value


def getDetailsFromExpiryName_Firstock(expiry_name):
    """

    :param expiry_name: STRING: nifty, banknifty, finnifty, midcap, sensex
    :return exchange, token, token_scrip, diff_between_two_strikes
    """
    exchange = "NSE"
    token = ""
    diff_between_two_strikes = 0
    token_scrip = ""
    if expiry_name == "nifty":
        exchange = "NSE"
        token = "Nifty 50"
        token_scrip = "26000"
        diff_between_two_strikes = 50
    elif expiry_name == "banknifty":
        exchange = "NSE"
        token = "Nifty Bank"
        token_scrip = "26009"
        diff_between_two_strikes = 100

    elif expiry_name == "finnifty":
        exchange = "NSE"
        token = "Nifty Fin Service"
        token_scrip = "26037"
        diff_between_two_strikes = 50

    elif expiry_name == "midcap":
        exchange = "NSE"
        token = "NIFTY MID SELECT"
        token_scrip = "26074"
        diff_between_two_strikes = 25
    elif expiry_name == "sensex":
        exchange = "BSE"
        token = "SENSEX"
        token_scrip = "1"
        diff_between_two_strikes = 100

    return exchange, token, token_scrip, diff_between_two_strikes


def weekly_future_using_firstock(expiry_name):
    """

    :param expiry_name: STRING: nifty, banknifty, finnifty, midcap, sensex
    :return: Returns synthetic future values for options/ futures
    """

    exchange, token, token_scrip, diff_between_two_strikes = getDetailsFromExpiryName_Firstock(expiry_name)

    # if is_cur_expiry_weekly() == True:

    # mod is difference in strikes (nifty has 50 strike diff between each strikes)
    try:
        symbol_cur_price = float(
            thefirstock.firstock_getQuoteLTP(exchange=exchange, token=token)['data']['lastTradedPrice'])
    except Exception as e:
        time.sleep(1)
        symbol_cur_price = float(
            thefirstock.firstock_getQuoteLTP(exchange=exchange, token=token)['data']['lastTradedPrice'])

    mod = symbol_cur_price % diff_between_two_strikes
    lower_strike = int(symbol_cur_price - mod)
    higher_strike = int(lower_strike + diff_between_two_strikes)

    if mod <= diff_between_two_strikes / 2:
        nearer_strike = lower_strike
    else:
        nearer_strike = higher_strike

    putsymbol = firstock_strike_to_symbol(expiry_name, nearer_strike, "PUT")
    callsymbol = firstock_strike_to_symbol(expiry_name, nearer_strike, "CALL")

    symbol_list = [putsymbol, callsymbol]
    symbol_index = None
    if exchange == "NSE":
        symbol_index = "NFO"
    elif exchange == "BSE":
        symbol_index = "BFO"

    try:
        ltp_list = last_price_firstock(symbol_list, symbol_index)
    except Exception as e:
        time.sleep(0.5)
        ltp_list = last_price_firstock(symbol_list, symbol_index)
    callprice = ltp_list[1]
    putprice = ltp_list[0]

    weekly_future_value = nearer_strike + callprice - putprice
    return weekly_future_value

    # else:
    #     print("Its a monthly expiry")
    #     weekly_future_value = last_price(get_nifty_monthly_future_symbol())


# write code for anchored vwap on nifty chart
# write code for anchored vwap on banknifty chart


def weekly_nifty_future_using_firstock():
    """
    :return: Returns synthetic future values for options/ futures
    """
    # if is_cur_expiry_weekly() == True:
    try:
        nifty_cur_price = float(
            thefirstock.firstock_getQuoteLTP(exchange="NSE", token="Nifty 50")['data']['lastTradedPrice'])
    except Exception as e:
        time.sleep(1)
        nifty_cur_price = float(
            thefirstock.firstock_getQuoteLTP(exchange="NSE", token="Nifty 50")['data']['lastTradedPrice'])

    mod = nifty_cur_price % 50

    lower_strike = int(nifty_cur_price - mod)
    higher_strike = int(lower_strike + 50)

    if (mod <= 25):
        nearer_strike = lower_strike
    else:
        nearer_strike = higher_strike
    putsymbol = firstock_nifty_strike_to_symbol(nearer_strike, "PUT")
    callsymbol = firstock_nifty_strike_to_symbol(nearer_strike, "CALL")

    symbol_list = [putsymbol, callsymbol]
    symbol_index = "NFO"
    try:
        ltp_list = last_price_firstock(symbol_list, symbol_index)
    except Exception as e:
        time.sleep(0.5)
        ltp_list = last_price_firstock(symbol_list, symbol_index)
    callprice = ltp_list[1]
    putprice = ltp_list[0]

    weekly_future_value = nearer_strike + callprice - putprice
    return weekly_future_value

    # else:
    #     print("Its a monthly expiry")
    #     weekly_future_value = last_price(get_nifty_monthly_future_symbol())


def weekly_fin_nifty_future_using_firstock():
    # if is_cur_expiry_weekly() == True:
    fin_nifty_cur_price = float(
        thefirstock.firstock_getQuoteLTP(exchange="NSE", token="Nifty Fin Service")['data']['lastTradedPrice'])

    mod = fin_nifty_cur_price % 50

    lower_strike = int(fin_nifty_cur_price - mod)
    higher_strike = int(lower_strike + 50)

    if (mod <= 25):
        nearer_strike = lower_strike
    else:
        nearer_strike = higher_strike

    # putsymbol = banknifty_strike_to_symbol(nearer_strike, "PUT")
    # callsymbol = banknifty_strike_to_symbol(nearer_strike, "CALL")

    # symbol_list = [putsymbol, callsymbol]
    # ltp_list = last_price(symbol_list)
    # callprice = ltp_list[1]
    # putprice = ltp_list[0]

    putsymbol = firstock_fin_nifty_strike_to_symbol(nearer_strike, "PUT")
    callsymbol = firstock_fin_nifty_strike_to_symbol(nearer_strike, "CALL")

    callprice = float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=callsymbol)['data']['lastTradedPrice'])
    putprice = float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=putsymbol)['data']['lastTradedPrice'])

    weekly_future_value = nearer_strike + callprice - putprice

    # ppp.set_trace()

    # else:
    #     print("Its a monthly expiry")
    #     weekly_future_value = last_price(get_banknifty_monthly_future_symbol())

    return weekly_future_value


def weekly_midcap_nifty_future_using_firstock():
    # if is_cur_expiry_weekly() == True:
    midcap_nifty_cur_price = float(
        thefirstock.firstock_getQuoteLTP(exchange="NSE", token="NIFTY MID SELECT")['data']['lastTradedPrice'])

    mod = midcap_nifty_cur_price % 50

    lower_strike = int(midcap_nifty_cur_price - mod)
    higher_strike = int(lower_strike + 50)

    if (mod <= 25):
        nearer_strike = lower_strike
    else:
        nearer_strike = higher_strike

    # putsymbol = banknifty_strike_to_symbol(nearer_strike, "PUT")
    # callsymbol = banknifty_strike_to_symbol(nearer_strike, "CALL")

    # symbol_list = [putsymbol, callsymbol]
    # ltp_list = last_price(symbol_list)
    # callprice = ltp_list[1]
    # putprice = ltp_list[0]

    putsymbol = firstock_midcap_nifty_strike_to_symbol(nearer_strike, "PUT")
    callsymbol = firstock_midcap_nifty_strike_to_symbol(nearer_strike, "CALL")

    callprice = float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=callsymbol)['data']['lastTradedPrice'])
    putprice = float(thefirstock.firstock_getQuoteLTP(exchange="NFO", token=putsymbol)['data']['lastTradedPrice'])

    weekly_future_value = nearer_strike + callprice - putprice

    # ppp.set_trace()

    # else:
    #     print("Its a monthly expiry")
    #     weekly_future_value = last_price(get_banknifty_monthly_future_symbol())

    return weekly_future_value


def weekly_finnifty_future():
    if is_cur_expiry_weekly() == True:
        finnifty_cur_price = kite.ltp('NSE:NIFTY FIN SERVICE')['NSE:NIFTY FIN SERVICE']['last_price']

        mod = finnifty_cur_price % 50

        lower_strike = int(finnifty_cur_price - mod)
        higher_strike = int(lower_strike + 50)

        if (mod <= 25):
            nearer_strike = lower_strike
        else:
            nearer_strike = higher_strike

        putsymbol = finnifty_strike_to_symbol(nearer_strike, "PUT")
        callsymbol = finnifty_strike_to_symbol(nearer_strike, "CALL")

        symbol_list = [putsymbol, callsymbol]
        ltp_list = last_price(symbol_list)
        callprice = ltp_list[1]
        putprice = ltp_list[0]

        weekly_future_value = nearer_strike + callprice - putprice

    else:
        print("Its a monthly expiry")
        weekly_future_value = last_price(get_finnifty_monthly_future_symbol())

    return weekly_future_value


def spot_straddle_price():
    weekly_future_value = weekly_nifty_future()
    print("Weekly future value is ", weekly_future_value)
    mod = weekly_future_value % 50
    lower_strike = int(weekly_future_value - mod)
    higher_strike = int(lower_strike + 50)

    symbol_list = [nifty_strike_to_symbol(lower_strike, "PUT"), nifty_strike_to_symbol(lower_strike, "CALL"),
                   nifty_strike_to_symbol(higher_strike, "PUT"), nifty_strike_to_symbol(higher_strike, "CALL")]

    ltp_list = last_price(symbol_list)

    lower_strike_straddle_price = ltp_list[0] + ltp_list[1]
    higher_strike_straddle_price = ltp_list[2] + ltp_list[3]

    spot_straddle_price = round((lower_strike_straddle_price * (50 - mod) + higher_strike_straddle_price * mod) / 50, 2)

    return spot_straddle_price


def nifty_enter_straddle(producttype, quantity):
    curdate = datetime.datetime.today()
    nifty_future_val = weekly_nifty_future()

    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStraddle3.txt"
    reversal_filename = "reversal.txt"

    print("Nifty Weekly Future- ", round(nifty_future_val, 1))
    lower_strike = int(nifty_future_val - (nifty_future_val % 50))
    higher_strike = int(lower_strike + 50)

    instruments = [nifty_strike_to_symbol(higher_strike, "PUT"), nifty_strike_to_symbol(higher_strike, "CALL"),
                   nifty_strike_to_symbol(lower_strike, "PUT"), nifty_strike_to_symbol(lower_strike, "CALL")]

    # print(instruments)
    instrument_prices = last_price(instruments)
    # print(instrument_prices)
    higher_strike_straddle_price = instrument_prices[0] + instrument_prices[1]
    print("Straddle - ", higher_strike, "is at ", higher_strike_straddle_price)
    lower_strike_straddle_price = instrument_prices[2] + instrument_prices[3]
    print("Straddle - ", lower_strike, "is at ", lower_strike_straddle_price)
    # Hedges BUY

    if ((higher_strike_straddle_price - lower_strike_straddle_price) > 3):  # Move to farther strike
        deploy_nifty_straddle_strike_no_sl(lower_strike, quantity, producttype, filename)
        f = open(reversal_filename, "w")  # Append mode
        f.write("0")
        f.close()
    elif ((lower_strike_straddle_price - higher_strike_straddle_price) > 3):
        deploy_nifty_straddle_strike_no_sl(higher_strike, quantity, producttype, filename)
        f = open(reversal_filename, "w")  # Append mode
        f.write("0")
        f.close()
    else:
        print("Reversal True")
        if (
                higher_strike_straddle_price > lower_strike_straddle_price):  # Here Reversal code needs to be implemented next
            deploy_nifty_straddle_strike_no_sl(higher_strike, quantity, producttype, filename)
        else:
            deploy_nifty_straddle_strike_no_sl(lower_strike, quantity, producttype, filename)

        f = open(reversal_filename, "w")  # Append mode
        f.write("1")
        f.close()


def check_pnl(filename):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStraddle3.txt"
    # straddle_min_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "StraddleMin.txt"
    # straddle_max_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "StraddleMax.txt"
    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    # print("hello")
    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0, None, None, None, None, None

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    pprint(symbol_dict)
    print("Step 3")
    putsymbol = None
    callsymbol = None
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity
    return pnl, callsymbol, callquantity, putsymbol, putquantity, symbol_dict


def monitor_nifty_moving_straddle3(producttype, callsymbol, callquantity, putsymbol, putquantity,
                                   symbol_dict):  # based on order data
    # Two things to be done
    # First starting straddle to be deployed based on combined straddle proce
    # Change code for reversal if market stays intact for half n hour
    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStraddle3.txt"
    reversal_filename = "reversal.txt"
    # pprint(symbol_dict)

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))

    prev_to_prev_strike = None
    prev_strike = None

    deployed_strike = nifty_symbol_to_strike(putsymbol)
    print("Deployed Strike is ", deployed_strike)
    quantity = abs(putquantity)

    nifty_future_val = weekly_nifty_future()
    print("Nifty Weekly Future- ", round(nifty_future_val, 1))
    lower_strike = int(nifty_future_val - (nifty_future_val % 50))
    higher_strike = int(lower_strike + 50)

    if (deployed_strike == lower_strike):
        next_strike = int(higher_strike)
    elif (deployed_strike == int(higher_strike)):
        next_strike = int(lower_strike)
    else:
        print("Strike has Changed...")

        instruments = [nifty_strike_to_symbol(higher_strike, "PUT"), nifty_strike_to_symbol(higher_strike, "CALL"),
                       nifty_strike_to_symbol(lower_strike, "PUT"), nifty_strike_to_symbol(lower_strike, "CALL")]
        # print(instruments)
        instrument_prices = last_price(instruments)
        # print(instrument_prices)
        higher_strike_straddle_price = instrument_prices[0] + instrument_prices[1]
        print("Straddle - ", higher_strike, "is at ", higher_strike_straddle_price)
        lower_strike_straddle_price = instrument_prices[2] + instrument_prices[3]
        print("Straddle - ", lower_strike, "is at ", lower_strike_straddle_price)

        if (abs(higher_strike_straddle_price - lower_strike_straddle_price) < 3):  # Move to farther strike
            print("Skipping one strike in between and moving straddle to farther strike")
            if (abs(higher_strike - deployed_strike) > abs(lower_strike - deployed_strike)):
                next_strike = int(higher_strike)
            else:
                next_strike = int(lower_strike)
        else:  # Move to nearer strike
            if (abs(higher_strike - deployed_strike) < abs(lower_strike - deployed_strike)):
                next_strike = int(higher_strike)
            else:
                next_strike = int(lower_strike)

    # Check for reversal
    find_prev = 0
    counter = 0
    reversal = False

    if (num_orders == 2):  # Only first straddle deployed till now
        f = open(reversal_filename, "r")  # Append mode
        filedata = f.read()
        f.close()
        if (filedata == "1"):
            reversal = True
            print("Reversal True after First Straddle")
    else:
        for i in range(num_orders - 1, 0, -1):
            cursymbol = processed_order_data[i][symbol_index]
            if (processed_order_data[i][txn_type_index] == 'BUY' and cursymbol.find(
                    'PE') > 0 and find_prev == 0):  # We can check for Put Or Call anyone
                prev_strike = nifty_symbol_to_strike(processed_order_data[i][symbol_index])
                print("Prev Strike is ", prev_strike)
                find_prev += 1
            elif (processed_order_data[i][txn_type_index] == 'SELL' and cursymbol.find('PE') > 0):
                if (nifty_symbol_to_strike(cursymbol) == next_strike or nifty_symbol_to_strike(
                        cursymbol) == deployed_strike):
                    counter += 1
                else:
                    if (abs(nifty_symbol_to_strike(cursymbol) - nifty_symbol_to_strike(
                            processed_order_data[i + 1][symbol_index])) > 50):
                        counter += 1
                    break
        if (counter % 2 == 0):  # if Even it is reversal code
            reversal = True

    print("Counter", counter, "Reversal", reversal)
    print("Next Strike", next_strike)
    instruments = [nifty_strike_to_symbol(deployed_strike, "PUT"), nifty_strike_to_symbol(deployed_strike, "CALL"),
                   nifty_strike_to_symbol(next_strike, "PUT"), nifty_strike_to_symbol(next_strike, "CALL")]
    # print(instruments)
    instrument_prices = last_price(instruments)
    # print(instrument_prices)
    cur_strike_straddle_price = instrument_prices[0] + instrument_prices[1]
    next_strike_straddle_price = instrument_prices[2] + instrument_prices[3]

    print("Current Straddle  - ", deployed_strike, "Price is \t", cur_strike_straddle_price)
    print("Next Straddle  - ", next_strike, "Price is \t", next_strike_straddle_price)

    change_straddle = False
    convert_straddle_to_strangle = False

    if ((next_strike_straddle_price - cur_strike_straddle_price) >= 3):
        print("Current straddle is the best, not changing anything!!")
        # DO Nothing
    elif ((next_strike_straddle_price - cur_strike_straddle_price < 3)):
        print("Exiting Current Straddle and moving to ", next_strike, " if its not a reversal")

        if (reversal == True and (prev_strike == next_strike or num_orders == 2)):

            if counter == 4 and (
                    next_strike_straddle_price - cur_strike_straddle_price) < -5:  # Repetitive Ping- Pong - Convert to Strangle
                print("Repetitive Ping-Pong, convert to strangle")
                convert_straddle_to_strangle = True
            elif ((next_strike_straddle_price - cur_strike_straddle_price) < -6):
                print("Market Reversing, changing position")
                change_straddle = True

            else:
                pass  # do nothing

        else:
            print("Move to Next Strike")
            change_straddle = True

        if (change_straddle == True):
            print("Change Straddle is True, moving straddle to ", next_strike)
            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            deploy_nifty_straddle_strike_no_sl(next_strike, quantity, producttype, filename)

            time.sleep(1)

            f = open(filename, "a")  # For Writing Orders
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
            f.close()
        elif (convert_straddle_to_strangle == True):
            print("Change Straddle To Strangle is  True")
            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            if (deployed_strike > prev_strike):
                higher_strike = deployed_strike
                lower_strike = prev_strike
            else:
                higher_strike = prev_strike
                lower_strike = deployed_strike

            curtime3 = datetime.datetime.now()
            orderid3 = execute_order(symbol=nifty_strike_to_symbol(higher_strike, "CALL"), type='SELL', quant=quantity,
                                     price=None, trig_price=None,
                                     product=producttype)

            curtime4 = datetime.datetime.now()
            orderid4 = execute_order(symbol=nifty_strike_to_symbol(lower_strike - 50, "PUT"), type='SELL',
                                     quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            time.sleep(1)

            f = open(filename, "a")  # For Writing Orders
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")

            f.write(str(orderid3) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(higher_strike, "CALL") + "\t" + str(
                quantity) + "\t" + str(
                fetch_order(orderid3)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(
                str(orderid4) + "\t" + "SELL" + "\t" + nifty_strike_to_symbol(lower_strike - 50, "PUT") + "\t" + str(
                    quantity) + "\t" + str(
                    fetch_order(orderid4)['average_price']) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()


def monitor_nifty_moving_straddle5(producttype):  # based on order data
    # Two things to be done
    # First starting straddle to be deployed based on combined straddle proce
    # Change code for reversal if market stays intact for half n hour
    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle5.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity

    pprint(symbol_dict)

    is_straddle = False
    is_strangle = False

    if (nifty_symbol_to_strike(putsymbol) == nifty_symbol_to_strike(callsymbol)):
        is_straddle = True
    else:
        is_strangle = True

    if is_straddle == True:

        deployed_strike = nifty_symbol_to_strike(putsymbol)
        print("Deployed Straddle Strike is ", deployed_strike)
        quantity = abs(putquantity)

        # nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
        nifty_cur_price = weekly_nifty_future()
        print("Nifty Future- ", round(nifty_cur_price, 1))

        if (nifty_cur_price >= deployed_strike + 50):
            print("Converting to strangle up side")
            next_callsymbol = nifty_strike_to_symbol(deployed_strike + 100, 'CALL')

            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=next_callsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            time.sleep(1)

            f = open(filename, "a")  # For Writing Orders
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + next_callsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
            f.close()


        elif (nifty_cur_price <= deployed_strike - 50):
            print("Converting to strangle down side")
            next_putsymbol = nifty_strike_to_symbol(deployed_strike - 100, 'PUT')

            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=next_putsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            time.sleep(1)

            f = open(filename, "a")  # For Writing Orders
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + next_putsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
            f.close()

        else:
            print("Current Straddle is the best...not doing anything here !!")

    elif (is_strangle == True):
        print("We are in a strangle...handling it here")
        nifty_cur_price = weekly_nifty_future()
        print("Nifty Future -", nifty_cur_price)
        putstrike = nifty_symbol_to_strike(putsymbol)
        print("Putstrike - ", putstrike)
        callstrike = nifty_symbol_to_strike(callsymbol)
        print("Callstrike - ", callstrike)
        quantity = abs(putquantity)  # or can be callquantity

        if (putstrike < nifty_cur_price < callstrike):
            print("Strangle in expected range...Doing Nothing")
        elif (nifty_cur_price >= (callstrike - 10)):
            # Move to Straddle
            print("Changing Strangle to Upper Straddle")
            next_putsymbol = nifty_strike_to_symbol(callstrike, 'PUT')

            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=putsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=next_putsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            time.sleep(1)

            f = open(filename, "a")  # For Writing Orders
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + next_putsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
            f.close()
        elif (nifty_cur_price <= (putstrike + 10)):
            # Move to Straddle
            print("Changing Strangle to Lower Straddle")
            next_callsymbol = nifty_strike_to_symbol(putstrike, 'CALL')

            curtime1 = datetime.datetime.now()
            orderid1 = execute_order(symbol=callsymbol, type='BUY', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=next_callsymbol, type='SELL', quant=quantity, price=None, trig_price=None,
                                     product=producttype)

            time.sleep(1)

            f = open(filename, "a")  # For Writing Orders
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid1)['average_price']) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + next_callsymbol + "\t" + str(quantity) + "\t" + str(
                fetch_order(orderid2)['average_price']) + "\t" + str(curtime2) + "\n")
            f.close()

    print("Step 4")
    print("Total pnl for Nifty Moving Straddle is ", round(pnl, 1))
    return pnl


def exit_nifty_moving_straddle5(producttype):  # Based on order id

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    curdate = datetime.datetime.today()
    orders_filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "MovingStraddle5.txt"
    f = open(orders_filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(
            num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass
        else:
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        # product_type=order['product']
        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        if (quantity == 0):
            continue
        elif (quantity < 0):  # Sell Position active, so need to place buy order
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()
        elif (
                quantity > 0):  # Buy Position active, so need to place buy order #WIll not be used in TripleStraddle but creating this code as generic code
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=producttype)
            f = open(orders_filename, "a")
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")
            f.close()


def monitor_banknifty_strangle(producttype, day_premium, adjustment_level, filename,
                               DeRiskPoints, StopLossPoints, expiry_end_code, adjustment_leg_matching_factor):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    # DeRiskPoints= 20 # day_premium*2
    # StopLossPoints = DeRiskPoints+5

    sl_hit = 0
    callsymbol = ""
    putsymbol = ""
    # adjustment_level = 1.75
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        logging.info("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                logging.info("Call symbol is %s Quantity is %s", callsymbol, quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = quantity
                logging.info("Put symbol is %s Quantity is %s", putsymbol, quantity)

    logging.info(symbol_dict)
    quantity = abs(callquantity)

    if (callsymbol == "" and putsymbol == ""):
        logging.info("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return round(pnl, 1)
    elif (callsymbol == ""):
        logging.info("No Active Call symbol found...Looks like some problem...Exiting all positions")
        exit_banknifty_strangle(producttype, filename)
        return round(pnl, 1)
    elif (putsymbol == ""):
        logging.info("No Active Put symbol found...Looks like some problem...Exiting all positions")
        exit_banknifty_strangle(producttype, filename)
        return round(pnl, 1)

    symbols = [callsymbol, putsymbol]
    symbols_ltp = last_price(symbols)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    logging.info("Call price is %s", callprice)
    logging.info("Put price is %s", putprice)

    if (callprice > putprice):
        higher_price = callprice
        higher_symbol = callsymbol
        lower_price = putprice
        lower_symbol = putsymbol
    else:
        higher_price = putprice
        higher_symbol = putsymbol
        lower_price = callprice
        lower_symbol = callsymbol

    logging.info("Current Ratio of both legs is %s", round(higher_price / lower_price, 2))
    # print("Max Loss points is ", MaxLossPoints)

    sl_count = 0
    for i in range(num_orders - 1, 0, -1):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (processed_order_data[i][
            txn_type_index] == 'SLL' and (
                symbol == callsymbol or symbol == putsymbol)):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            sl_count += 1
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            logging.info("SLL order status is - %s", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                logging.info("Stop loss hit at average price %s", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                stop_loss_symbol = symbol
                sl_hit = 1
                break
            elif (sl_count == 2):
                logging.info("Sl not hit yet")
                break
    if (sl_hit == 1):
        # Update the file
        # Cancel the other SL order - Done
        # Exit the active leg - Done
        # Place new orders- Done

        if (stop_loss_symbol == callsymbol):
            logging.info("Call leg cut by SL, cancelling PUT SL and cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=producttype)
            # time.sleep(2)

            logging.info("Updating File - Replacing SLL with BUY")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()

            putprice_buy = fetch_order(putorderid_buy)['average_price']

            if (putprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    putprice_buy) + "\t" + str(curtime1) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        elif (stop_loss_symbol == putsymbol):
            logging.info("Put leg cut by SL, cancelling CALL SLand cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                            product=producttype)
            # time.sleep(2)
            logging.info("Updating File")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()
            callprice_buy = fetch_order(callorderid_buy)['average_price']

            if (callprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    callprice_buy) + "\t" + str(curtime1) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        logging.info("Starting both positions afresh now")

        banknifty_cur_price = weekly_banknifty_future()
        banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)
        put_strike_new = banknifty_atm_strike
        call_strike_new = banknifty_atm_strike

        while (True):

            putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

            symbols = [callsymbol_new, putsymbol_new]
            symbols_ltp = last_price(symbols)
            callprice_new = symbols_ltp[0]
            putprice_new = symbols_ltp[1]

            if (callprice_new > day_premium):
                call_strike_new += 100
            if (putprice_new > day_premium):
                put_strike_new -= 100

            if (callprice_new < day_premium and putprice_new < day_premium):
                break

        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None,
                                       trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None,
                                        trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity,
                                       price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        if putstrike_price_new > 0:
            f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
                putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &s order did not get executed....Some problem ...check ", putsymbol_new)

        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        if callstrike_price_new > 0:
            f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
                callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &sorder did not get executed....Some problem ...check ", callsymbol_new)

        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        f.close()
    elif ((higher_price > day_premium + DeRiskPoints) or expiry_end_code == 1):
        logging.info("Cutting both positions and de-risking")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()
        putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime2 = datetime.datetime.now()
        callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        logging.info("Starting both positions afresh now")

        banknifty_cur_price = weekly_banknifty_future()
        banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)
        put_strike_new = banknifty_atm_strike
        call_strike_new = banknifty_atm_strike

        while (True):

            putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

            symbols = [callsymbol_new, putsymbol_new]
            symbols_ltp = last_price(symbols)
            callprice_new = symbols_ltp[0]
            putprice_new = symbols_ltp[1]

            if (callprice_new > day_premium):
                call_strike_new += 100
            if (putprice_new > day_premium):
                put_strike_new -= 100

            if (callprice_new < day_premium and putprice_new < day_premium):
                break
        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putprice_buy = fetch_order(putorderid_buy)['average_price']
        callprice_buy = fetch_order(callorderid_buy)['average_price']

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
            putprice_buy) + "\t" + str(curtime1) + "\n")
        f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
            callprice_buy) + "\t" + str(curtime2) + "\n")

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()
        if (expiry_end_code == 1):
            time.sleep(60)
            expiry_end_code = 0
    elif (higher_price / lower_price >= adjustment_level and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = banknifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * adjustment_leg_matching_factor):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return round(pnl, 1)
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(curtime1) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return round(pnl, 1)

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(curtime2) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(curtime2) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = banknifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice * adjustment_leg_matching_factor):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return round(pnl, 1)

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(curtime1) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return round(pnl, 1)

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(curtime1) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(curtime2) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(curtime2) + "\n")

            f.close()
    else:
        if (higher_price <= 4 and higher_price / lower_price >= adjustment_level):
            logging.info("Premiums too low, adjustment not required")
        else:
            logging.info("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return round(pnl, 1)


def call_strike_up():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])
    cursymbol = ""

    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('NIFTY') == True) and symbol.find('CE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break

    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:
        pos = cursymbol.find('CE')
        strike = int(cursymbol[pos - 5:pos])
        newstrike = strike + 50
        newsymbol = nifty_strike_to_symbol(newstrike, "CALL")

        print("Placing BUY Order", curquantity, cursymbol)
        execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", curquantity, newsymbol)
        execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None, product='NRML')


def call_strike_down():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])
    cursymbol = ""
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('NIFTY') == True) and symbol.find('CE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break
    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:
        pos = cursymbol.find('CE')
        strike = int(cursymbol[pos - 5:pos])
        newstrike = strike - 50
        newsymbol = nifty_strike_to_symbol(newstrike, "CALL")

        print("Placing BUY Order", curquantity, cursymbol)
        execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", curquantity, newsymbol)
        execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None, product='NRML')


def put_strike_up():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])
    cursymbol = ""
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if ((symbol.startswith('NIFTY') == True) and symbol.find('PE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break
    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:
        pos = cursymbol.find('PE')
        strike = int(cursymbol[pos - 5:pos])
        newstrike = strike + 50
        newsymbol = nifty_strike_to_symbol(newstrike, "PUT")

        print("Placing BUY Order", curquantity, cursymbol)
        execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", curquantity, newsymbol)
        execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None, product='NRML')


def put_strike_down():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])
    cursymbol = ""
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('NIFTY') == True) and symbol.find('PE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break

    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:
        pos = cursymbol.find('PE')
        strike = int(cursymbol[pos - 5:pos])
        newstrike = strike - 50
        newsymbol = nifty_strike_to_symbol(newstrike, "PUT")

        print("Placing BUY Order", curquantity, cursymbol)
        execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", curquantity, newsymbol)
        execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None, product='NRML')


def monitor_banknifty_option_buying_scalping(filename, producttype):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    cursymbol = ""

    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BN_Strangle.txt"
    maxprice_filename = "datafiles\\" + "maxprice.txt"
    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    num_buy_orders = 0
    num_sell_orders = 0

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = int(processed_order_data[i][quantity_index])
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
            num_sell_orders += 1
        elif (type == 'BUY'):
            quantity = int(quantity)
            num_buy_orders += 1

            if (num_buy_orders == 1):
                symbol_buy_price = float(symbol_avg_price)  # First buy price
            elif (num_buy_orders == 2):
                symbol_buy_price = (symbol_buy_price + float(symbol_avg_price)) / 2

        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity

    print("\nOur average BUY Price for ", symbol, "is", round(symbol_buy_price, 2))
    # print("\nNum of Buy Orders", num_buy_orders)
    # print("Num of Sell Orders", num_sell_orders)
    pnl = 0
    # pprint(symbol_dict)
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_last_price = last_price(symbol)
        print("Current Price for ", symbol, "is", symbol_last_price, "\n")
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][
                    quantity_dict_index] * symbol_last_price)  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] > 0):
            cursymbol = symbol
            curquantity = quantity
            print("Cur symbol is", cursymbol, "\nQuantity is ", quantity)

    # pprint(symbol_dict)
    print("Cur diff from Buy price is ", round(symbol_last_price - symbol_buy_price, 2))
    if (cursymbol == ""):
        print("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return None, 0

    stop_loss = 0
    book_profit = 0
    add_quantity = 0

    f = open(maxprice_filename, 'r')
    filedata = f.read()
    f.close()
    if filedata == '':
        saved_max_price = 0
        f = open(maxprice_filename, 'w')
        f.write(str(symbol_buy_price))
        f.close()
        saved_max_price = symbol_buy_price
        print("Saving Max for the first times")
    else:
        f = open(maxprice_filename, 'r')
        filedata = f.read()
        f.close()
        saved_max_price = float(filedata)

        if (symbol_last_price > saved_max_price):
            f = open(maxprice_filename, 'w')
            f.write(str(symbol_last_price))
            f.close()
            saved_max_price = float(symbol_last_price)

    print("\nMax Price of this current trade is ", saved_max_price, "\n")
    if (num_orders == 1):
        if (saved_max_price - symbol_buy_price) >= 10:
            if (symbol_last_price - saved_max_price <= -5):
                print("Booking one fourth quantity")
                book_profit = 1
            else:
                print("Wait for 5 point trailing stop loss to hit to book first profits")
        elif (symbol_last_price - symbol_buy_price) <= -5:
            add_quantity = 1
    elif (num_orders == 2):
        if (num_buy_orders == 2 and num_sell_orders == 0):
            if (saved_max_price - symbol_buy_price) >= 6:
                print("Booking one fourth quantity")
                book_profit = 1
            else:
                if (symbol_last_price - saved_max_price <= -12):
                    print("Trade not working lets exit all quantity")
                    stop_loss = 1
                else:
                    print(
                        "Lets see if this trade turns out to be profitable or not :)- Waiting for profits to reach 15 points or TSL at -15 points")
        elif (num_buy_orders == 1 and num_sell_orders == 1):
            if (saved_max_price - symbol_buy_price) >= 15:
                if (symbol_last_price - saved_max_price <= -5):
                    print("Booking one fourth quantity")
                    book_profit = 1
                else:
                    print("Wait for 5 point trailing stop loss to hit to book second profits")
            elif (symbol_last_price - symbol_buy_price < 0):  # Exits  buy price
                print("2nd Trade not working lets exit all remaining quantity")
                stop_loss = 1
            else:
                print(
                    "Lets see if this trade turns out to be profitable or not :)- Waiting for profits to reach 10 points or TSL at -15 points")

    elif (num_orders == 3):
        if (num_buy_orders == 2 and num_sell_orders == 1):
            if (saved_max_price - symbol_buy_price) >= 12:
                if (symbol_last_price - saved_max_price <= -4):
                    print("Booking one fourth quantity")
                    book_profit = 1
                else:
                    print("Wait for 5 point trailing stop loss to hit to book second profits")
            elif (symbol_last_price - symbol_buy_price < 0):  # Exits  buy price
                print("2nd Trade not working lets exit all remaining quantity")
                stop_loss = 1
            else:
                print(
                    "Lets see if this trade turns out to be profitable or not :)- Waiting for profits to reach 10 points or TSL at -15 points")
        elif (num_buy_orders == 1 and num_sell_orders == 2):
            if (
                    symbol_last_price - saved_max_price <= -18 or symbol_last_price - symbol_buy_price < 0):  # Exits  buy price
                print("20 pt stop loss or  exit at cost")
                stop_loss = 1
            else:
                print("20 pt stop loss or  exit at cost")
    elif (num_orders == 4):  # This means 2 buy and 2 sell orders
        if (symbol_last_price - saved_max_price <= -20 or symbol_last_price - symbol_buy_price < 0):  # Exits  buy price
            print("20 pt stop loss or  exit at cost")
            stop_loss = 1
        else:
            print("20 pt stop loss or  exit at cost")

    if (add_quantity == 1):
        curtime = datetime.datetime.now()
        orderid = execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None,
                                product=producttype)
        time.sleep(1)
        order_price = fetch_order(orderid)['average_price']
        f = open(filename, "a")  # Append mode
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(curquantity) + "\t" + str(
            order_price) + "\t" + str(curtime) + "\n")
        f.close()

        # Resetting Max Price
        f = open(maxprice_filename, 'w')
        f.write("0")
        f.close()
    elif (stop_loss == 1):
        curtime = datetime.datetime.now()
        orderid = execute_order(symbol=cursymbol, type="SELL", quant=curquantity, price=None, trig_price=None,
                                product=producttype)
        time.sleep(1)
        order_price = fetch_order(orderid)['average_price']

        f = open(filename, "a")  # Append mode
        f.write(str(orderid) + "\t" + "SELL" + "\t" + cursymbol + "\t" + str(curquantity) + "\t" + str(
            order_price) + "\t" + str(curtime) + "\n")
        f.close()
    elif (book_profit == 1):
        if (num_sell_orders == 0):
            sellquantity = int(curquantity / 3)
        elif (num_sell_orders == 1):
            sellquantity = int(curquantity / 2)
        curtime = datetime.datetime.now()
        orderid = execute_order(symbol=cursymbol, type="SELL", quant=sellquantity, price=None, trig_price=None,
                                product=producttype)
        time.sleep(1)
        order_price = fetch_order(orderid)['average_price']
        f = open(filename, "a")  # Append mode
        f.write(str(orderid) + "\t" + "SELL" + "\t" + cursymbol + "\t" + str(sellquantity) + "\t" + str(
            order_price) + "\t" + str(curtime) + "\n")
        f.close()
    return round(pnl, 1), curquantity


def monitor_banknifty_option_buying_breakout(filename, producttype):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    cursymbol = ""

    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BN_Strangle.txt"
    maxprice_filename = "datafiles\\" + "maxprice.txt"
    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = int(processed_order_data[i][quantity_index])
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY' and i == 0):
            quantity = int(quantity)
            symbol_buy_price = float(symbol_avg_price)  # First buy price
            print("\nOur BUY Price for ", symbol, "is", round(symbol_buy_price, 2))

        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_last_price = last_price(symbol)
        print("Current Price for ", symbol, "is", symbol_last_price, "\n")
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][
                    quantity_dict_index] * symbol_last_price)  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] > 0):
            cursymbol = symbol
            curquantity = quantity
            print("Cur symbol is", cursymbol, "Quantity is ", quantity)

    # pprint(symbol_dict)
    print("Cur diff from Buy price is ", round(symbol_last_price - symbol_buy_price, 2))
    if (cursymbol == ""):
        print("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return None

    stop_loss = 0
    book_profit = 0

    f = open(maxprice_filename, 'r')
    filedata = f.read()
    f.close()
    if filedata == '':
        saved_max_price = 0
        f = open(maxprice_filename, 'w')
        f.write(str(symbol_buy_price))
        f.close()
        saved_max_price = symbol_buy_price
        print("Saving Max for the first times")
    else:
        f = open(maxprice_filename, 'r')
        filedata = f.read()
        f.close()
        saved_max_price = float(filedata)

        if (symbol_last_price > saved_max_price):
            f = open(maxprice_filename, 'w')
            f.write(str(symbol_last_price))
            f.close()
            saved_max_price = float(symbol_last_price)

    print("Max Price of this trade is ", saved_max_price)
    if (num_orders == 1):
        if (saved_max_price - symbol_buy_price) >= 10:
            if (symbol_last_price - saved_max_price <= -5):
                print("Booking one third quantity")
                book_profit = 1
            else:
                print("Wait for 5 point trailing stop loss to hit to book first profits")
        else:
            if (symbol_last_price - saved_max_price <= -25):
                print("Trade not working lets exit all quantity")
                stop_loss = 1
            else:
                print(
                    "Lets see if this trade turns out to be profitable or not :)- Waiting for profits to reach 15 points or TSL at -15 points")
    elif (num_orders == 2):
        if (saved_max_price - symbol_buy_price) >= 15:
            if (symbol_last_price - saved_max_price <= -8):
                print("Booking one third quantity")
                book_profit = 1
            else:
                print("Wait for 5 point trailing stop loss to hit to book second profits")
        elif (symbol_last_price - symbol_buy_price < 0):  # Exits  buy price
            print("2nd Trade not working lets exit all remaining quantity")
            stop_loss = 1
        else:
            print(
                "Lets see if this trade turns out to be profitable or not :)- Waiting for profits to reach 10 points or TSL at -15 points")
    elif (num_orders == 3):
        if (symbol_last_price - saved_max_price <= -20 or symbol_last_price - symbol_buy_price < 0):  # Exits  buy price
            print("20 pt stop loss or  exit at cost")
            stop_loss = 1
        else:
            print("20 pt stop loss or  exit at cost")
    if (stop_loss == 1):
        curtime = datetime.datetime.now()
        orderid = execute_order(symbol=cursymbol, type="SELL", quant=curquantity, price=None, trig_price=None,
                                product=producttype)
        time.sleep(2)
        order_price = fetch_order(orderid)['average_price']

        f = open(filename, "a")  # Append mode
        f.write(str(orderid) + "\t" + "SELL" + "\t" + cursymbol + "\t" + str(curquantity) + "\t" + str(
            order_price) + "\t" + str(curtime) + "\n")
        f.close()
    elif (book_profit == 1):
        if num_orders == 1:
            sellquantity = int(curquantity / 3)
        elif num_orders == 2:
            sellquantity = int(curquantity / 2)

        curtime = datetime.datetime.now()
        orderid = execute_order(symbol=cursymbol, type="SELL", quant=sellquantity, price=None, trig_price=None,
                                product=producttype)
        time.sleep(2)
        order_price = fetch_order(orderid)['average_price']

        f = open(filename, "a")  # Append mode
        f.write(str(orderid) + "\t" + "SELL" + "\t" + cursymbol + "\t" + str(sellquantity) + "\t" + str(
            order_price) + "\t" + str(curtime) + "\n")
        f.close()
    return round(pnl, 1)


def monitor_nifty_strangle2(producttype, MaxLossPoints, day_premium, adjustment_level, filename, max_premium_increase):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    callsymbol = ""
    putsymbol = ""
    adjustment_level = 1.6
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    call_premium = day_premium
    multiplier = 1.2
    put_premium = day_premium * multiplier
    lower_adjustment_level = 0.7
    higher_adjustment_level = 1.75

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "Nifty_Strangle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                print("Call symbol is", callsymbol, "Quantity is ", quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                print("Put symbol is", putsymbol, "Quantity is ", quantity)

    pprint(symbol_dict)
    quantity = abs(callquantity)
    if (callsymbol == "" or putsymbol == ""):
        print("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return round(pnl, 1)

    symbols = [callsymbol, putsymbol]
    # print(symbols)
    symbols_ltp = last_price(symbols)

    # print(symbols_ltp)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    print("Call price is", callprice)
    print("Put price is", putprice)

    print("Current Ratio of both legs is ", round(putprice / callprice, 2))
    if (callprice > call_premium + max_premium_increase or putprice > put_premium + max_premium_increase):
        print("Cutting both positions and de-risking")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()
        putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime2 = datetime.datetime.now()
        callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        print("Starting both positions afresh now")

        nifty_cur_price = weekly_nifty_future()
        nifty_atm_strike = int(nifty_cur_price - nifty_cur_price % 50)
        put_strike_new = nifty_atm_strike
        call_strike_new = nifty_atm_strike

        while (True):

            putsymbol_new = nifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = nifty_strike_to_symbol(call_strike_new, "CALL")

            symbols = [callsymbol_new, putsymbol_new]
            symbols_ltp = last_price(symbols)
            callprice_new = symbols_ltp[0]
            putprice_new = symbols_ltp[1]

            if (callprice_new > call_premium):
                call_strike_new += 50
            if (putprice_new > put_premium):
                put_strike_new -= 50

            if (callprice_new < call_premium and putprice_new < put_premium):
                break
        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + MaxLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + MaxLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode

        putprice_buy = fetch_order(putorderid_buy)['average_price']
        callprice_buy = fetch_order(callorderid_buy)['average_price']

        f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
            putprice_buy) + "\t" + str(curtime1) + "\n")
        f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
            callprice_buy) + "\t" + str(curtime2) + "\n")

        f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()
    elif (putprice / callprice <= lower_adjustment_level):

        print("Cutting put position and entering matching position")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        put_strike = nifty_symbol_to_strike(putsymbol) + 50
        while (True):
            new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")
            new_putprice = last_price(new_putsymbol)

            if (new_putprice < callprice * multiplier):
                put_strike += 50
            else:
                break

        put_strike -= 50
        new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")

        curtime2 = datetime.datetime.now()
        orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                 product=producttype)
        time.sleep(1)

        order_price1 = fetch_order(orderid1)['average_price']
        order_price2 = fetch_order(orderid2)['average_price']

        put_sl_trig_price = round(order_price2, 1) + MaxLossPoints
        put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                       price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                       product=producttype)

        f = open(filename, "a")  # Append mode
        f.write(str(orderid1) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
            order_price1) + "\t" + str(curtime1) + "\n")

        f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
            order_price2) + "\t" + str(curtime2) + "\n")

        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(curtime2) + "\n")

        f.close()
    elif (putprice / callprice >= higher_adjustment_level):

        print("Cutting Call position and entering matching position")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        call_strike = nifty_symbol_to_strike(callsymbol) - 50
        while (True):
            new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")
            new_callprice = last_price(new_callsymbol)

            if (new_callprice * multiplier < putprice):
                call_strike -= 50
            else:
                break

        call_strike += 50
        new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")

        curtime2 = datetime.datetime.now()
        orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                 product=producttype)
        time.sleep(2)
        order_price1 = fetch_order(orderid1)['average_price']
        order_price2 = fetch_order(orderid2)['average_price']

        call_sl_trig_price = round(order_price2, 1) + MaxLossPoints
        call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)
        f = open(filename, "a")  # Append mode
        f.write(str(orderid1) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
            order_price1) + "\t" + str(curtime1) + "\n")

        f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
            order_price2) + "\t" + str(curtime2) + "\n")

        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(curtime2) + "\n")

        f.close()
    else:
        print("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return round(pnl, 1)


def exit_nifty_strangle(producttype):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    curdate = datetime.datetime.today()
    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "Nifty_Strangle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Checking active positions

        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][quantity_dict_index] += quantity
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        symbol_quantity = symbol_dict[symbol][quantity_dict_index]
        if (symbol_quantity < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = int(symbol_quantity)
                print("Call symbol is", callsymbol, "Quantity is ", symbol_quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = int(symbol_quantity)
                print("Put symbol is", putsymbol, "Quantity is ", symbol_quantity)

    putexit = 0
    callexit = 0

    for i in range(num_orders - 1, 0, -1):
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        symbol_order_id = processed_order_data[i][order_index]
        if (symbol == putsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            putexit = 1
        elif (symbol == callsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            callexit = 1
        if (putexit == 1 and callexit == 1):
            break

    curtime = datetime.datetime.now()

    putorderid = execute_order(symbol=putsymbol, type="BUY", quant=abs(putquantity), price=None, trig_price=None,
                               product=producttype)

    callorderid = execute_order(symbol=callsymbol, type="BUY", quant=abs(callquantity), price=None, trig_price=None,
                                product=producttype)

    time.sleep(1)

    f = open(filename, "a")  # Append mode
    if (fetch_order(putorderid)['status'] == 'COMPLETE'):
        f.write(str(putorderid) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(abs(putquantity)) + "\t" + str(
            fetch_order(putorderid)['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something wrong with Put order...Check It!")

    curtime = datetime.datetime.now()
    if (fetch_order(callorderid)['status'] == 'COMPLETE'):
        f.write(str(callorderid) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(abs(callquantity)) + "\t" + str(
            fetch_order(callorderid)['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something wrong with Call order...Check It!")

    f.close()


def exit_nifty_straddle(producttype, filename):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "Nifty_Strangle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Checking active positions

        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        symbol_dict[symbol][quantity_dict_index] += quantity
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        symbol_quantity = symbol_dict[symbol][quantity_dict_index]
        if (symbol_quantity < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = int(symbol_quantity)
                print("Call symbol is", callsymbol, "Quantity is ", symbol_quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = int(symbol_quantity)
                print("Put symbol is", putsymbol, "Quantity is ", symbol_quantity)

    putexit = 0
    callexit = 0

    for i in range(num_orders - 1, 0, -1):
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        symbol_order_id = processed_order_data[i][order_index]
        if (symbol == putsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            putexit = 1
        elif (symbol == callsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            callexit = 1
        if (putexit == 1 and callexit == 1):
            break

    curtime = datetime.datetime.now()

    putorderid = execute_order(symbol=putsymbol, type="BUY", quant=abs(putquantity), price=None, trig_price=None,
                               product=producttype)

    callorderid = execute_order(symbol=callsymbol, type="BUY", quant=abs(callquantity), price=None, trig_price=None,
                                product=producttype)

    time.sleep(1)

    f = open(filename, "a")  # Append mode
    if (fetch_order(putorderid)['status'] == 'COMPLETE'):
        f.write(str(putorderid) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(abs(putquantity)) + "\t" + str(
            fetch_order(putorderid)['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something wrong with Put order...Check It!")

    curtime = datetime.datetime.now()
    if (fetch_order(callorderid)['status'] == 'COMPLETE'):
        f.write(str(callorderid) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(abs(callquantity)) + "\t" + str(
            fetch_order(callorderid)['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something wrong with Call order...Check It!")

    f.close()


def banknifty_call_strike_up_with_sl_and_file(filename):
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    if num_positions == 0:
        print("Found No Position to Adjust...Exiting!!")
        return
    cursymbol = ""
    i = 0
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('CE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break

    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    # else:
    strike = banknifty_symbol_to_strike(cursymbol)
    newstrike = strike + 100
    newsymbol = banknifty_strike_to_symbol(newstrike, "CALL")

    print("Placing BUY Order", curquantity, cursymbol)
    orderid_1 = execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None,
                              product='NRML')

    curtime = datetime.datetime.now()

    time.sleep(0.1)
    order = fetch_order(orderid_1)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid_1) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    print("Placing SELL Order", curquantity, newsymbol)
    orderid_2 = execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None,
                              product='NRML')
    curtime = datetime.datetime.now()
    time.sleep(0.1)
    order = fetch_order(orderid_2)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid_2) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    ###############################################

    # FINDING PREV SL TO CUT

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)

    ###############################################

    print("CUTTING SL ORDER OF PREV CALL")

    # if (put_diff > put_max_range):
    # time.sleep(5)

    # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts Up")
    # banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type,filename)

    new_call_strike = strike + 100
    new_callsymbol = banknifty_strike_to_symbol(new_call_strike, "CALL")
    new_callprice = last_price(new_callsymbol)

    # # logging.info("Cutting both positions and de-risking")
    # logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

    for i in range(num_orders - 1, 0, -1):
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        symbol_order_id = processed_order_data[i][order_index]
        if (symbol == callsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            break

    curtime1 = datetime.datetime.now()

    call_sl_trig_price = new_callprice * 3

    call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity, price=call_sl_trig_price + 10,
                                    trig_price=call_sl_trig_price,
                                    product='NRML')

    f = open(filename, "a")  # Append mode
    # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
    #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
    f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
        call_sl_trig_price) + "\t" + str(curtime1) + "\n")

    f.close()


def banknifty_call_strike_down_with_sl_and_file(filename):
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    if num_positions == 0:
        print("Found No Position to Adjust...Exiting!!")
        return
    cursymbol = ""
    i = 0
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('CE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break

    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    # else:
    strike = banknifty_symbol_to_strike(cursymbol)
    newstrike = strike - 100
    newsymbol = banknifty_strike_to_symbol(newstrike, "CALL")

    print("Placing BUY Order", curquantity, cursymbol)
    orderid_1 = execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None,
                              product='NRML')

    curtime = datetime.datetime.now()

    time.sleep(0.1)
    order = fetch_order(orderid_1)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid_1) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    print("Placing SELL Order", curquantity, newsymbol)
    orderid_2 = execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None,
                              product='NRML')
    curtime = datetime.datetime.now()
    time.sleep(0.1)
    order = fetch_order(orderid_2)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid_2) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    ###############################################

    # FINDING PREV SL TO CUT

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)

    ###############################################

    print("CUTTING SL ORDER OF PREV CALL")

    # if (put_diff > put_max_range):
    # time.sleep(5)

    # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts Up")
    # banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type,filename)

    new_call_strike = strike - 100
    new_callsymbol = banknifty_strike_to_symbol(new_call_strike, "CALL")
    new_callprice = last_price(new_callsymbol)

    # # logging.info("Cutting both positions and de-risking")
    # logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

    for i in range(num_orders - 1, 0, -1):
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        symbol_order_id = processed_order_data[i][order_index]
        if (symbol == callsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            break

    curtime1 = datetime.datetime.now()

    call_sl_trig_price = new_callprice * 3

    call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity, price=call_sl_trig_price + 10,
                                    trig_price=call_sl_trig_price,
                                    product='NRML')

    f = open(filename, "a")  # Append mode
    # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
    #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
    f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
        call_sl_trig_price) + "\t" + str(curtime1) + "\n")

    f.close()


def banknifty_put_strike_up_with_sl_and_file(filename):
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    if num_positions == 0:
        print("Found No Position to Adjust...Exiting!!")
        return
    cursymbol = ""
    i = 0
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('PE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Put symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break

    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    # else:
    strike = banknifty_symbol_to_strike(cursymbol)
    newstrike = strike + 100
    newsymbol = banknifty_strike_to_symbol(newstrike, "PUT")

    print("Placing BUY Order", curquantity, cursymbol)
    orderid_1 = execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None,
                              product='NRML')

    curtime = datetime.datetime.now()

    time.sleep(0.1)
    order = fetch_order(orderid_1)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid_1) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    print("Placing SELL Order", curquantity, newsymbol)
    orderid_2 = execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None,
                              product='NRML')
    curtime = datetime.datetime.now()
    time.sleep(0.1)
    order = fetch_order(orderid_2)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid_2) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    ###############################################

    # FINDING PREV SL TO CUT

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)

    ###############################################

    print("CUTTING SL ORDER OF PREV CALL")

    # if (put_diff > put_max_range):
    # time.sleep(5)

    # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts Up")
    # banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type,filename)

    new_put_strike = strike + 100
    new_putsymbol = banknifty_strike_to_symbol(new_put_strike, "PUT")
    new_putprice = last_price(new_putsymbol)

    # # logging.info("Cutting both positions and de-risking")
    # logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

    for i in range(num_orders - 1, 0, -1):
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        symbol_order_id = processed_order_data[i][order_index]
        if (symbol == putsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            break

    curtime1 = datetime.datetime.now()

    put_sl_trig_price = new_putprice * 3

    put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                   trig_price=put_sl_trig_price,
                                   product='NRML')

    f = open(filename, "a")  # Append mode
    # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
    #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
    f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
        put_sl_trig_price) + "\t" + str(curtime1) + "\n")

    f.close()


def banknifty_put_strike_down_with_sl_and_file(filename):
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    if num_positions == 0:
        print("Found No Position to Adjust...Exiting!!")
        return
    cursymbol = ""
    i = 0
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('PE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Put symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break

    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    # else:
    strike = banknifty_symbol_to_strike(cursymbol)
    newstrike = strike - 100
    newsymbol = banknifty_strike_to_symbol(newstrike, "PUT")

    print("Placing BUY Order", curquantity, cursymbol)
    orderid_1 = execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None,
                              product='NRML')

    curtime = datetime.datetime.now()

    time.sleep(0.1)
    order = fetch_order(orderid_1)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid_1) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    print("Placing SELL Order", curquantity, newsymbol)
    orderid_2 = execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None,
                              product='NRML')
    curtime = datetime.datetime.now()
    time.sleep(0.1)
    order = fetch_order(orderid_2)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid_2) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    ###############################################

    # FINDING PREV SL TO CUT

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue

        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)

    ###############################################

    print("CUTTING SL ORDER OF PREV CALL")

    # if (put_diff > put_max_range):
    # time.sleep(5)

    # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts Up")
    # banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type,filename)

    new_put_strike = strike - 100
    new_putsymbol = banknifty_strike_to_symbol(new_put_strike, "PUT")
    new_putprice = last_price(new_putsymbol)

    # # logging.info("Cutting both positions and de-risking")
    # logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

    for i in range(num_orders - 1, 0, -1):
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        symbol_order_id = processed_order_data[i][order_index]
        if (symbol == putsymbol and type == 'SLL'):
            kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
            break

    curtime1 = datetime.datetime.now()

    put_sl_trig_price = new_putprice * 3

    put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                   trig_price=put_sl_trig_price,
                                   product='NRML')

    f = open(filename, "a")  # Append mode
    # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
    #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
    f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
        put_sl_trig_price) + "\t" + str(curtime1) + "\n")

    f.close()


def banknifty_call_strike_up():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    if num_positions == 0:
        print("Found No Position to Adjust...Exiting!!")
        return
    cursymbol = ""
    i = 0
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('CE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break

    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:
        strike = banknifty_symbol_to_strike(cursymbol)
        newstrike = strike + 100
        newsymbol = banknifty_strike_to_symbol(newstrike, "CALL")

        print("Placing BUY Order", curquantity, cursymbol)
        execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", curquantity, newsymbol)
        execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None, product='NRML')


def banknifty_call_strike_down():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])
    if num_positions == 0:
        print("Found No Position to Adjust...Exiting!!")
        return
    cursymbol = ""
    i = 0
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('CE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break
    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:
        strike = banknifty_symbol_to_strike(cursymbol)
        newstrike = strike - 100
        newsymbol = banknifty_strike_to_symbol(newstrike, "CALL")

        print("Placing BUY Order", curquantity, cursymbol)
        execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", curquantity, newsymbol)
        execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None, product='NRML')


def banknifty_put_strike_up():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    if num_positions == 0:
        print("Found No Position to Adjust...Exiting!!")
        return
    cursymbol = ""
    i = 0
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']
        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('PE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break
    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:
        strike = banknifty_symbol_to_strike(cursymbol)
        newstrike = strike + 100
        newsymbol = banknifty_strike_to_symbol(newstrike, "PUT")

        print("Placing BUY Order", curquantity, cursymbol)
        execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", curquantity, newsymbol)
        execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None, product='NRML')


def banknifty_put_strike_down():
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])

    if num_positions == 0:
        print("Found No Position to Adjust...Exiting!!")
        return
    cursymbol = ""
    i = 0
    for i in range(num_positions):

        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('PE') > 0 and quantity < 0 and
                today_positions['net'][i]['product'] == 'NRML'):
            print("Call symbol is", symbol)
            cursymbol = symbol
            curquantity = abs(quantity)
            break

    if (i == num_positions - 1 and cursymbol == ""):
        print("Found No Position to Adjust...Exiting!!")
        return
    else:
        strike = banknifty_symbol_to_strike(cursymbol)
        newstrike = strike - 100
        newsymbol = banknifty_strike_to_symbol(newstrike, "PUT")

        print("Placing BUY Order", curquantity, cursymbol)
        execute_order(symbol=cursymbol, type="BUY", quant=curquantity, price=None, trig_price=None, product='NRML')
        print("Placing SELL Order", curquantity, newsymbol)
        execute_order(symbol=newsymbol, type="SELL", quant=curquantity, price=None, trig_price=None, product='NRML')


def monitor_banknifty_moving_strangle(product_type, filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            print("Call symbol and quantity is", callsymbol, callquantity)

    pprint(symbol_dict)
    print("Step 4")
    print("Total pnl is ", round(pnl, 1))

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3 or curday == 2):  # Expiry Day - Thursday
        call_max_range = 400
        call_min_range = 200
        put_min_range = 200
        put_max_range = 400
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        #     call_max_range = 160
        #     call_min_range = 80
        #     put_min_range = 100
        #     put_max_range = 180
        # elif(cur_hour==12 or cur_hour==13 ):
        #     call_max_range = 150
        #     call_min_range = 70
        #     put_max_range = 170
        #     put_min_range = 90
        # if((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        #     call_max_range = 150
        #     call_min_range = 70
        #     put_max_range = 180
        #     put_min_range = 100
    # elif(curday == 4):  # Friday - Start with a delta neutral 350 point strangle
    #     call_max_range = 180
    #     call_min_range = 100
    #     put_max_range = 230
    #     put_min_range = 150
    # elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
    #     call_max_range = 150
    #     call_min_range = 75
    #     put_max_range = 175
    #     put_min_range = 100
    # elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
    #     call_max_range = 150
    #     call_min_range = 75
    #     put_max_range = 175
    #     put_min_range = 100
    # elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
    #     call_max_range = 170
    #     call_min_range = 90
    #     put_max_range = 190
    #     put_min_range = 110

    banknifty_cur_price = weekly_banknifty_future()
    print("Bank Nifty CUrrent Price is - ", banknifty_cur_price, "\n")
    if (callsymbol == "" and putsymbol == ""):
        print("Found No Positions to Monitor...Exiting!!")
        return 0
    else:
        callstrike = banknifty_symbol_to_strike(callsymbol)
        putstrike = banknifty_symbol_to_strike(putsymbol)

        put_diff = banknifty_cur_price - putstrike
        call_diff = callstrike - banknifty_cur_price

        if (call_diff > call_max_range):
            time.sleep(5)
            banknifty_cur_price = weekly_banknifty_future()
            call_diff = callstrike - banknifty_cur_price
            if (call_diff > call_max_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Down")
                banknifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            time.sleep(5)
            nifty_cur_price = weekly_banknifty_future()
            call_diff = callstrike - banknifty_cur_price
            if (call_diff < call_min_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Up")
                banknifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), product_type, filename)
        else:
            print("Call Strike Diff is ", int(call_diff), "Nothing to do right now !!")
            print("Will Move Calls Up At ", callstrike - call_min_range)
            print("Will Move Calls Down At ", callstrike - call_max_range)

        if (put_diff > put_max_range):
            time.sleep(5)
            banknifty_cur_price = weekly_banknifty_future()
            put_diff = banknifty_cur_price - putstrike
            if (put_diff > put_max_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Up")
                banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            time.sleep(5)
            banknifty_cur_price = weekly_banknifty_future()
            put_diff = banknifty_cur_price - putstrike
            if (put_diff < put_min_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Down")
                banknifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), product_type, filename)
        else:
            print("Put Strike Diff is ", int(put_diff), "Nothing to do right now !!")
            print("Will Move Puts Up At ", putstrike + put_max_range)
            print("Will Move Puts Down At ", putstrike + put_min_range)

    return pnl


def exit_banknifty_moving_strangle(product_type):  # Bas
    # ed on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    curdate = datetime.datetime.today()

    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Read mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # Net Quantity Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        symbol_dict[symbol][0] += quantity

    pprint(symbol_dict)
    print("Step 3")

    f = open(filename, "a")  # Append Mode
    for symbol in symbol_dict:  # Exit Sell Positions
        quantity = symbol_dict[symbol][0]
        if quantity < 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="BUY", quant=abs(quantity), price=None, trig_price=None,
                                    product=product_type)
            f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")

    for symbol in symbol_dict:  # Exit Buy Positions
        quantity = symbol_dict[symbol][0]
        if quantity > 0:
            print("Exiting ", symbol)
            curtime = datetime.datetime.now()
            orderid = execute_order(symbol=symbol, type="SELL", quant=abs(quantity), price=None, trig_price=None,
                                    product=product_type)
            f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol + "\t" + str(abs(quantity)) + "\t" + str(
                fetch_order(orderid)['average_price']) + "\t" + str(curtime) + "\n")

    f.close()


def banknifty_call_strike_down_moving_strangle(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - 100

    cursymbol = banknifty_strike_to_symbol(callstrike, "CALL")
    newsymbol = banknifty_strike_to_symbol(newstrike, "CALL")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    f.close()


def banknifty_call_strike_up_moving_strangle(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + 100

    cursymbol = banknifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = banknifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")
    f.close()


def banknifty_put_strike_down_moving_strangle(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - 100

    cursymbol = banknifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = banknifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")
    f.close()


def banknifty_put_strike_up_moving_strangle(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + 100

    cursymbol = banknifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = banknifty_strike_to_symbol(newstrike, 'PUT')
    print("Inside banknifty_put_strike_up_moving_strangle, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    f.close()


def nifty_call_strike_down_moving_strangle(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) - 50

    cursymbol = nifty_strike_to_symbol(callstrike, "CALL")
    newsymbol = nifty_strike_to_symbol(newstrike, "CALL")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    f.close()


def nifty_call_strike_up_moving_strangle(callstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(callstrike) + 50

    cursymbol = nifty_strike_to_symbol(callstrike, 'CALL')
    newsymbol = nifty_strike_to_symbol(newstrike, 'CALL')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")
    f.close()


def nifty_put_strike_down_moving_strangle(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) - 50

    cursymbol = nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = nifty_strike_to_symbol(newstrike, 'PUT')

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)

    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")
    f.close()


def nifty_put_strike_up_moving_strangle(putstrike, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "a")  # Append mode

    newstrike = int(putstrike) + 50

    cursymbol = nifty_strike_to_symbol(putstrike, 'PUT')
    newsymbol = nifty_strike_to_symbol(newstrike, 'PUT')
    print("Inside banknifty_put_strike_up_moving_strangle, product type is :", type)

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=cursymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + cursymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=newsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)

    time.sleep(0.1)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        print("Something Wrong with Order CHeck Now")

    f.close()


### KAPIL'S CODE REQUIRED TO RUN SHEET ##

def get_quote(sym):
    # print("KITE FROM GET QUOTE:"+ str(kite))
    # pprint(kite.ltp(sym))
    return kite.quote(sym)


def get_ltp(sym):
    return kite.ltp(sym)


def get_ltp_for_symbol(expiry_name):
    """
    Returns the last traded price (LTP) for a given symbol's expiry name.
    
    Parameters:
    expiry_name (str): The expiry name of the symbol.
    
    Returns:
    float: The last traded price (LTP) of the symbol.
    """
    token, difference_between_strikes = getDetailsFromExpiryName_Zerodha(expiry_name)
    return kite.ltp(token)[token]['last_price']


def nifty_ltp():
    return kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']


def midcap_nifty_ltp():
    return kite.ltp('NSE:NIFTY MID SELECT')['NSE:NIFTY MID SELECT']['last_price']


def sensex_ltp():
    return kite.ltp('BSE:SENSEX')['BSE:SENSEX']['last_price']


def bank_nifty_ltp():
    return kite.ltp('NSE:NIFTY BANK')['NSE:NIFTY BANK']['last_price']


def fin_nifty_ltp():
    return kite.ltp('NSE:NIFTY FIN SERVICE')['NSE:NIFTY FIN SERVICE']['last_price']


def fin_nifty_current_expiry_symbol():
    global months
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= 1:  # 0 Is Monday,1 is tuesday  3 is Thursday
        days_remaining = fin_expiryday - curday
    elif curday > 1:
        days_remaining = fin_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NFO:FINNIFTY" + expiryyear + expirym + expiryd
        symbol = "NFO:FINNIFTY" + expiryyear + expirym + expiryd
        # + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "NFO:FINNIFTY" + expiryyear + months[int(expirym)]
        # + str(strike) + suffix

    return (symbol)


# expiry symbol depends on if its a montly expiry or a weekly expiry, expiry year, expiry day etc
def nifty_current_expiry_symbol():
    """

    :return: Returns Zerodha Expiry Symbol Prefix (Acc to Weekly / Monthly ) NFO:NIFTY
    """
    global months
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = expiryday - curday
    elif curday > expiryday:
        days_remaining = expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        print(
            "Current upcoming expiry is a Monthly Expiry!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NFO:NIFTY" + expiryyear + expirym + expiryd

        symbol = "NFO:NIFTY" + expiryyear + expirym + expiryd

        # + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "NFO:NIFTY" + expiryyear + months[int(expirym)]
        # + str(strike) + suffix

    return (symbol)


# expiry symbol depends on if its a montly expiry or a weekly expiry, expiry year, expiry day etc
def bank_nifty_current_expiry_symbol():
    global months
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= bn_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = bn_expiryday - curday
    elif curday > bn_expiryday:
        days_remaining = bn_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    print("Upcoming Expiry is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        # print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        # print("Current upcoming expiry is a Monthly Expiry")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NFO:BANKNIFTY" + expiryyear + expirym + expiryd
        symbol = "NFO:BANKNIFTY" + expiryyear + expirym + expiryd
        # + str(strike) + suffix
    elif (expirytype == 'Monthly'):
        symbol = "NFO:BANKNIFTY" + expiryyear + months[int(expirym)]
        # + str(strike) + suffix
    month_number = int(symbol[-4:-2])
    # Map the month number to the corresponding alphabet
    if month_number == 10:
        month_alphabet = 'O'
    elif month_number == 11:
        month_alphabet = 'N'
    elif month_number == 12:
        month_alphabet = 'D'
    else:
        month_alphabet = None  # Handle other cases if needed
    if month_alphabet is not None:
        symbol = symbol.replace(str(month_number), month_alphabet)
    return (symbol)


# expiry symbol depends on if its a montly expiry or a weekly expiry, expiry year, expiry day etc
def midcap_nifty_current_expiry_symbol():
    global months
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= midcap_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = midcap_expiryday - curday
    elif curday > midcap_expiryday:
        days_remaining = midcap_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    print("Upcoming midcap_expiryday is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        print(
            "Current upcoming expiry is a Monthly Expiry\!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NFO:NIFTY" + expiryyear + expirym + expiryd

        symbol = "NFO:MIDCPNIFTY" + expiryyear + expirym + expiryd

        # + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "NFO:MIDCPNIFTY" + expiryyear + months[int(expirym)]
        # + str(strike) + suffix

    return (symbol)


# expiry symbol depends on if its a montly expiry or a weekly expiry, expiry year, expiry day etc
def sensex_current_expiry_symbol():
    global months
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= sensex_expiryday:  # 0 Is Monday, 3 is Thursday
        days_remaining = sensex_expiryday - curday
    elif curday > sensex_expiryday:
        days_remaining = sensex_expiryday - curday + 7

    expirydate = curdate + datetime.timedelta(days=days_remaining)  # Current upcoming expiry
    nextexpirydate = expirydate + datetime.timedelta(days=7)
    nextexpirymonth = nextexpirydate.strftime("%m")

    print("Upcoming sensex_expiryday is on ", expirydate)
    expiryyear = expirydate.strftime("%y")
    expirymonth = expirydate.strftime("%m")
    expiryd = expirydate.strftime("%d")

    if (expirymonth == nextexpirymonth):
        print("Current upcoming expiry is a Weekly Expiry")
        expirytype = 'Weekly'
    else:
        print(
            "Current upcoming expiry is a Monthly Expiry\!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11")
        expirytype = 'Monthly'

    # print(expirymonth[0],expirymonth[1])

    if (expirymonth[0] == "0"):
        expirym = expirymonth[1]
    else:
        expirym = expirymonth

    if (expirytype == 'Weekly'):
        # symbol = "NFO:NIFTY" + expiryyear + expirym + expiryd

        symbol = "BFO:SENSEX" + expiryyear + months[int(expirym)][0] + expiryd

        # + str(strike) + suffix


    elif (expirytype == 'Monthly'):
        symbol = "BFO:SENSEX" + expiryyear + months[int(expirym)]
        # + str(strike) + suffix

    return (symbol)


def nify_get_greeks(price, curr_nifty_price, strike, t, flag):
    """
    :usage NIFTY_SPOT_CALL_IV, NIFTY_SPOT_CALL_GREEKS = nify_get_greeks(OPTION_LTP, nifty_spot_p, int(OPTION_strike), t,
                                                                     'c')
    :param price:
    :param curr_nifty_price:
    :param strike:
    :param t:
    :param flag:
    :return:
    """
    p = 0
    r = 0.05
    p = py_vollib_vectorized.vectorized_implied_volatility(price, curr_nifty_price, strike, t, r, flag, q=0,
                                                           model='black_scholes_merton',
                                                           return_as='numpy')  # equivalent
    sigma = p[0]

    # print( put_ltp,"PUT IV " , putsymbol ," ", p[0]*100)

    return p[0], py_vollib_vectorized.api.get_all_greeks(flag, curr_nifty_price, strike, t, r, sigma,
                                                         model='black_scholes', return_as='dict')


def midcap_nify_get_greeks(price, curr_midcap_nifty_price, strike, t, flag):
    p = 0
    r = 0.05
    p = py_vollib_vectorized.vectorized_implied_volatility(price, curr_midcap_nifty_price, strike, t, r, flag, q=0,
                                                           model='black_scholes_merton',
                                                           return_as='numpy')  # equivalent
    sigma = p[0]

    # print( put_ltp,"PUT IV " , putsymbol ," ", p[0]*100)

    return p[0], py_vollib_vectorized.api.get_all_greeks(flag, curr_midcap_nifty_price, strike, t, r, sigma,
                                                         model='black_scholes', return_as='dict')


def sensex_get_greeks(price, curr_sensex_price, strike, t, flag):
    p = 0
    r = 0.05
    p = py_vollib_vectorized.vectorized_implied_volatility(price, curr_sensex_price, strike, t, r, flag, q=0,
                                                           model='black_scholes_merton',
                                                           return_as='numpy')  # equivalent
    sigma = p[0]

    # print( put_ltp,"PUT IV " , putsymbol ," ", p[0]*100)

    return p[0], py_vollib_vectorized.api.get_all_greeks(flag, curr_sensex_price, strike, t, r, sigma,
                                                         model='black_scholes', return_as='dict')


def fin_nify_get_greeks(price, curr_fin_nifty_price, strike, t, flag):
    p = 0
    r = 0.05
    p = py_vollib_vectorized.vectorized_implied_volatility(price, curr_fin_nifty_price, strike, t, r, flag, q=0,
                                                           model='black_scholes_merton',
                                                           return_as='numpy')  # equivalent
    sigma = p[0]

    # print( put_ltp,"PUT IV " , putsymbol ," ", p[0]*100)

    return p[0], py_vollib_vectorized.api.get_all_greeks(flag, curr_fin_nifty_price, strike, t, r, sigma,
                                                         model='black_scholes', return_as='dict')


def bank_nify_get_greeks(price, curr_bank_nifty_price, strike, t, flag):
    p = 0
    r = 0.05

    p = py_vollib_vectorized.vectorized_implied_volatility(price, curr_bank_nifty_price, strike, t, r, flag, q=0,
                                                           model='black_scholes_merton',
                                                           return_as='numpy')  # equivalent
    sigma = p[0]

    # print( put_ltp,"PUT IV " , putsymbol ," ", p[0]*100)

    return p[0], py_vollib_vectorized.api.get_all_greeks(flag, curr_bank_nifty_price, strike, t, r, sigma,
                                                         model='black_scholes', return_as='dict')


def bank_nify_get_greeks_for_web_socket(price, strike, t, flag):
    p = 0
    r = 0.05
    curr_bank_nifty_price = weekly_banknifty_future()

    p = py_vollib_vectorized.vectorized_implied_volatility(price, curr_bank_nifty_price, strike, t, r, flag, q=0,
                                                           model='black_scholes_merton',
                                                           return_as='numpy')  # equivalent
    sigma = p[0]

    # print( put_ltp,"PUT IV " , putsymbol ," ", p[0]*100)

    return p[0], py_vollib_vectorized.api.get_all_greeks(flag, curr_bank_nifty_price, strike, t, r, sigma,
                                                         model='black_scholes', return_as='dict')


def monitor_banknifty_strangle_with_greeks(producttype, MaxLossPoints):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    callsymbol = ""
    putsymbol = ""
    adjustment_level = 1.75
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if (curday == 3):  # Expiry Day - Thursday
        day_premium = 15
        adjustment_level = 2
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        day_premium = 20
    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        day_premium = 20
    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        day_premium = 20
    elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
        day_premium = 20

    filename = "datafiles\\" + curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
        "%y") + "BN_Strangle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                print("Call symbol is", callsymbol, "Quantity is ", quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                print("Put symbol is", putsymbol, "Quantity is ", quantity)

    pprint(symbol_dict)
    quantity = abs(callquantity)
    if (callsymbol == "" or putsymbol == ""):
        print("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return round(pnl, 1)

    symbols = [callsymbol, putsymbol]
    symbols_ltp = last_price(symbols)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    print("Call price is", callprice)
    print("Put price is", putprice)

    if (callprice > putprice):
        higher_price = callprice
        higher_symbol = callsymbol
        lower_price = putprice
        lower_symbol = putsymbol
    else:
        higher_price = putprice
        higher_symbol = putsymbol
        lower_price = callprice
        lower_symbol = callsymbol

    print("Current Ratio of both legs is ", round(higher_price / lower_price, 2))
    print("Max Loss points is ", MaxLossPoints)
    if (higher_price > day_premium + 20):
        print("Cutting both positions and de-risking")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()
        putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime2 = datetime.datetime.now()
        callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        print("Starting both positions afresh now")

        banknifty_cur_price = weekly_banknifty_future()
        banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)
        put_strike_new = banknifty_atm_strike
        call_strike_new = banknifty_atm_strike

        while (True):

            putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

            symbols = [callsymbol_new, putsymbol_new]
            symbols_ltp = last_price(symbols)
            callprice_new = symbols_ltp[0]
            putprice_new = symbols_ltp[1]

            if (callprice_new > day_premium):
                call_strike_new += 100
            if (putprice_new > day_premium):
                put_strike_new -= 100

            if (callprice_new < day_premium and putprice_new < day_premium):
                break
        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putprice_buy = fetch_order(putorderid_buy)['average_price']
        callprice_buy = fetch_order(callorderid_buy)['average_price']

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
            putprice_buy) + "\t" + str(curtime1) + "\n")
        f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
            callprice_buy) + "\t" + str(curtime2) + "\n")

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + MaxLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + MaxLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()
    elif (higher_price / lower_price >= adjustment_level):

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        print("Cutting " + lower_symbol + " and entering matching position")

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = banknifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice + 3):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            put_sl_trig_price = round(order_price2, 1) + MaxLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(curtime1) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(curtime2) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(curtime2) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = banknifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice + 3):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            call_sl_trig_price = round(order_price2, 1) + MaxLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(curtime1) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(curtime2) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(curtime2) + "\n")

            f.close()
    else:
        print("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return round(pnl, 1)


def check_symbols_in_bn_file(filename):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, call_ltp, put_ltp

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    if filename == "":
        filename = "datafiles\\" + curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
            "%y") + "BN_Strangle.txt"
    else:
        filename = filename
    # straddle_min_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "StraddleMin.txt"
    # straddle_max_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "StraddleMax.txt"

    f = open(filename, "a")  # File Reading
    # filedata = f.read()
    f.close()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    # print("hello")
    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0, None, None, None, None, None

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)
    # ppp.set_trace()

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    putsymbol = None
    callsymbol = None
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity
    return pnl, callsymbol, callquantity, putsymbol, putquantity, symbol_dict


def check_symbols_in_FIN_file(filename):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, call_ltp, put_ltp

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    if filename == "":
        filename = "datafiles\\" + curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime(
            "%y") + "BN_Strangle.txt"
    else:
        filename = filename
    # straddle_min_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "StraddleMin.txt"
    # straddle_max_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "StraddleMax.txt"

    f = open(filename, "a")  # File Reading
    # filedata = f.read()
    f.close()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    # print("hello")
    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0, None, None, None, None, None

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)
    # ppp.set_trace()

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    putsymbol = None
    callsymbol = None
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity
    return pnl, callsymbol, callquantity, putsymbol, putquantity, symbol_dict


def check_symbols_in_nifty_file(filename):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, call_ltp, put_ltp

    # pnl = (sellValue - buyValue) + (netQuantity * lastPrice * multiplier);
    curdate = datetime.datetime.today()
    if filename == "":
        filename = "datafiles\\multiple_moving_strangle\\" + curdate.strftime("%d") + curdate.strftime(
            "%m") + curdate.strftime(
            "%y") + "MovingStrangle_mummy.txt"
    else:
        filename = filename
    # straddle_min_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "StraddleMin.txt"
    # straddle_max_file = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "StraddleMax.txt"

    f = open(filename, "a")  # File Reading
    # filedata = f.read()
    f.close()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    # print("hello")
    if (num_orders == 0):
        print("Nothing to Monitor..Returning !!")
        return 0, None, None, None, None, None

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n")
    # pprint(processed_order_data)
    # ppp.set_trace()

    symbol_dict = {}

    for i in range(num_orders):  # This loop does 2 independent things

        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL' or type == 'CANCELED'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    putsymbol = None
    callsymbol = None
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                symbol_dict[symbol][0] * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][2]
        if (quantity < 0 and symbol.find('PE') > 0):
            putsymbol = symbol
            putquantity = quantity
        elif (quantity < 0 and symbol.find('CE') > 0):
            callsymbol = symbol
            callquantity = quantity
    return pnl, callsymbol, callquantity, putsymbol, putquantity, symbol_dict


### KAPIL'S CODE REQUIRED TO RUN SHEET  ENDS ##

###############################################

def monitor_nifty_strangle(producttype, day_premium, adjustment_level, filename):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    DeRiskPoints = day_premium * 2
    StopLossPoints = DeRiskPoints + 5

    sl_hit = 0
    callsymbol = ""
    putsymbol = ""
    # adjustment_level = 1.5
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()
    #
    # if (curday == 3):  # Expiry Day - Thursday
    #     day_premium = 8
    #     # adjustment_level=1.6
    # elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
    #     day_premium = 12
    # elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
    #     day_premium = 12
    # elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
    #     day_premium = 10
    # elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
    #     day_premium = 10

    # filename = "datafiles\\"+ curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "BN_Strangle.txt"

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        print("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                print("Call symbol is", callsymbol, "Quantity is ", quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                print("Put symbol is", putsymbol, "Quantity is ", quantity)

    pprint(symbol_dict)
    quantity = abs(callquantity)
    if (callsymbol == "" or putsymbol == ""):
        print("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return round(pnl, 1)
    symbols = [callsymbol, putsymbol]
    symbols_ltp = last_price(symbols)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    print("Call price is", callprice)
    print("Put price is", putprice)

    if (callprice > putprice):
        higher_price = callprice
        higher_symbol = callsymbol
        lower_price = putprice
        lower_symbol = putsymbol
    else:
        higher_price = putprice
        higher_symbol = putsymbol
        lower_price = callprice
        lower_symbol = callsymbol

    print("Current Ratio of both legs is ", round(higher_price / lower_price, 2))
    # print("Max Loss points is ", MaxLossPoints)
    sl_count = 0
    for i in range(num_orders - 1, 0, -1):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (processed_order_data[i][txn_type_index] == 'SLL'
                and (
                        symbol == callsymbol or symbol == putsymbol)):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            sl_count += 1
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            # print("SLL order status is -", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                print("Stop loss hit at average price", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                stop_loss_symbol = symbol
                sl_hit = 1
                break
            elif (sl_count == 2):
                print("Sl not hit yet")
                break
    if (sl_hit == 1):
        # Update the file
        # Cancel the other SL order - Done
        # Exit the active leg - Done
        # Place new orders- Done

        print("Updating File")
        f = open(filename, "w")  # For Overwriting Existing File
        for i in range(num_orders):
            num_parameters = len(processed_order_data[i])
            for j in range(num_parameters):
                f.write(processed_order_data[i][j])
                if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                    f.write("\t")
            f.write("\n")
        f.close()

        if (stop_loss_symbol == callsymbol):
            print("Call leg cut by SL, cancelling PUT SL and cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=producttype)
            time.sleep(2)

            putprice_buy = fetch_order(putorderid_buy)['average_price']

            f = open(filename, "a")  # Append mode
            f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                putprice_buy) + "\t" + str(curtime1) + "\n")
            f.close()
        elif (stop_loss_symbol == putsymbol):
            print("Put leg cut by SL, cancelling CALL SLand cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                            product=producttype)
            time.sleep(2)

            callprice_buy = fetch_order(callorderid_buy)['average_price']

            f = open(filename, "a")  # Append mode
            f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                callprice_buy) + "\t" + str(curtime1) + "\n")
            f.close()

        print("Starting both positions afresh now")

        nifty_cur_price = weekly_nifty_future()
        nifty_atm_strike = int(nifty_cur_price - nifty_cur_price % 50)
        put_strike_new = nifty_atm_strike
        call_strike_new = nifty_atm_strike

        while (True):

            putsymbol_new = nifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = nifty_strike_to_symbol(call_strike_new, "CALL")

            symbols = [callsymbol_new, putsymbol_new]
            symbols_ltp = last_price(symbols)
            callprice_new = symbols_ltp[0]
            putprice_new = symbols_ltp[1]

            if (callprice_new > day_premium):
                call_strike_new += 50
            if (putprice_new > day_premium):
                put_strike_new -= 50

            if (callprice_new < day_premium and putprice_new < day_premium):
                break

        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None,
                                       trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None,
                                        trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity,
                                       price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        f.close()

    elif (higher_price > day_premium + DeRiskPoints):
        print("Cutting both positions and de-risking")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()
        putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime2 = datetime.datetime.now()
        callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        print("Starting both positions afresh now")

        nifty_cur_price = weekly_nifty_future()
        nifty_atm_strike = int(nifty_cur_price - nifty_cur_price % 50)
        put_strike_new = nifty_atm_strike
        call_strike_new = nifty_atm_strike

        while (True):

            putsymbol_new = nifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = nifty_strike_to_symbol(call_strike_new, "CALL")

            symbols = [callsymbol_new, putsymbol_new]
            symbols_ltp = last_price(symbols)
            callprice_new = symbols_ltp[0]
            putprice_new = symbols_ltp[1]

            if (callprice_new > day_premium):
                call_strike_new += 50
            if (putprice_new > day_premium):
                put_strike_new -= 50

            if (callprice_new < day_premium and putprice_new < day_premium):
                break
        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putprice_buy = fetch_order(putorderid_buy)['average_price']
        callprice_buy = fetch_order(callorderid_buy)['average_price']

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
            putprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
            callprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()
    elif (higher_price / lower_price >= adjustment_level):

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        print("Cutting " + lower_symbol + " and entering matching position")

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = nifty_symbol_to_strike(putsymbol) + 50
            while (True):
                new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice):
                    put_strike += 50
                else:
                    break

            # put_strike-=50
            new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = nifty_symbol_to_strike(callsymbol) - 50
            while (True):
                new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice):
                    call_strike -= 50
                else:
                    break

            call_strike += 50
            new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()
    else:
        print("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return round(pnl, 1)


def monitor_banknifty_moving_strangle_without_file(producttype):
    banknifty_cur_price = weekly_banknifty_future()
    today_positions = kite.positions()
    num_positions = len(today_positions['net'])
    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3 or curday == 1):  # Exppiry Day - Thursday
        # call_max_range = 450
        # call_min_range = 250
        # put_max_range = 450
        # put_min_range = 250

        call_max_range = 500
        call_min_range = 300
        put_max_range = 500
        put_min_range = 300
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point strangle
        #     call_max_range = 160
        #     call_min_range = 80
        #     put_min_range = 100
        #     put_max_range = 180
        # elif(cur_hour==12 or cur_hour==13 ):
        #     call_max_range = 150
        #     call_min_range = 70
        #     put_max_range = 170
        #     put_min_range = 90
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        #     call_max_range = 135
        #     call_min_range = 55
        #     put_max_range = 155
        #     put_min_range = 75
    # elif(curday == 4):  # Friday - Start with a delta neutral 350 point strangle
    #     call_max_range = 180
    #     call_min_range = 100
    #     put_max_range = 230
    #     put_min_range = 150
    # elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
    #     call_max_range = 150
    #     call_min_range = 75
    #     put_max_range = 175
    #     put_min_range = 100
    # elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
    #     call_max_range = 170
    #     call_min_range = 90
    #     put_max_range = 190
    #     put_min_range = 110

    for i in range(num_positions):
        symbol = today_positions['net'][i]['tradingsymbol']
        quantity = today_positions['net'][i]['quantity']

        if ((symbol.startswith('BANKNIFTY') == True) and symbol.find('CE') > 0 and quantity < 0):
            # print("Call symbol is",symbol)
            callsymbol = symbol
            callquantity = abs(quantity)
        elif ((symbol.startswith('BANKNIFTY') == True) and symbol.find('PE') > 0 and quantity < 0):
            putsymbol = symbol
            putquantity = abs(quantity)

    if (callsymbol == "" and putsymbol == ""):
        print("Found No Positions to Monitor...Exiting!!")
        return
    else:

        callstrike = banknifty_symbol_to_strike(callsymbol)

        putstrike = banknifty_symbol_to_strike(putsymbol)

        put_diff = banknifty_cur_price - putstrike
        call_diff = callstrike - banknifty_cur_price

        if (call_diff > call_max_range):
            time.sleep(5)
            nifty_cur_price = weekly_banknifty_future()
            call_diff = callstrike - nifty_cur_price
            if (call_diff > call_max_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Down")
                banknifty_call_strike_down()
        elif (call_diff < call_min_range):
            time.sleep(5)
            nifty_cur_price = weekly_banknifty_future()
            call_diff = callstrike - nifty_cur_price
            if (call_diff < call_min_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Up")
                banknifty_call_strike_up()
        else:
            print("Call Strike Diff is ", int(call_diff), "Nothing to do right now !!")
            print("Will Move Calls Up At ", callstrike - call_min_range)
            print("Will Move Calls Down At ", callstrike - call_max_range)

        if (put_diff > put_max_range):
            time.sleep(5)
            nifty_cur_price = weekly_banknifty_future()
            put_diff = nifty_cur_price - putstrike
            if (put_diff > put_max_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Up")
                banknifty_put_strike_up()
        elif (put_diff < put_min_range):
            time.sleep(5)
            nifty_cur_price = weekly_banknifty_future()
            if (put_diff < put_min_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Down")
                banknifty_put_strike_down()
        else:
            print("Put Strike Diff is ", int(put_diff), "Nothing to do right now !!")
            print("Will Move Puts Up At ", putstrike + put_max_range)
            print("Will Move Puts Down At ", putstrike + put_min_range)


def get_nifty_watchlist(strike_nifty, num_strikes, nifty_prefix):
    # NIFTY_OPTION_CHAIN_WATCHLIST.clear()
    # global NIFTY_OPTION_CHAIN_WATCHLIST
    NIFTY_OPTION_CHAIN_WATCHLIST = [256265]

    for x in range(num_strikes):
        val = strike_nifty + (int)((num_strikes - x) * 50)
        ap_val_h = str(val)
        ap_val = nifty_prefix + ap_val_h + "CE"
        NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_nifty - (int)(x * 50)
        ap_val_h = str(val)
        ap_val = nifty_prefix + ap_val_h + "CE"
        NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_nifty + (int)((num_strikes - x) * 50)
        ap_val_h = str(val)
        ap_val = nifty_prefix + ap_val_h + "PE"
        NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_nifty - (int)(x * 50)
        ap_val_h = str(val)
        ap_val = nifty_prefix + ap_val_h + "PE"
        NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    return NIFTY_OPTION_CHAIN_WATCHLIST


def get_nifty_COP_watchlist(strike_nifty, num_strikes, nifty_prefix, COP):
    # NIFTY_OPTION_CHAIN_WATCHLIST.clear()
    # global NIFTY_OPTION_CHAIN_WATCHLIST
    NIFTY_OPTION_CHAIN_WATCHLIST = []
    if (COP == "CALL"):

        for x in range(num_strikes):
            val = strike_nifty + (int)((num_strikes - x) * 50)
            ap_val_h = str(val)
            ap_val = nifty_prefix + ap_val_h + "CE"
            NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == "CALL"):
        for x in range(num_strikes):
            val = strike_nifty - (int)(x * 50)
            ap_val_h = str(val)
            ap_val = nifty_prefix + ap_val_h + "CE"
            NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    if (COP == "PUT"):
        for x in range(num_strikes):
            val = strike_nifty + (int)((num_strikes - x) * 50)
            ap_val_h = str(val)
            ap_val = nifty_prefix + ap_val_h + "PE"
            NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == "PUT"):
        for x in range(num_strikes):
            val = strike_nifty - (int)(x * 50)
            ap_val_h = str(val)
            ap_val = nifty_prefix + ap_val_h + "PE"
            NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    return NIFTY_OPTION_CHAIN_WATCHLIST


def get_midcap_nifty_COP_watchlist(strike_midcap_nifty, num_strikes, midcap_nifty_prefix, COP):
    # NIFTY_OPTION_CHAIN_WATCHLIST.clear()
    # global NIFTY_OPTION_CHAIN_WATCHLIST
    MIDCAP_NIFTY_OPTION_CHAIN_WATCHLIST = []
    if (COP == "CALL"):

        for x in range(num_strikes):
            val = strike_midcap_nifty + (int)((num_strikes - x) * 50)
            ap_val_h = str(val)
            ap_val = midcap_nifty_prefix + ap_val_h + "CE"
            MIDCAP_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == "CALL"):
        for x in range(num_strikes):
            val = strike_midcap_nifty - (int)(x * 50)
            ap_val_h = str(val)
            ap_val = midcap_nifty_prefix + ap_val_h + "CE"
            MIDCAP_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    if (COP == "PUT"):
        for x in range(num_strikes):
            val = strike_midcap_nifty + (int)((num_strikes - x) * 50)
            ap_val_h = str(val)
            ap_val = midcap_nifty_prefix + ap_val_h + "PE"
            MIDCAP_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == "PUT"):
        for x in range(num_strikes):
            val = strike_midcap_nifty - (int)(x * 50)
            ap_val_h = str(val)
            ap_val = midcap_nifty_prefix + ap_val_h + "PE"
            MIDCAP_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    return MIDCAP_NIFTY_OPTION_CHAIN_WATCHLIST


def get_sensex_COP_watchlist(strike_sensex, num_strikes, sensex_prefix, COP):
    # NIFTY_OPTION_CHAIN_WATCHLIST.clear()
    # global NIFTY_OPTION_CHAIN_WATCHLIST
    SENSEX_OPTION_CHAIN_WATCHLIST = []
    if (COP == "CALL"):

        for x in range(num_strikes):
            val = strike_sensex + (int)((num_strikes - x) * 100)
            ap_val_h = str(val)
            ap_val = sensex_prefix + ap_val_h + "CE"
            SENSEX_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == "CALL"):
        for x in range(num_strikes):
            val = strike_sensex - (int)(x * 100)
            ap_val_h = str(val)
            ap_val = sensex_prefix + ap_val_h + "CE"
            SENSEX_OPTION_CHAIN_WATCHLIST.append(ap_val)

    if (COP == "PUT"):
        for x in range(num_strikes):
            val = strike_sensex + (int)((num_strikes - x) * 100)
            ap_val_h = str(val)
            ap_val = sensex_prefix + ap_val_h + "PE"
            SENSEX_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == "PUT"):
        for x in range(num_strikes):
            val = strike_sensex - (int)(x * 100)
            ap_val_h = str(val)
            ap_val = sensex_prefix + ap_val_h + "PE"
            SENSEX_OPTION_CHAIN_WATCHLIST.append(ap_val)

    return SENSEX_OPTION_CHAIN_WATCHLIST


def get_fin_nifty_COP_watchlist(strike_fin_nifty, num_strikes, fin_nifty_prefix, COP):
    # NIFTY_OPTION_CHAIN_WATCHLIST.clear()
    # global NIFTY_OPTION_CHAIN_WATCHLIST
    FIN_NIFTY_OPTION_CHAIN_WATCHLIST = [257801]
    if (COP == "CALL"):

        for x in range(num_strikes):
            val = strike_fin_nifty + (int)((num_strikes - x) * 50)
            ap_val_h = str(val)
            ap_val = fin_nifty_prefix + ap_val_h + "CE"
            FIN_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == "CALL"):
        for x in range(num_strikes):
            val = strike_fin_nifty - (int)(x * 50)
            ap_val_h = str(val)
            ap_val = fin_nifty_prefix + ap_val_h + "CE"
            FIN_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    if (COP == "PUT"):
        for x in range(num_strikes):
            val = strike_fin_nifty + (int)((num_strikes - x) * 50)
            ap_val_h = str(val)
            ap_val = fin_nifty_prefix + ap_val_h + "PE"
            FIN_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == "PUT"):
        for x in range(num_strikes):
            val = strike_fin_nifty - (int)(x * 50)
            ap_val_h = str(val)
            ap_val = fin_nifty_prefix + ap_val_h + "PE"
            FIN_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    return FIN_NIFTY_OPTION_CHAIN_WATCHLIST


def get_fin_nifty_watchlist(strike_fin_nifty, num_strikes, fin_nifty_prefix):
    # NIFTY_OPTION_CHAIN_WATCHLIST.clear()
    # global BANK_NIFTY_OPTION_CHAIN_WATCHLIST
    FIN_NIFTY_OPTION_CHAIN_WATCHLIST = [257801]

    for x in range(num_strikes):
        val = strike_fin_nifty + (int)((num_strikes - x) * 50)
        ap_val_h = str(val)
        ap_val = fin_nifty_prefix + ap_val_h + "CE"
        FIN_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_fin_nifty - (int)(x * 50)
        ap_val_h = str(val)
        ap_val = fin_nifty_prefix + ap_val_h + "CE"
        FIN_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_fin_nifty + (int)((num_strikes - x) * 50)
        ap_val_h = str(val)
        ap_val = fin_nifty_prefix + ap_val_h + "PE"
        FIN_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_fin_nifty - (int)(x * 50)
        ap_val_h = str(val)
        ap_val = fin_nifty_prefix + ap_val_h + "PE"
        FIN_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    return FIN_NIFTY_OPTION_CHAIN_WATCHLIST


def get_bank_nifty_watchlist(strike_bank_nifty, num_strikes, bank_nifty_prefix):
    # NIFTY_OPTION_CHAIN_WATCHLIST.clear()
    # global BANK_NIFTY_OPTION_CHAIN_WATCHLIST
    BANK_NIFTY_OPTION_CHAIN_WATCHLIST = [260105]

    for x in range(num_strikes):
        val = strike_bank_nifty + (int)((num_strikes - x) * 100)
        ap_val_h = str(val)
        ap_val = bank_nifty_prefix + ap_val_h + "CE"
        BANK_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_bank_nifty - (int)(x * 100)
        ap_val_h = str(val)
        ap_val = bank_nifty_prefix + ap_val_h + "CE"
        BANK_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_bank_nifty + (int)((num_strikes - x) * 100)
        ap_val_h = str(val)
        ap_val = bank_nifty_prefix + ap_val_h + "PE"
        BANK_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    for x in range(num_strikes):
        val = strike_bank_nifty - (int)(x * 100)
        ap_val_h = str(val)
        ap_val = bank_nifty_prefix + ap_val_h + "PE"
        BANK_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    return BANK_NIFTY_OPTION_CHAIN_WATCHLIST


def get_details_for_expiry(expiry_name):
    """
    Returns a dictionary containing details for a given expiry name.

    Parameters:
    expiry_name (str): Name of the expiry (nifty, banknifty, finnifty, midcap, sensex)

    Returns:
    dict: A dictionary containing the following details:
        cash_exchange_segment (str): Cash exchange segment (NSE for nifty, banknifty, finnifty, midcap; BSE for sensex)
        options_exchange_segment (str): Options exchange segment (NFO for nifty, banknifty, finnifty, midcap; BFO for sensex)
        options_instrument_type (str): Options instrument type (OPTIDX for all)
        options_symbol_name (str): Options symbol name (NIFTY for nifty, banknifty, finnifty, midcap; None for sensex)

    Raises:
    Exception: If an invalid expiry name is provided.
    """
    details = {}
    if expiry_name == 'nifty' or expiry_name == 'banknifty' or expiry_name == 'finnifty' or expiry_name == 'midcap':
        details['cash_exchange_segment'] = 'NSE'
        details['options_exchange_segment'] = 'NFO'
        details['options_instrument_type'] = 'OPTIDX'
        # details['options_symbol_name'] = 'NIFTY'

        if expiry_name == 'nifty':
            details['difference_between_strikes'] = 50
            details['lot_size'] = 50
        elif expiry_name == 'banknifty':
            details['difference_between_strikes'] = 100
            details['lot_size'] = 15
        elif expiry_name == 'finnifty':
            details['difference_between_strikes'] = 50
            details['lot_size'] = 40
        elif expiry_name == 'midcap':
            details['difference_between_strikes'] = 25
            details['lot_size'] = 75

    elif expiry_name == "sensex":
        details['cash_exchange_segment'] = 'BSE'
        details['options_exchange_segment'] = 'BFO'
        details['options_instrument_type'] = 'OPTIDX'
        details['difference_between_strikes'] = 100
        details['lot_size'] = 10

        # details['options_symbol_name'] = 'NIFTY'
    else:
        raise Exception(f"Invalid expiry name {expiry_name}")
    return details


def get_bank_nifty_COP_watchlist(strike_bank_nifty, num_strikes, bank_nifty_prefix, COP):
    # NIFTY_OPTION_CHAIN_WATCHLIST.clear()
    # global BANK_NIFTY_OPTION_CHAIN_WATCHLIST
    BANK_NIFTY_OPTION_CHAIN_WATCHLIST = []
    if (COP == 'CALL'):
        for x in range(num_strikes):
            val = strike_bank_nifty + (int)((num_strikes - x) * 100)
            ap_val_h = str(val)
            ap_val = bank_nifty_prefix + ap_val_h + "CE"
            BANK_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == 'CALL'):
        for x in range(num_strikes):
            val = strike_bank_nifty - (int)(x * 100)
            ap_val_h = str(val)
            ap_val = bank_nifty_prefix + ap_val_h + "CE"
            BANK_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == 'PUT'):
        for x in range(num_strikes):
            val = strike_bank_nifty + (int)((num_strikes - x) * 100)
            ap_val_h = str(val)
            ap_val = bank_nifty_prefix + ap_val_h + "PE"
            BANK_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)
    if (COP == 'PUT'):
        for x in range(num_strikes):
            val = strike_bank_nifty - (int)(x * 100)
            ap_val_h = str(val)
            ap_val = bank_nifty_prefix + ap_val_h + "PE"
            BANK_NIFTY_OPTION_CHAIN_WATCHLIST.append(ap_val)

    return BANK_NIFTY_OPTION_CHAIN_WATCHLIST


def TIME_TO_EXPIRY_FIRSTOCK(expiry_name):
    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    symbol_expiryday = 0
    if expiry_name == "nifty":
        symbol_expiryday = expiryday
    elif expiry_name == "banknifty":
        symbol_expiryday = bn_expiryday
    elif expiry_name == "finnifty":
        symbol_expiryday = fin_expiryday
    elif expiry_name == "midcap":
        symbol_expiryday = midcap_expiryday
    elif expiry_name == "sensex":
        symbol_expiryday = sensex_expiryday

    if curday <= symbol_expiryday:  # 0 Is Monday,1 TUE,2 WED, 3 is Thursday, 4 FRI
        days_remaining = symbol_expiryday - curday
    elif curday > symbol_expiryday:
        days_remaining = symbol_expiryday - curday + 7
    TIME_REMAINING_IN_PRESENT_DAY = 0
    if (curday == 3):  # thursday
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    if (TIME_REMAINING_IN_PRESENT_DAY < 0):
        TIME_REMAINING_IN_PRESENT_DAY = 0
    else:
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    TIME_REMAINING_IN_PRESENT_DAY = TIME_REMAINING_IN_PRESENT_DAY / 15.5  # in days
    ACTUAL_DAYS_TO_EXPIRY = TIME_REMAINING_IN_PRESENT_DAY + days_remaining
    t = ACTUAL_DAYS_TO_EXPIRY / 365  # TIME TO EXPIRY IN YEARS
    if (t == 0):
        t = 0.00001
    return t


def TIME_TO_EXPIRY():
    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= expiryday:  # 0 Is Monday,1 TUE,2 WED, 3 is Thursday, 4 FRI
        days_remaining = expiryday - curday
    elif curday > expiryday:
        days_remaining = expiryday - curday + 7
    TIME_REMAINING_IN_PRESENT_DAY = 0
    if (curday == 3):  # thursday
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    if (TIME_REMAINING_IN_PRESENT_DAY < 0):
        TIME_REMAINING_IN_PRESENT_DAY = 0
    else:
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    TIME_REMAINING_IN_PRESENT_DAY = TIME_REMAINING_IN_PRESENT_DAY / 15.5  # in days
    ACTUAL_DAYS_TO_EXPIRY = TIME_REMAINING_IN_PRESENT_DAY + days_remaining
    t = ACTUAL_DAYS_TO_EXPIRY / 365  # TIME TO EXPIRY IN YEARS
    if (t == 0):
        t = 0.00001
    return t


def MIDCAP_TIME_TO_EXPIRY():
    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= midcap_expiryday:  # 0 Is Monday,1 TUE,2 WED, 3 is Thursday, 4 FRI
        days_remaining = midcap_expiryday - curday
    elif curday > midcap_expiryday:
        days_remaining = midcap_expiryday - curday + 7
    TIME_REMAINING_IN_PRESENT_DAY = 0
    if (curday == midcap_expiryday):  # thursday
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    if (TIME_REMAINING_IN_PRESENT_DAY < 0):
        TIME_REMAINING_IN_PRESENT_DAY = 0
    else:
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    TIME_REMAINING_IN_PRESENT_DAY = TIME_REMAINING_IN_PRESENT_DAY / 15.5  # in days
    ACTUAL_DAYS_TO_EXPIRY = TIME_REMAINING_IN_PRESENT_DAY + days_remaining
    t = ACTUAL_DAYS_TO_EXPIRY / 365  # TIME TO EXPIRY IN YEARS
    if (t == 0):
        t = 0.00001
    return t


def SENSEX_TIME_TO_EXPIRY():
    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= sensex_expiryday:  # 0 Is Monday,1 TUE,2 WED, 3 is Thursday, 4 FRI
        days_remaining = sensex_expiryday - curday
    elif curday > sensex_expiryday:
        days_remaining = sensex_expiryday - curday + 7
    TIME_REMAINING_IN_PRESENT_DAY = 0
    if (curday == sensex_expiryday):  # thursday
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    if (TIME_REMAINING_IN_PRESENT_DAY < 0):
        TIME_REMAINING_IN_PRESENT_DAY = 0
    else:
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    TIME_REMAINING_IN_PRESENT_DAY = TIME_REMAINING_IN_PRESENT_DAY / 15.5  # in days
    ACTUAL_DAYS_TO_EXPIRY = TIME_REMAINING_IN_PRESENT_DAY + days_remaining
    t = ACTUAL_DAYS_TO_EXPIRY / 365  # TIME TO EXPIRY IN YEARS
    if (t == 0):
        t = 0.00001
    return t


def FIN_TIME_TO_EXPIRY():
    curtime = datetime.datetime.now()
    cur_minute = curtime.minute
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    if curday <= 1:  # 0 Is Monday,1 TUE,2 WED, 3 is Thursday, 4 FRI
        days_remaining = fin_expiryday - curday
    elif curday > 3:
        days_remaining = fin_expiryday - curday + 7
    TIME_REMAINING_IN_PRESENT_DAY = 0
    if (curday == 1):  # thursday
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    if (TIME_REMAINING_IN_PRESENT_DAY < 0):
        TIME_REMAINING_IN_PRESENT_DAY = 0
    else:
        TIME_REMAINING_IN_PRESENT_DAY = 15.5 - cur_hour - (cur_minute / 60)  # in hours
    TIME_REMAINING_IN_PRESENT_DAY = TIME_REMAINING_IN_PRESENT_DAY / 15.5  # in days
    ACTUAL_DAYS_TO_EXPIRY = TIME_REMAINING_IN_PRESENT_DAY + days_remaining
    t = ACTUAL_DAYS_TO_EXPIRY / 365  # TIME TO EXPIRY IN YEARS
    if (t == 0):
        t = 0.00001
    return t


def nifty_n_delta_strike_firstock(delta, df, put_or_call):
    """

    :param delta: INT -> Delta (1-100)
    :param df: Option Chain DF with 20 strikes, and associated data
    :param put_or_call: "p" or "c" -> put or call
    :return: strike price INT
    """
    # while (True):
    strike = 0
    if (put_or_call == "p"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = v["integer_strike"]
            # OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = v["integer_strike"]
            # OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                return strike

    return strike


def nifty_n_delta_strike(delta, df, put_or_call):
    # while (True):
    strike = 0
    if (put_or_call == "p"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                return strike

    return strike


def midcap_nifty_n_delta_strike(delta, df, put_or_call):
    # while (True):
    strike = 0
    if (put_or_call == "p"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801' or k == '288009'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-6:]
            OPTION_strike = int(OPTION_strike[:4])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801' or k == '288009'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-6:]
            OPTION_strike = int(OPTION_strike[:4])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                return strike

    return strike


def sensex_n_delta_strike(delta, df, put_or_call):
    # while (True):
    strike = 0
    if (put_or_call == "p"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801' or k == '288009' or k == '265'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801' or k == '288009' or k == '265'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                return strike

    return strike


def fin_nifty_n_delta_strike(delta, df, put_or_call):
    # while (True):
    strike = 0
    if (put_or_call == "p"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                return strike

    return strike


def nifty_n_delta_strike_with_ltp(delta, df, put_or_call):
    # while (True):
    strike = 0
    ltp = 0
    if (put_or_call == "p"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            OPTION_LTP = v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                ltp = int(OPTION_LTP)

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            OPTION_LTP = v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                # OPTION_LTP=v['last_price']
                ltp = int(OPTION_LTP)
                return strike, ltp

    return strike, ltp


def bank_nifty_n_delta_strike(delta, df, put_or_call):
    # while (True):
    strike = 0
    OPTION_LTP = 0
    if (put_or_call == "p"):

        for k, v in df.iterrows():
            if k == '260105' or k == '256265' or k == '257801':
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])

            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                OPTION_LTP = v['last_price']

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            OPTION_LTP = v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                return strike, OPTION_LTP

    return strike, OPTION_LTP


def bank_nifty_n_delta_strike_for_run_sheet(delta, df, put_or_call):
    # while (True):
    strike = 0
    OPTION_LTP = 0
    if put_or_call == "p":

        for k, v in df.iterrows():
            if k == '260105' or k == '256265' or k == '257801':
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])

            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                OPTION_LTP = v['last_price']

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            OPTION_LTP = v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                return strike

    return strike


def fin_nifty_n_delta_strike_for_run_sheet(delta, df, put_or_call):
    # while (True):
    strike = 0
    if (put_or_call == "p"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)

    elif (put_or_call == "c"):

        for k, v in df.iterrows():
            if (k == '260105' or k == '256265' or k == '257801'):
                print("ye ni krna")
                continue

            OPTION_strike = k[-7:]
            OPTION_strike = int(OPTION_strike[:5])
            # OPTION_LTP=v['last_price']
            OPTION_DELTA = v['DELTA']
            if (OPTION_DELTA < delta and OPTION_DELTA != 0):
                strike = int(OPTION_strike)
                return strike

    return strike


def COMPLETE_SYMBOL_WATCHLIST_FIRSTOCK(expiry_name):
    """
    :param: expiry_name: "sensex", "nifty", "banknifty", "midcap", "finnifty"
    :return: 2 Dataframe  (CE AND PE )with columns : 	INDEX -> instrument_name integer_strike	instrument_token	timestamp
    last_trade_time	last_price	last_quantity	buy_quantity	sell_quantity	volume	average_price
    oi	oi_day_high	oi_day_low	net_change	lower_circuit_limit	upper_circuit_limit	IV	DELTA	THETA	GAMMA

    """
    # regex pattern set
    pattern = r'\d{4,6}'

    # nifty_prefix = nifty_current_expiry_symbol()
    exchange, token, token_scrip, diff_between_two_strikes = getDetailsFromExpiryName_Firstock(expiry_name)

    # nifty_strike = float(
    #     thefirstock.firstock_getQuoteLTP(exchange="NSE", token="Nifty 50")['data']['lastTradedPrice'])
    symbol_cur_price = None
    try:
        symbol_cur_price = float(
            thefirstock.firstock_getQuoteLTP(exchange=exchange, token=token)['data']['lastTradedPrice'])
    except Exception as e:
        time.sleep(1)
        symbol_cur_price = float(
            thefirstock.firstock_getQuoteLTP(exchange=exchange, token=token)['data']['lastTradedPrice'])

    nearer_strike = symbol_cur_price / diff_between_two_strikes
    mod = symbol_cur_price % diff_between_two_strikes

    if mod > diff_between_two_strikes / 2:
        nearer_strike = (int(nearer_strike) + 1) * diff_between_two_strikes
    else:
        nearer_strike = (int(nearer_strike)) * diff_between_two_strikes

    put_symbol_firstock = firstock_strike_to_symbol(expiry_name, nearer_strike, "PUT")
    call_symbol_firstock = firstock_strike_to_symbol(expiry_name, nearer_strike, "CALL")

    # put_symbol_firstock = firstock_nifty_strike_to_symbol(strike_nifty, "PUT")
    # call_symbol_firstock = firstock_nifty_strike_to_symbol(strike_nifty, "CALL")

    # for the current call_symbol_firstock (or can be put symbol, does not matter)
    # output : has status, data : {values: exchange, token, tradingsymbol, optiontype, lotsize and strikeprice}
    # we enrich this data with LTP, buy , sell , OI values in later for loop
    symbol_exchange = None
    if exchange == "NSE":
        symbol_exchange = "NFO"
    elif exchange == "BSE":
        symbol_exchange = "BFO"

    optionChain = thefirstock.firstock_OptionChain(
        exchange=symbol_exchange,
        tradingSymbol=call_symbol_firstock,
        strikePrice=str(nearer_strike),
        count="20"
    )

    # Create data token (input format to get multi-asset-quotes from firstock)
    # output: Lotsize, dayhigh,daylow, volume, lasttradedquantity, last traded price, depth (as best buy/ sell price)
    dataToken = []
    optionChainDF = None
    if (optionChain['status'] == 'Success'):
        for data in optionChain['data']:
            dataToken.append({
                "exchange": data['exchange'],
                "token": data['token']
            })

        # the getMultiQuote function gets at max 10 quotes at a time now
        enriched_data_optionchain = []
        batch_size = 20
        for i in range(0, len(dataToken), batch_size):
            time.sleep(1)
            dataToken_batch = dataToken[i:i + batch_size]
            enriched_data_optionchain_batch = thefirstock.firstock_getMultiQuote(
                dataToken=dataToken_batch
            )
            if enriched_data_optionchain_batch['status'] == 'Success':
                token_dictionary_list = enriched_data_optionchain_batch['data']
                for token_dict in token_dictionary_list:
                    enriched_data_optionchain.append(token_dict)
            else:
                time.sleep(0.2)
                enriched_data_optionchain_batch = thefirstock.firstock_getMultiQuote(
                    dataToken=dataToken_batch
                )
                if enriched_data_optionchain_batch['status'] == 'Success':
                    token_dictionary_list = enriched_data_optionchain_batch['data']
                    for token_dict in token_dictionary_list:
                        enriched_data_optionchain.append(token_dict)
                else:
                    raise Exception(
                        "Exception raised at Firststock_getMultiquote in function COMPLETE_NIFTY_WATCHLIST_FIRSTOCK()")

        # enriched_data_optionchain = thefirstock.firstock_getMultiQuote(
        #     dataToken=dataToken
        # )

        # getMultiQuotes_temp = enriched_data_optionchain
        #         print(getMultiQuotes_temp)

        # Create a Dataframe from enriched_data_option_chain (Desired format -> same as Zerodha data)
        # Output: Dataframe which we get from COMPLETE_NIFTY_WATCHLIST() in Zerodha
        oc_data_list = []
        if True:
            # for data in enriched_data_optionchain['data']:
            #     pass

            columns = ["instrument_name", "instrument_token", "timestamp", "last_trade_time", "last_price",
                       "last_quantity", "buy_quantity",
                       "sell_quantity", "volume", "average_price", "oi", "oi_day_high", "oi_day_low", "net_change",
                       "lower_circuit_limit",
                       "upper_circuit_limit", "IV", "DELTA", "THETA", "GAMMA"]

            # nifty_spot_p = float(
            #     thefirstock.firstock_getQuoteLTP(exchange="NSE", token="Nifty 50")['data']['lastTradedPrice'])
            try:
                symbol_spot_p = float(
                    thefirstock.firstock_getQuoteLTP(exchange=exchange, token=token)['data']['lastTradedPrice'])
            except Exception as e:
                time.sleep(1)
                symbol_spot_p = float(
                    thefirstock.firstock_getQuoteLTP(exchange=exchange, token=token)['data']['lastTradedPrice'])

            t = TIME_TO_EXPIRY()  # TIME TO EXPIRY IN YEARS

            # oc_data_list = []
            oc_data_list_call = []
            oc_data_list_put = []

            for data in enriched_data_optionchain:

                # in some cases , last traded price is not fetched maybe due to inliquidity.
                if 'lastTradedPrice' in data['result'].keys():
                    pass
                else:
                    continue
                dResult = data['result']
                dToken = dResult['token']
                instrument_name = dResult['tradingSymbol']
                company_name = dResult['companyName']
                instrument_token = dToken
                timestamp = dResult['requestTime']
                last_trade_time = dResult['lastTradeTime']
                last_price = dResult['lastTradedPrice']
                last_quantity = dResult['lastTradedQuantity']
                buy_quantity = None
                sell_quantity = None
                volume = dResult['volume']
                average_price = None
                oi = None
                oi_day_high = None
                oi_day_low = None
                net_change = None
                lower_circuit_limit = dResult['lowerCircuit']
                upper_circuit_limit = dResult['upperCircuit']
                IV = None
                DELTA = None
                THETA = None
                GAMMA = None

                if expiry_name == "sensex":
                    pass
                elif expiry_name == "nifty":
                    pass
                elif expiry_name == "banknifty":
                    pass
                elif expiry_name == "midcap":
                    pass
                elif expiry_name == "finnifty":
                    pass

                if expiry_name == "sensex":
                    instrument_type = data['result']['tradingSymbol'][-2:]
                else:
                    instrument_type = data['result']['tradingSymbol'][-6:-5]

                if instrument_type == 'C' or instrument_type == "CE":
                    # calculate greeks using pyvollib
                    # OPTION_strike = instrument_name[-5:]

                    # Option Strike using company name
                    # This pattern recognises 4 , 5 , 6 digit numbers in string company name of type:
                    match = re.search(pattern, company_name)
                    if match:
                        OPTION_strike = match.group()
                    OPTION_strike = int(OPTION_strike)
                    OPTION_LTP = float(last_price)
                    if (OPTION_LTP == 0):
                        OPTION_LTP = 0.05

                    NIFTY_SPOT_CALL_IV, NIFTY_SPOT_CALL_GREEKS = nify_get_greeks(OPTION_LTP, symbol_spot_p,
                                                                                 int(OPTION_strike), t, 'c')
                    NIFTY_SPOT_CALL_DELTA = NIFTY_SPOT_CALL_GREEKS['delta'][0] * 100
                    NIFTY_SPOT_PUT_IV = NIFTY_SPOT_CALL_IV * 100
                    NIFTY_SPOT_CALL_THETA = NIFTY_SPOT_CALL_GREEKS['theta'][0]
                    NIFTY_SPOT_CALL_GAMMA = NIFTY_SPOT_CALL_GREEKS['gamma'][0]

                    oc_data_list_call.append({
                        "integer_strike": OPTION_strike,
                        "instrument_name": dResult['tradingSymbol'],
                        "instrument_token": str(dToken),
                        "timestamp": dResult['requestTime'],
                        "last_trade_time": dResult['lastTradeTime'],
                        "last_price": dResult['lastTradedPrice'],
                        "last_quantity": dResult['lastTradedQuantity'],
                        "buy_quantity": None,
                        "sell_quantity": None,
                        "volume": dResult['volume'],
                        "average_price": None,
                        "oi": None,
                        "oi_day_high": None,
                        "oi_day_low": None,
                        "net_change": None,
                        "lower_circuit_limit": dResult['lowerCircuit'],
                        "upper_circuit_limit": dResult['upperCircuit'],
                        "IV": NIFTY_SPOT_CALL_IV,
                        "DELTA": NIFTY_SPOT_CALL_DELTA,
                        "THETA": NIFTY_SPOT_CALL_THETA,
                        "GAMMA": NIFTY_SPOT_CALL_GAMMA,
                    })
                elif instrument_type == 'P' or instrument_type == "PE":
                    # calculate greeks using pyvollib
                    # This pattern recognises 4 , 5 , 6 digit numbers in string company name of type:
                    match = re.search(pattern, company_name)
                    if match:
                        OPTION_strike = match.group()
                    OPTION_strike = int(OPTION_strike)

                    OPTION_LTP = float(last_price)
                    if (OPTION_LTP == 0):
                        OPTION_LTP = 0.05
                    NIFTY_SPOT_PUT_IV, NIFTY_SPOT_PUT_GREEKS = nify_get_greeks(OPTION_LTP, symbol_spot_p,
                                                                               int(OPTION_strike), t, 'p')
                    NIFTY_SPOT_PUT_DELTA = NIFTY_SPOT_PUT_GREEKS['delta'][0] * (-100)
                    NIFTY_SPOT_PUT_IV = NIFTY_SPOT_PUT_IV * 100
                    NIFTY_SPOT_PUT_THETA = NIFTY_SPOT_PUT_GREEKS['theta'][0]
                    NIFTY_SPOT_PUT_GAMMA = NIFTY_SPOT_PUT_GREEKS['gamma'][0]

                    oc_data_list_put.append({
                        "integer_strike": OPTION_strike,
                        "instrument_name": dResult['tradingSymbol'],
                        "instrument_token": str(dToken),
                        "timestamp": dResult['requestTime'],
                        "last_trade_time": dResult['lastTradeTime'],
                        "last_price": dResult['lastTradedPrice'],
                        "last_quantity": dResult['lastTradedQuantity'],
                        "buy_quantity": None,
                        "sell_quantity": None,
                        "volume": dResult['volume'],
                        "average_price": None,
                        "oi": None,
                        "oi_day_high": None,
                        "oi_day_low": None,
                        "net_change": None,
                        "lower_circuit_limit": dResult['lowerCircuit'],
                        "upper_circuit_limit": dResult['upperCircuit'],
                        "IV": NIFTY_SPOT_PUT_IV,
                        "DELTA": NIFTY_SPOT_PUT_DELTA,
                        "THETA": NIFTY_SPOT_PUT_THETA,
                        "GAMMA": NIFTY_SPOT_PUT_GAMMA,
                    })
            CALL_NIFTY_OPTION_CHAIN_df = pd.DataFrame(oc_data_list_call)
            CALL_NIFTY_OPTION_CHAIN_df.sort_values(by=['integer_strike'], inplace=True)
            #             CALL_NIFTY_OPTION_CHAIN_df.drop(['integer_strike'], axis = 1, inplace = True)
            CALL_NIFTY_OPTION_CHAIN_df.set_index('instrument_name', inplace=True)
            PUT_NIFTY_OPTION_CHAIN_df = pd.DataFrame(oc_data_list_put)
            PUT_NIFTY_OPTION_CHAIN_df.sort_values(by=['integer_strike'], inplace=True)
            #             PUT_NIFTY_OPTION_CHAIN_df.drop(['integer_strike'], axis = 1, inplace = True)
            PUT_NIFTY_OPTION_CHAIN_df.set_index('instrument_name', inplace=True)

            return CALL_NIFTY_OPTION_CHAIN_df, PUT_NIFTY_OPTION_CHAIN_df
        else:
            raise Exception(
                "Exception raised at Firststock_getMultiquote in function COMPLETE_NIFTY_WATCHLIST_FIRSTOCK()")
    else:
        raise Exception("Option Chain Function did not return desired option chain. Check immediately...")


def COMPLETE_NIFTY_WATCHLIST_FIRSTOCK():
    """

    :return: 2 Dataframe  (CE AND PE )with columns : 	INDEX -> instrument_name integer_strike	instrument_token	timestamp
    last_trade_time	last_price	last_quantity	buy_quantity	sell_quantity	volume	average_price
    oi	oi_day_high	oi_day_low	net_change	lower_circuit_limit	upper_circuit_limit	IV	DELTA	THETA	GAMMA

    """
    nifty_prefix = nifty_current_expiry_symbol()
    nifty_strike = float(
        thefirstock.firstock_getQuoteLTP(exchange="NSE", token="Nifty 50")['data']['lastTradedPrice'])

    strike_nifty = nifty_strike / 50
    mod = nifty_strike % 50

    if mod > 25:
        strike_nifty = (int(strike_nifty) + 1) * 50
    else:
        strike_nifty = (int(strike_nifty)) * 50

    put_symbol_firstock = firstock_nifty_strike_to_symbol(strike_nifty, "PUT")
    call_symbol_firstock = firstock_nifty_strike_to_symbol(strike_nifty, "CALL")
    # for the current call_symbol_firstock (or can be put symbol, does not matter)
    # output : has status, data : {values: exchange, token, tradingsymbol, optiontype, lotsize and strikeprice}
    # we enrich this data with LTP, buy , sell , OI values in later for loop
    optionChain = thefirstock.firstock_OptionChain(
        exchange="NFO",
        tradingSymbol=call_symbol_firstock,
        strikePrice=str(strike_nifty),
        count="20"
    )

    # Create data token (input format to get multi-asset-quotes from firstock)
    # output: Lotsize, dayhigh,daylow, volume, lasttradedquantity, last traded price, depth (as best buy/ sell price)
    dataToken = []
    optionChainDF = None
    if (optionChain['status'] == 'Success'):
        for data in optionChain['data']:
            dataToken.append({
                "exchange": data['exchange'],
                "token": data['token']
            })

        enriched_data_optionchain = thefirstock.firstock_getMultiQuote(
            dataToken=dataToken
        )
        getMultiQuotes_temp = enriched_data_optionchain
        #         print(getMultiQuotes_temp)

        # Create a Dataframe from enriched_data_option_chain (Desired format -> same as Zerodha data)
        # Output: Dataframe which we get from COMPLETE_NIFTY_WATCHLIST() in Zerodha
        oc_data_list = []
        if (enriched_data_optionchain['status'] == 'Success'):
            for data in enriched_data_optionchain['data']:
                pass

            columns = ["instrument_name", "instrument_token", "timestamp", "last_trade_time", "last_price",
                       "last_quantity", "buy_quantity",
                       "sell_quantity", "volume", "average_price", "oi", "oi_day_high", "oi_day_low", "net_change",
                       "lower_circuit_limit",
                       "upper_circuit_limit", "IV", "DELTA", "THETA", "GAMMA"]

            nifty_spot_p = float(
                thefirstock.firstock_getQuoteLTP(exchange="NSE", token="Nifty 50")['data']['lastTradedPrice'])
            t = TIME_TO_EXPIRY()  # TIME TO EXPIRY IN YEARS

            # oc_data_list = []
            oc_data_list_call = []
            oc_data_list_put = []

            for data in enriched_data_optionchain['data']:
                #     print()
                #     print(data)

                dResult = data['result']
                dToken = dResult['token']
                instrument_name = dResult['tradingSymbol']
                instrument_token = dToken
                timestamp = dResult['requestTime']
                last_trade_time = dResult['lastTradeTime']
                last_price = dResult['lastTradedPrice']
                last_quantity = dResult['lastTradedQuantity']
                buy_quantity = None
                sell_quantity = None
                volume = dResult['volume']
                average_price = None
                oi = None
                oi_day_high = None
                oi_day_low = None
                net_change = None
                lower_circuit_limit = dResult['lowerCircuit']
                upper_circuit_limit = dResult['upperCircuit']
                IV = None
                DELTA = None
                THETA = None
                GAMMA = None

                instrument_type = data['result']['tradingSymbol'][-6:-5]
                if (instrument_type == 'C'):
                    # calculate greeks using pyvollib
                    OPTION_strike = instrument_name[-5:]
                    OPTION_strike = int(OPTION_strike)
                    OPTION_LTP = float(last_price)
                    if (OPTION_LTP == 0):
                        OPTION_LTP = 0.05

                    NIFTY_SPOT_CALL_IV, NIFTY_SPOT_CALL_GREEKS = nify_get_greeks(OPTION_LTP, nifty_spot_p,
                                                                                 int(OPTION_strike), t, 'c')
                    NIFTY_SPOT_CALL_DELTA = NIFTY_SPOT_CALL_GREEKS['delta'][0] * 100
                    NIFTY_SPOT_PUT_IV = NIFTY_SPOT_CALL_IV * 100
                    NIFTY_SPOT_CALL_THETA = NIFTY_SPOT_CALL_GREEKS['theta'][0]
                    NIFTY_SPOT_CALL_GAMMA = NIFTY_SPOT_CALL_GREEKS['gamma'][0]

                    oc_data_list_call.append({
                        "integer_strike": OPTION_strike,
                        "instrument_name": dResult['tradingSymbol'],
                        "instrument_token": str(dToken),
                        "timestamp": dResult['requestTime'],
                        "last_trade_time": dResult['lastTradeTime'],
                        "last_price": dResult['lastTradedPrice'],
                        "last_quantity": dResult['lastTradedQuantity'],
                        "buy_quantity": None,
                        "sell_quantity": None,
                        "volume": dResult['volume'],
                        "average_price": None,
                        "oi": None,
                        "oi_day_high": None,
                        "oi_day_low": None,
                        "net_change": None,
                        "lower_circuit_limit": dResult['lowerCircuit'],
                        "upper_circuit_limit": dResult['upperCircuit'],
                        "IV": NIFTY_SPOT_CALL_IV,
                        "DELTA": NIFTY_SPOT_CALL_DELTA,
                        "THETA": NIFTY_SPOT_CALL_THETA,
                        "GAMMA": NIFTY_SPOT_CALL_GAMMA,
                    })
                elif (instrument_type == 'P'):
                    # calculate greeks using pyvollib
                    OPTION_strike = instrument_name[-5:]
                    OPTION_strike = int(OPTION_strike)
                    OPTION_LTP = float(last_price)
                    if (OPTION_LTP == 0):
                        OPTION_LTP = 0.05
                    NIFTY_SPOT_PUT_IV, NIFTY_SPOT_PUT_GREEKS = nify_get_greeks(OPTION_LTP, nifty_spot_p,
                                                                               int(OPTION_strike), t, 'p')
                    NIFTY_SPOT_PUT_DELTA = NIFTY_SPOT_PUT_GREEKS['delta'][0] * (-100)
                    NIFTY_SPOT_PUT_IV = NIFTY_SPOT_PUT_IV * 100
                    NIFTY_SPOT_PUT_THETA = NIFTY_SPOT_PUT_GREEKS['theta'][0]
                    NIFTY_SPOT_PUT_GAMMA = NIFTY_SPOT_PUT_GREEKS['gamma'][0]

                    oc_data_list_put.append({
                        "integer_strike": OPTION_strike,
                        "instrument_name": dResult['tradingSymbol'],
                        "instrument_token": str(dToken),
                        "timestamp": dResult['requestTime'],
                        "last_trade_time": dResult['lastTradeTime'],
                        "last_price": dResult['lastTradedPrice'],
                        "last_quantity": dResult['lastTradedQuantity'],
                        "buy_quantity": None,
                        "sell_quantity": None,
                        "volume": dResult['volume'],
                        "average_price": None,
                        "oi": None,
                        "oi_day_high": None,
                        "oi_day_low": None,
                        "net_change": None,
                        "lower_circuit_limit": dResult['lowerCircuit'],
                        "upper_circuit_limit": dResult['upperCircuit'],
                        "IV": NIFTY_SPOT_PUT_IV,
                        "DELTA": NIFTY_SPOT_PUT_DELTA,
                        "THETA": NIFTY_SPOT_PUT_THETA,
                        "GAMMA": NIFTY_SPOT_PUT_GAMMA,
                    })
            CALL_NIFTY_OPTION_CHAIN_df = pd.DataFrame(oc_data_list_call)
            CALL_NIFTY_OPTION_CHAIN_df.sort_values(by=['integer_strike'], inplace=True)
            #             CALL_NIFTY_OPTION_CHAIN_df.drop(['integer_strike'], axis = 1, inplace = True)
            CALL_NIFTY_OPTION_CHAIN_df.set_index('instrument_name', inplace=True)
            PUT_NIFTY_OPTION_CHAIN_df = pd.DataFrame(oc_data_list_put)
            PUT_NIFTY_OPTION_CHAIN_df.sort_values(by=['integer_strike'], inplace=True)
            #             PUT_NIFTY_OPTION_CHAIN_df.drop(['integer_strike'], axis = 1, inplace = True)
            PUT_NIFTY_OPTION_CHAIN_df.set_index('instrument_name', inplace=True)

            return CALL_NIFTY_OPTION_CHAIN_df, PUT_NIFTY_OPTION_CHAIN_df
        else:
            raise Exception(
                "Exception raised at Firststock_getMultiquote in function COMPLETE_NIFTY_WATCHLIST_FIRSTOCK()")
    else:
        raise Exception("Option Chain Function did not return desired option chain. Check immediately...")

    return pd.DataFrame(oc_data_list)


def COMPLETE_NIFTY_WATCHLIST():
    nifty_prefix = nifty_current_expiry_symbol()

    nifty_strike = nifty_ltp()
    # bank_nifty_strike=bank_nifty_ltp()

    strike_nifty = nifty_strike / 50
    mod = nifty_strike % 50

    # strike_bank_nifty=bank_nifty_strike/100
    # mod_bank_nifty=bank_nifty_strike%100

    if mod > 25:
        strike_nifty = (int(strike_nifty) + 1) * 50
    else:
        strike_nifty = (int(strike_nifty)) * 50

    # if mod_bank_nifty>61 :
    #     strike_bank_nifty= (int(strike_bank_nifty)+1)*100
    # else:
    #     strike_bank_nifty= (int(strike_bank_nifty))*100

    # print("NIFTY STRIKE IS: ", strike_nifty)
    # # print("BANK NIFTY STRIKE IS: ", strike_bank_nifty)
    # print("_______________________________________________________________________________________________")

    # sys_ce=nifty_prefix + str(strike_nifty) + "CE"
    # sys_pe=nifty_prefix + str(strike_nifty) + "PE"

    # sys_ce_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "CE"
    # sys_pe_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "PE"

    # NIFTY_OPTION_CHAIN_WATCHLIST=get_nifty_watchlist(strike_nifty,30,nifty_prefix)
    # BANK_NIFTY_OPTION_CHAIN_WATCHLIST=get_bank_nifty_watchlist(strike_bank_nifty,30,bank_nifty_prefix)

    # pprint(NIFTY_OPTION_CHAIN_WATCHLIST)

    # NIFTY_OPTION_CHAIN_DATA = get_quote(NIFTY_OPTION_CHAIN_WATCHLIST)
    # BANK_NIFTY_OPTION_CHAIN_DATA = get_quote(BANK_NIFTY_OPTION_CHAIN_WATCHLIST)

    NIFTY_OPTION_CHAIN_CALL_WATCHLIST = get_nifty_COP_watchlist(strike_nifty, 20, nifty_prefix, "CALL")
    NIFTY_OPTION_CHAIN_CALL_DATA = get_quote(NIFTY_OPTION_CHAIN_CALL_WATCHLIST)

    NIFTY_OPTION_CHAIN_PUT_WATCHLIST = get_nifty_COP_watchlist(strike_nifty, 20, nifty_prefix, "PUT")
    NIFTY_OPTION_CHAIN_PUT_DATA = get_quote(NIFTY_OPTION_CHAIN_PUT_WATCHLIST)
    # print(type(NIFTY_OPTION_CHAIN_PUT_DATA))
    # pprint(NIFTY_OPTION_CHAIN_PUT_DATA)
    # ppp.set_trace()

    CALL_NIFTY_OPTION_CHAIN_df = pd.DataFrame(NIFTY_OPTION_CHAIN_CALL_DATA).transpose()
    CALL_NIFTY_OPTION_CHAIN_df = CALL_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    CALL_NIFTY_OPTION_CHAIN_df['IV'] = [0] * CALL_NIFTY_OPTION_CHAIN_df[CALL_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_NIFTY_OPTION_CHAIN_df['DELTA'] = [0] * CALL_NIFTY_OPTION_CHAIN_df[
        CALL_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_NIFTY_OPTION_CHAIN_df['THETA'] = [0] * CALL_NIFTY_OPTION_CHAIN_df[
        CALL_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_NIFTY_OPTION_CHAIN_df['GAMMA'] = [0] * CALL_NIFTY_OPTION_CHAIN_df[
        CALL_NIFTY_OPTION_CHAIN_df.columns[0]].count()

    PUT_NIFTY_OPTION_CHAIN_df = pd.DataFrame(NIFTY_OPTION_CHAIN_PUT_DATA).transpose()
    PUT_NIFTY_OPTION_CHAIN_df = PUT_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    PUT_NIFTY_OPTION_CHAIN_df['IV'] = [0] * PUT_NIFTY_OPTION_CHAIN_df[PUT_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_NIFTY_OPTION_CHAIN_df['DELTA'] = [0] * PUT_NIFTY_OPTION_CHAIN_df[PUT_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_NIFTY_OPTION_CHAIN_df['THETA'] = [0] * PUT_NIFTY_OPTION_CHAIN_df[PUT_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_NIFTY_OPTION_CHAIN_df['GAMMA'] = [0] * PUT_NIFTY_OPTION_CHAIN_df[PUT_NIFTY_OPTION_CHAIN_df.columns[0]].count()

    # NIFTY_OPTION_CHAIN_df = pd.DataFrame(NIFTY_OPTION_CHAIN_DATA).transpose()
    # BANK_NIFTY_OPTION_CHAIN_df = pd.DataFrame(BANK_NIFTY_OPTION_CHAIN_DATA).transpose()

    # NIFTY_OPTION_CHAIN_df = NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc','depth'])
    # BANK_NIFTY_OPTION_CHAIN_df = BANK_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc'])
    nifty_spot_p = nifty_ltp()
    # bank_nifty_spot_p=bank_nifty_ltp()
    t = TIME_TO_EXPIRY()  # TIME TO EXPIRY IN YEARS
    # if(t==0):
    #     t=0.00001

    # pprint(PUT_NIFTY_OPTION_CHAIN_df)
    # print(",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,")

    for k, v in CALL_NIFTY_OPTION_CHAIN_df.iterrows():
        if (k == '260105' or k == '256265' or k == '257801'):
            print("ye ni krna")
            continue

        OPTION_strike = k[-7:]
        OPTION_strike = int(OPTION_strike[:5])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        NIFTY_SPOT_CALL_IV, NIFTY_SPOT_CALL_GREEKS = nify_get_greeks(OPTION_LTP, nifty_spot_p, int(OPTION_strike), t,
                                                                     'c')
        NIFTY_SPOT_CALL_DELTA = NIFTY_SPOT_CALL_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        NIFTY_SPOT_CALL_THETA = NIFTY_SPOT_CALL_GREEKS['theta'][0]
        NIFTY_SPOT_CALL_GAMMA = NIFTY_SPOT_CALL_GREEKS['gamma'][0]
        # print(type(NIFTY_SPOT_CALL_IV))
        # if(type(NIFTY_SPOT_CALL_IV)==INT):
        try:
            CALL_NIFTY_OPTION_CHAIN_df.at[k, 'IV'] = NIFTY_SPOT_CALL_IV * 100
            CALL_NIFTY_OPTION_CHAIN_df.at[k, 'DELTA'] = NIFTY_SPOT_CALL_DELTA * (100)
            CALL_NIFTY_OPTION_CHAIN_df.at[k, 'THETA'] = NIFTY_SPOT_CALL_THETA
            CALL_NIFTY_OPTION_CHAIN_df.at[k, 'GAMMA'] = NIFTY_SPOT_CALL_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    for k, v in PUT_NIFTY_OPTION_CHAIN_df.iterrows():
        if (k == '260105' or k == '256265' or k == '257801'):
            print("ye ni krna")
            continue

        OPTION_strike = k[-7:]
        OPTION_strike = int(OPTION_strike[:5])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        NIFTY_SPOT_PUT_IV, NIFTY_SPOT_PUT_GREEKS = nify_get_greeks(OPTION_LTP, nifty_spot_p, int(OPTION_strike), t, 'p')
        NIFTY_SPOT_PUT_DELTA = NIFTY_SPOT_PUT_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        NIFTY_SPOT_PUT_THETA = NIFTY_SPOT_PUT_GREEKS['theta'][0]
        NIFTY_SPOT_PUT_GAMMA = NIFTY_SPOT_PUT_GREEKS['gamma'][0]
        try:
            PUT_NIFTY_OPTION_CHAIN_df.at[k, 'IV'] = NIFTY_SPOT_PUT_IV * 100
            PUT_NIFTY_OPTION_CHAIN_df.at[k, 'DELTA'] = NIFTY_SPOT_PUT_DELTA * (-100)
            PUT_NIFTY_OPTION_CHAIN_df.at[k, 'THETA'] = NIFTY_SPOT_PUT_THETA
            PUT_NIFTY_OPTION_CHAIN_df.at[k, 'GAMMA'] = NIFTY_SPOT_PUT_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    return CALL_NIFTY_OPTION_CHAIN_df, PUT_NIFTY_OPTION_CHAIN_df


def COMPLETE_MIDCAP_NIFTY_WATCHLIST():
    midcap_nifty_prefix = midcap_nifty_current_expiry_symbol()

    midcap_nifty_strike = midcap_nifty_ltp()
    # bank_nifty_strike=bank_nifty_ltp()

    strike_midcap_nifty = midcap_nifty_strike / 50
    mod = midcap_nifty_strike % 50

    # strike_bank_nifty=bank_nifty_strike/100
    # mod_bank_nifty=bank_nifty_strike%100

    if mod > 25:
        strike_midcap_nifty = (int(strike_midcap_nifty) + 1) * 50
    else:
        strike_midcap_nifty = (int(strike_midcap_nifty)) * 50

    # ppp.set_trace()

    # if mod_bank_nifty>61 :
    #     strike_bank_nifty= (int(strike_bank_nifty)+1)*100
    # else:
    #     strike_bank_nifty= (int(strike_bank_nifty))*100

    # print("NIFTY STRIKE IS: ", strike_nifty)
    # # print("BANK NIFTY STRIKE IS: ", strike_bank_nifty)
    # print("_______________________________________________________________________________________________")

    # sys_ce=nifty_prefix + str(strike_nifty) + "CE"
    # sys_pe=nifty_prefix + str(strike_nifty) + "PE"

    # sys_ce_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "CE"
    # sys_pe_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "PE"

    # NIFTY_OPTION_CHAIN_WATCHLIST=get_nifty_watchlist(strike_nifty,30,nifty_prefix)
    # BANK_NIFTY_OPTION_CHAIN_WATCHLIST=get_bank_nifty_watchlist(strike_bank_nifty,30,bank_nifty_prefix)

    # pprint(NIFTY_OPTION_CHAIN_WATCHLIST)

    # NIFTY_OPTION_CHAIN_DATA = get_quote(NIFTY_OPTION_CHAIN_WATCHLIST)
    # BANK_NIFTY_OPTION_CHAIN_DATA = get_quote(BANK_NIFTY_OPTION_CHAIN_WATCHLIST)

    MIDCAP_NIFTY_OPTION_CHAIN_CALL_WATCHLIST = get_midcap_nifty_COP_watchlist(strike_midcap_nifty, 20,
                                                                              midcap_nifty_prefix, "CALL")
    MIDCAP_NIFTY_OPTION_CHAIN_CALL_DATA = get_quote(MIDCAP_NIFTY_OPTION_CHAIN_CALL_WATCHLIST)

    MIDCAP_NIFTY_OPTION_CHAIN_PUT_WATCHLIST = get_midcap_nifty_COP_watchlist(strike_midcap_nifty, 20,
                                                                             midcap_nifty_prefix, "PUT")
    MIDCAP_NIFTY_OPTION_CHAIN_PUT_DATA = get_quote(MIDCAP_NIFTY_OPTION_CHAIN_PUT_WATCHLIST)
    # print(type(NIFTY_OPTION_CHAIN_PUT_DATA))
    # pprint(NIFTY_OPTION_CHAIN_PUT_DATA)
    # ppp.set_trace()

    CALL_MIDCAP_NIFTY_OPTION_CHAIN_df = pd.DataFrame(MIDCAP_NIFTY_OPTION_CHAIN_CALL_DATA).transpose()
    CALL_MIDCAP_NIFTY_OPTION_CHAIN_df = CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    CALL_MIDCAP_NIFTY_OPTION_CHAIN_df['IV'] = [0] * CALL_MIDCAP_NIFTY_OPTION_CHAIN_df[
        CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_MIDCAP_NIFTY_OPTION_CHAIN_df['DELTA'] = [0] * CALL_MIDCAP_NIFTY_OPTION_CHAIN_df[
        CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_MIDCAP_NIFTY_OPTION_CHAIN_df['THETA'] = [0] * CALL_MIDCAP_NIFTY_OPTION_CHAIN_df[
        CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_MIDCAP_NIFTY_OPTION_CHAIN_df['GAMMA'] = [0] * CALL_MIDCAP_NIFTY_OPTION_CHAIN_df[
        CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.columns[0]].count()

    PUT_MIDCAP_NIFTY_OPTION_CHAIN_df = pd.DataFrame(MIDCAP_NIFTY_OPTION_CHAIN_PUT_DATA).transpose()
    PUT_MIDCAP_NIFTY_OPTION_CHAIN_df = PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    PUT_MIDCAP_NIFTY_OPTION_CHAIN_df['IV'] = [0] * PUT_MIDCAP_NIFTY_OPTION_CHAIN_df[
        PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_MIDCAP_NIFTY_OPTION_CHAIN_df['DELTA'] = [0] * PUT_MIDCAP_NIFTY_OPTION_CHAIN_df[
        PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_MIDCAP_NIFTY_OPTION_CHAIN_df['THETA'] = [0] * PUT_MIDCAP_NIFTY_OPTION_CHAIN_df[
        PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_MIDCAP_NIFTY_OPTION_CHAIN_df['GAMMA'] = [0] * PUT_MIDCAP_NIFTY_OPTION_CHAIN_df[
        PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.columns[0]].count()

    # NIFTY_OPTION_CHAIN_df = pd.DataFrame(NIFTY_OPTION_CHAIN_DATA).transpose()
    # BANK_NIFTY_OPTION_CHAIN_df = pd.DataFrame(BANK_NIFTY_OPTION_CHAIN_DATA).transpose()

    # NIFTY_OPTION_CHAIN_df = NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc','depth'])
    # BANK_NIFTY_OPTION_CHAIN_df = BANK_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc'])
    midcap_nifty_spot_p = midcap_nifty_ltp()
    # bank_nifty_spot_p=bank_nifty_ltp()
    t = MIDCAP_TIME_TO_EXPIRY()  # TIME TO EXPIRY IN YEARS
    # if(t==0):
    #     t=0.00001

    # pprint(PUT_NIFTY_OPTION_CHAIN_df)
    # print(",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,")

    for k, v in CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.iterrows():
        if (k == '260105' or k == '256265' or k == '257801' or k == '288009'):
            print("ye ni krna")
            continue

        OPTION_strike = k[-6:]
        OPTION_strike = int(OPTION_strike[:4])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        MIDCAP_NIFTY_SPOT_CALL_IV, MIDCAP_NIFTY_SPOT_CALL_GREEKS = midcap_nify_get_greeks(OPTION_LTP,
                                                                                          midcap_nifty_spot_p,
                                                                                          int(OPTION_strike), t, 'c')
        MIDCAP_NIFTY_SPOT_CALL_DELTA = MIDCAP_NIFTY_SPOT_CALL_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        MIDCAP_NIFTY_SPOT_CALL_THETA = MIDCAP_NIFTY_SPOT_CALL_GREEKS['theta'][0]
        MIDCAP_NIFTY_SPOT_CALL_GAMMA = MIDCAP_NIFTY_SPOT_CALL_GREEKS['gamma'][0]
        # print(type(NIFTY_SPOT_CALL_IV))
        # if(type(NIFTY_SPOT_CALL_IV)==INT):
        try:
            CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.at[k, 'IV'] = MIDCAP_NIFTY_SPOT_CALL_IV * 100
            CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.at[k, 'DELTA'] = MIDCAP_NIFTY_SPOT_CALL_DELTA * (100)
            CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.at[k, 'THETA'] = MIDCAP_NIFTY_SPOT_CALL_THETA
            CALL_MIDCAP_NIFTY_OPTION_CHAIN_df.at[k, 'GAMMA'] = MIDCAP_NIFTY_SPOT_CALL_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    for k, v in PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.iterrows():
        if (k == '260105' or k == '256265' or k == '257801'):
            print("ye ni krna")
            continue

        OPTION_strike = k[-6:]
        OPTION_strike = int(OPTION_strike[:4])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        MIDCAP_NIFTY_SPOT_PUT_IV, MIDCAP_NIFTY_SPOT_PUT_GREEKS = midcap_nify_get_greeks(OPTION_LTP, midcap_nifty_spot_p,
                                                                                        int(OPTION_strike), t, 'p')
        MIDCAP_NIFTY_SPOT_PUT_DELTA = MIDCAP_NIFTY_SPOT_PUT_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        MIDCAP_NIFTY_SPOT_PUT_THETA = MIDCAP_NIFTY_SPOT_PUT_GREEKS['theta'][0]
        MIDCAP_NIFTY_SPOT_PUT_GAMMA = MIDCAP_NIFTY_SPOT_PUT_GREEKS['gamma'][0]
        try:
            PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.at[k, 'IV'] = MIDCAP_NIFTY_SPOT_PUT_IV * 100
            PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.at[k, 'DELTA'] = MIDCAP_NIFTY_SPOT_PUT_DELTA * (-100)
            PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.at[k, 'THETA'] = MIDCAP_NIFTY_SPOT_PUT_THETA
            PUT_MIDCAP_NIFTY_OPTION_CHAIN_df.at[k, 'GAMMA'] = MIDCAP_NIFTY_SPOT_PUT_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    return CALL_MIDCAP_NIFTY_OPTION_CHAIN_df, PUT_MIDCAP_NIFTY_OPTION_CHAIN_df


def COMPLETE_SENSEX_WATCHLIST():
    sensex_prefix = sensex_current_expiry_symbol()

    sensex_strike = sensex_ltp()
    # bank_nifty_strike=bank_nifty_ltp()

    strike_sensex = sensex_strike / 100
    mod = sensex_strike % 100

    # strike_bank_nifty=bank_nifty_strike/100
    # mod_bank_nifty=bank_nifty_strike%100

    if mod > 50:
        strike_sensex = (int(strike_sensex) + 1) * 100
    else:
        strike_sensex = (int(strike_sensex)) * 100

    # ppp.set_trace()

    # if mod_bank_nifty>61 :
    #     strike_bank_nifty= (int(strike_bank_nifty)+1)*100
    # else:
    #     strike_bank_nifty= (int(strike_bank_nifty))*100

    # print("NIFTY STRIKE IS: ", strike_nifty)
    # # print("BANK NIFTY STRIKE IS: ", strike_bank_nifty)
    # print("_______________________________________________________________________________________________")

    # sys_ce=nifty_prefix + str(strike_nifty) + "CE"
    # sys_pe=nifty_prefix + str(strike_nifty) + "PE"

    # sys_ce_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "CE"
    # sys_pe_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "PE"

    # NIFTY_OPTION_CHAIN_WATCHLIST=get_nifty_watchlist(strike_nifty,30,nifty_prefix)
    # BANK_NIFTY_OPTION_CHAIN_WATCHLIST=get_bank_nifty_watchlist(strike_bank_nifty,30,bank_nifty_prefix)

    # pprint(NIFTY_OPTION_CHAIN_WATCHLIST)

    # NIFTY_OPTION_CHAIN_DATA = get_quote(NIFTY_OPTION_CHAIN_WATCHLIST)
    # BANK_NIFTY_OPTION_CHAIN_DATA = get_quote(BANK_NIFTY_OPTION_CHAIN_WATCHLIST)

    SENSEX_OPTION_CHAIN_CALL_WATCHLIST = get_sensex_COP_watchlist(strike_sensex, 20, sensex_prefix, "CALL")
    SENSEX_OPTION_CHAIN_CALL_DATA = get_quote(SENSEX_OPTION_CHAIN_CALL_WATCHLIST)

    SENSEX_OPTION_CHAIN_PUT_WATCHLIST = get_sensex_COP_watchlist(strike_sensex, 20, sensex_prefix, "PUT")
    SENSEX_OPTION_CHAIN_PUT_DATA = get_quote(SENSEX_OPTION_CHAIN_PUT_WATCHLIST)
    # print(type(NIFTY_OPTION_CHAIN_PUT_DATA))
    # pprint(NIFTY_OPTION_CHAIN_PUT_DATA)
    # ppp.set_trace()

    CALL_SENSEX_OPTION_CHAIN_df = pd.DataFrame(SENSEX_OPTION_CHAIN_CALL_DATA).transpose()
    # ppp.set_trace()
    CALL_SENSEX_OPTION_CHAIN_df = CALL_SENSEX_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    CALL_SENSEX_OPTION_CHAIN_df['IV'] = [0] * CALL_SENSEX_OPTION_CHAIN_df[
        CALL_SENSEX_OPTION_CHAIN_df.columns[0]].count()
    CALL_SENSEX_OPTION_CHAIN_df['DELTA'] = [0] * CALL_SENSEX_OPTION_CHAIN_df[
        CALL_SENSEX_OPTION_CHAIN_df.columns[0]].count()
    CALL_SENSEX_OPTION_CHAIN_df['THETA'] = [0] * CALL_SENSEX_OPTION_CHAIN_df[
        CALL_SENSEX_OPTION_CHAIN_df.columns[0]].count()
    CALL_SENSEX_OPTION_CHAIN_df['GAMMA'] = [0] * CALL_SENSEX_OPTION_CHAIN_df[
        CALL_SENSEX_OPTION_CHAIN_df.columns[0]].count()

    PUT_SENSEX_OPTION_CHAIN_df = pd.DataFrame(SENSEX_OPTION_CHAIN_PUT_DATA).transpose()
    PUT_SENSEX_OPTION_CHAIN_df = PUT_SENSEX_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    PUT_SENSEX_OPTION_CHAIN_df['IV'] = [0] * PUT_SENSEX_OPTION_CHAIN_df[PUT_SENSEX_OPTION_CHAIN_df.columns[0]].count()
    PUT_SENSEX_OPTION_CHAIN_df['DELTA'] = [0] * PUT_SENSEX_OPTION_CHAIN_df[
        PUT_SENSEX_OPTION_CHAIN_df.columns[0]].count()
    PUT_SENSEX_OPTION_CHAIN_df['THETA'] = [0] * PUT_SENSEX_OPTION_CHAIN_df[
        PUT_SENSEX_OPTION_CHAIN_df.columns[0]].count()
    PUT_SENSEX_OPTION_CHAIN_df['GAMMA'] = [0] * PUT_SENSEX_OPTION_CHAIN_df[
        PUT_SENSEX_OPTION_CHAIN_df.columns[0]].count()

    # NIFTY_OPTION_CHAIN_df = pd.DataFrame(NIFTY_OPTION_CHAIN_DATA).transpose()
    # BANK_NIFTY_OPTION_CHAIN_df = pd.DataFrame(BANK_NIFTY_OPTION_CHAIN_DATA).transpose()

    # NIFTY_OPTION_CHAIN_df = NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc','depth'])
    # BANK_NIFTY_OPTION_CHAIN_df = BANK_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc'])
    sensex_spot_p = sensex_ltp()
    # bank_nifty_spot_p=bank_nifty_ltp()
    t = SENSEX_TIME_TO_EXPIRY()  # TIME TO EXPIRY IN YEARS
    # if(t==0):
    #     t=0.00001

    # pprint(PUT_NIFTY_OPTION_CHAIN_df)
    # print(",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,")

    for k, v in CALL_SENSEX_OPTION_CHAIN_df.iterrows():
        if (k == '260105' or k == '256265' or k == '257801' or k == '288009' or k == '265'):
            print("ye ni krna")
            continue

        OPTION_strike = k[-7:]
        OPTION_strike = int(OPTION_strike[:5])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        SENSEX_SPOT_CALL_IV, SENSEX_SPOT_CALL_GREEKS = sensex_get_greeks(OPTION_LTP, sensex_spot_p, int(OPTION_strike),
                                                                         t, 'c')
        SENSEX_SPOT_CALL_DELTA = SENSEX_SPOT_CALL_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        SENSEX_SPOT_CALL_THETA = SENSEX_SPOT_CALL_GREEKS['theta'][0]
        SENSEX_SPOT_CALL_GAMMA = SENSEX_SPOT_CALL_GREEKS['gamma'][0]
        # print(type(NIFTY_SPOT_CALL_IV))
        # if(type(NIFTY_SPOT_CALL_IV)==INT):
        try:
            CALL_SENSEX_OPTION_CHAIN_df.at[k, 'IV'] = SENSEX_SPOT_CALL_IV * 100
            CALL_SENSEX_OPTION_CHAIN_df.at[k, 'DELTA'] = SENSEX_SPOT_CALL_DELTA * (100)
            CALL_SENSEX_OPTION_CHAIN_df.at[k, 'THETA'] = SENSEX_SPOT_CALL_THETA
            CALL_SENSEX_OPTION_CHAIN_df.at[k, 'GAMMA'] = SENSEX_SPOT_CALL_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    for k, v in PUT_SENSEX_OPTION_CHAIN_df.iterrows():
        if (k == '260105' or k == '256265' or k == '257801' or k == '265'):
            print("ye ni krna")
            continue

        OPTION_strike = k[-7:]
        OPTION_strike = int(OPTION_strike[:5])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        SENSEX_SPOT_PUT_IV, SENSEX_SPOT_PUT_GREEKS = sensex_get_greeks(OPTION_LTP, sensex_spot_p, int(OPTION_strike), t,
                                                                       'p')
        SENSEX_SPOT_PUT_DELTA = SENSEX_SPOT_PUT_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        SENSEX_SPOT_PUT_THETA = SENSEX_SPOT_PUT_GREEKS['theta'][0]
        SENSEX_SPOT_PUT_GAMMA = SENSEX_SPOT_PUT_GREEKS['gamma'][0]
        try:
            PUT_SENSEX_OPTION_CHAIN_df.at[k, 'IV'] = SENSEX_SPOT_PUT_IV * 100
            PUT_SENSEX_OPTION_CHAIN_df.at[k, 'DELTA'] = SENSEX_SPOT_PUT_DELTA * (-100)
            PUT_SENSEX_OPTION_CHAIN_df.at[k, 'THETA'] = SENSEX_SPOT_PUT_THETA
            PUT_SENSEX_OPTION_CHAIN_df.at[k, 'GAMMA'] = SENSEX_SPOT_PUT_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    return CALL_SENSEX_OPTION_CHAIN_df, PUT_SENSEX_OPTION_CHAIN_df


def COMPLETE_FIN_NIFTY_WATCHLIST():
    fin_nifty_prefix = fin_nifty_current_expiry_symbol()

    fin_nifty_strike = fin_nifty_ltp()
    # bank_nifty_strike=bank_nifty_ltp()

    strike_fin_nifty = fin_nifty_strike / 50
    mod = fin_nifty_strike % 50

    # strike_bank_nifty=bank_nifty_strike/100
    # mod_bank_nifty=bank_nifty_strike%100

    if mod > 25:
        strike_fin_nifty = (int(strike_fin_nifty) + 1) * 50
    else:
        strike_fin_nifty = (int(strike_fin_nifty)) * 50

    FIN_NIFTY_OPTION_CHAIN_CALL_WATCHLIST = get_fin_nifty_COP_watchlist(strike_fin_nifty, 20, fin_nifty_prefix, "CALL")
    FIN_NIFTY_OPTION_CHAIN_CALL_DATA = get_quote(FIN_NIFTY_OPTION_CHAIN_CALL_WATCHLIST)

    FIN_NIFTY_OPTION_CHAIN_PUT_WATCHLIST = get_fin_nifty_COP_watchlist(strike_fin_nifty, 20, fin_nifty_prefix, "PUT")
    FIN_NIFTY_OPTION_CHAIN_PUT_DATA = get_quote(FIN_NIFTY_OPTION_CHAIN_PUT_WATCHLIST)
    # print(type(NIFTY_OPTION_CHAIN_PUT_DATA))
    # pprint(NIFTY_OPTION_CHAIN_PUT_DATA)
    # ppp.set_trace()

    CALL_FIN_NIFTY_OPTION_CHAIN_df = pd.DataFrame(FIN_NIFTY_OPTION_CHAIN_CALL_DATA).transpose()
    CALL_FIN_NIFTY_OPTION_CHAIN_df = CALL_FIN_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    CALL_FIN_NIFTY_OPTION_CHAIN_df['IV'] = [0] * CALL_FIN_NIFTY_OPTION_CHAIN_df[
        CALL_FIN_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_FIN_NIFTY_OPTION_CHAIN_df['DELTA'] = [0] * CALL_FIN_NIFTY_OPTION_CHAIN_df[
        CALL_FIN_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_FIN_NIFTY_OPTION_CHAIN_df['THETA'] = [0] * CALL_FIN_NIFTY_OPTION_CHAIN_df[
        CALL_FIN_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_FIN_NIFTY_OPTION_CHAIN_df['GAMMA'] = [0] * CALL_FIN_NIFTY_OPTION_CHAIN_df[
        CALL_FIN_NIFTY_OPTION_CHAIN_df.columns[0]].count()

    PUT_FIN_NIFTY_OPTION_CHAIN_df = pd.DataFrame(FIN_NIFTY_OPTION_CHAIN_PUT_DATA).transpose()
    PUT_FIN_NIFTY_OPTION_CHAIN_df = PUT_FIN_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    PUT_FIN_NIFTY_OPTION_CHAIN_df['IV'] = [0] * PUT_FIN_NIFTY_OPTION_CHAIN_df[
        PUT_FIN_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_FIN_NIFTY_OPTION_CHAIN_df['DELTA'] = [0] * PUT_FIN_NIFTY_OPTION_CHAIN_df[
        PUT_FIN_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_FIN_NIFTY_OPTION_CHAIN_df['THETA'] = [0] * PUT_FIN_NIFTY_OPTION_CHAIN_df[
        PUT_FIN_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_FIN_NIFTY_OPTION_CHAIN_df['GAMMA'] = [0] * PUT_FIN_NIFTY_OPTION_CHAIN_df[
        PUT_FIN_NIFTY_OPTION_CHAIN_df.columns[0]].count()

    # NIFTY_OPTION_CHAIN_df = pd.DataFrame(NIFTY_OPTION_CHAIN_DATA).transpose()
    # BANK_NIFTY_OPTION_CHAIN_df = pd.DataFrame(BANK_NIFTY_OPTION_CHAIN_DATA).transpose()

    # NIFTY_OPTION_CHAIN_df = NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc','depth'])
    # BANK_NIFTY_OPTION_CHAIN_df = BANK_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc'])
    fin_nifty_spot_p = fin_nifty_ltp()
    # bank_nifty_spot_p=bank_nifty_ltp()
    t = FIN_TIME_TO_EXPIRY()  # TIME TO EXPIRY IN YEARS
    # if(t==0):
    #     t=0.00001

    # pprint(PUT_NIFTY_OPTION_CHAIN_df)
    # print(",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,")

    for k, v in CALL_FIN_NIFTY_OPTION_CHAIN_df.iterrows():
        if k == '260105' or k == '256265' or k == '257801':
            print("ye ni krna")
            continue

        OPTION_strike = k[-7:]
        OPTION_strike = int(OPTION_strike[:5])
        OPTION_LTP = v['last_price']
        if OPTION_LTP == 0:
            OPTION_LTP = 0.05

        FIN_NIFTY_SPOT_CALL_IV, FIN_NIFTY_SPOT_CALL_GREEKS = fin_nify_get_greeks(OPTION_LTP, fin_nifty_spot_p,
                                                                                 int(OPTION_strike), t, 'c')
        FIN_NIFTY_SPOT_CALL_DELTA = FIN_NIFTY_SPOT_CALL_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        FIN_NIFTY_SPOT_CALL_THETA = FIN_NIFTY_SPOT_CALL_GREEKS['theta'][0]
        FIN_NIFTY_SPOT_CALL_GAMMA = FIN_NIFTY_SPOT_CALL_GREEKS['gamma'][0]
        # print(type(NIFTY_SPOT_CALL_IV))
        # if(type(NIFTY_SPOT_CALL_IV)==INT):
        try:
            CALL_FIN_NIFTY_OPTION_CHAIN_df.at[k, 'IV'] = FIN_NIFTY_SPOT_CALL_IV * 100
            CALL_FIN_NIFTY_OPTION_CHAIN_df.at[k, 'DELTA'] = FIN_NIFTY_SPOT_CALL_DELTA * (100)
            CALL_FIN_NIFTY_OPTION_CHAIN_df.at[k, 'THETA'] = FIN_NIFTY_SPOT_CALL_THETA
            CALL_FIN_NIFTY_OPTION_CHAIN_df.at[k, 'GAMMA'] = FIN_NIFTY_SPOT_CALL_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    for k, v in PUT_FIN_NIFTY_OPTION_CHAIN_df.iterrows():
        if k == '260105' or k == '256265' or k == '257801':
            print("ye ni krna")
            continue

        OPTION_strike = k[-7:]
        OPTION_strike = int(OPTION_strike[:5])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        FIN_NIFTY_SPOT_PUT_IV, FIN_NIFTY_SPOT_PUT_GREEKS = fin_nify_get_greeks(OPTION_LTP, fin_nifty_spot_p,
                                                                               int(OPTION_strike), t, 'p')
        FIN_NIFTY_SPOT_PUT_DELTA = FIN_NIFTY_SPOT_PUT_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        FIN_NIFTY_SPOT_PUT_THETA = FIN_NIFTY_SPOT_PUT_GREEKS['theta'][0]
        FIN_NIFTY_SPOT_PUT_GAMMA = FIN_NIFTY_SPOT_PUT_GREEKS['gamma'][0]
        try:
            PUT_FIN_NIFTY_OPTION_CHAIN_df.at[k, 'IV'] = FIN_NIFTY_SPOT_PUT_IV * 100
            PUT_FIN_NIFTY_OPTION_CHAIN_df.at[k, 'DELTA'] = FIN_NIFTY_SPOT_PUT_DELTA * (-100)
            PUT_FIN_NIFTY_OPTION_CHAIN_df.at[k, 'THETA'] = FIN_NIFTY_SPOT_PUT_THETA
            PUT_FIN_NIFTY_OPTION_CHAIN_df.at[k, 'GAMMA'] = FIN_NIFTY_SPOT_PUT_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    return CALL_FIN_NIFTY_OPTION_CHAIN_df, PUT_FIN_NIFTY_OPTION_CHAIN_df


def COMPLETE_BANK_NIFTY_WATCHLIST(expiry_name="banknifty"):
    # bank_nifty_prefix = bank_nifty_current_expiry_symbol()
    bank_nifty_prefix = get_current_expiry_symbol_prefix(expiry_name)
    bank_nifty_strike = bank_nifty_ltp()
    # bank_nifty_strike=bank_nifty_ltp()

    strike_bank_nifty = bank_nifty_strike / 100
    mod = bank_nifty_strike % 100

    # strike_bank_nifty=bank_nifty_strike/100
    # mod_bank_nifty=bank_nifty_strike%100

    if mod > 50:
        strike_bank_nifty = (int(strike_bank_nifty) + 1) * 100
    else:
        strike_bank_nifty = (int(strike_bank_nifty)) * 100

    # if mod_bank_nifty>61 :
    #     strike_bank_nifty= (int(strike_bank_nifty)+1)*100
    # else:
    #     strike_bank_nifty= (int(strike_bank_nifty))*100

    # print("NIFTY STRIKE IS: ", strike_nifty)
    # # print("BANK NIFTY STRIKE IS: ", strike_bank_nifty)
    # print("_______________________________________________________________________________________________")

    # sys_ce=nifty_prefix + str(strike_nifty) + "CE"
    # sys_pe=nifty_prefix + str(strike_nifty) + "PE"

    # sys_ce_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "CE"
    # sys_pe_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "PE"

    # NIFTY_OPTION_CHAIN_WATCHLIST=get_nifty_watchlist(strike_nifty,30,nifty_prefix)
    # BANK_NIFTY_OPTION_CHAIN_WATCHLIST=get_bank_nifty_watchlist(strike_bank_nifty,30,bank_nifty_prefix)

    # pprint(NIFTY_OPTION_CHAIN_WATCHLIST)

    # NIFTY_OPTION_CHAIN_DATA = get_quote(NIFTY_OPTION_CHAIN_WATCHLIST)
    # BANK_NIFTY_OPTION_CHAIN_DATA = get_quote(BANK_NIFTY_OPTION_CHAIN_WATCHLIST)

    BANK_NIFTY_OPTION_CHAIN_CALL_WATCHLIST = get_bank_nifty_COP_watchlist(strike_bank_nifty, 30, bank_nifty_prefix,
                                                                          "CALL")
    BANK_NIFTY_OPTION_CHAIN_CALL_DATA = get_quote(BANK_NIFTY_OPTION_CHAIN_CALL_WATCHLIST)

    BANK_NIFTY_OPTION_CHAIN_PUT_WATCHLIST = get_bank_nifty_COP_watchlist(strike_bank_nifty, 30, bank_nifty_prefix,
                                                                         "PUT")
    BANK_NIFTY_OPTION_CHAIN_PUT_DATA = get_quote(BANK_NIFTY_OPTION_CHAIN_PUT_WATCHLIST)
    # print(type(NIFTY_OPTION_CHAIN_PUT_DATA))
    # pprint(NIFTY_OPTION_CHAIN_PUT_DATA)
    # ppp.set_trace()

    CALL_BANK_NIFTY_OPTION_CHAIN_df = pd.DataFrame(BANK_NIFTY_OPTION_CHAIN_CALL_DATA).transpose()
    CALL_BANK_NIFTY_OPTION_CHAIN_df = CALL_BANK_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    CALL_BANK_NIFTY_OPTION_CHAIN_df['IV'] = [0] * CALL_BANK_NIFTY_OPTION_CHAIN_df[
        CALL_BANK_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_BANK_NIFTY_OPTION_CHAIN_df['DELTA'] = [0] * CALL_BANK_NIFTY_OPTION_CHAIN_df[
        CALL_BANK_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_BANK_NIFTY_OPTION_CHAIN_df['THETA'] = [0] * CALL_BANK_NIFTY_OPTION_CHAIN_df[
        CALL_BANK_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    CALL_BANK_NIFTY_OPTION_CHAIN_df['GAMMA'] = [0] * CALL_BANK_NIFTY_OPTION_CHAIN_df[
        CALL_BANK_NIFTY_OPTION_CHAIN_df.columns[0]].count()

    PUT_BANK_NIFTY_OPTION_CHAIN_df = pd.DataFrame(BANK_NIFTY_OPTION_CHAIN_PUT_DATA).transpose()
    PUT_BANK_NIFTY_OPTION_CHAIN_df = PUT_BANK_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc', 'depth'])
    PUT_BANK_NIFTY_OPTION_CHAIN_df['IV'] = [0] * PUT_BANK_NIFTY_OPTION_CHAIN_df[
        PUT_BANK_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_BANK_NIFTY_OPTION_CHAIN_df['DELTA'] = [0] * PUT_BANK_NIFTY_OPTION_CHAIN_df[
        PUT_BANK_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_BANK_NIFTY_OPTION_CHAIN_df['THETA'] = [0] * PUT_BANK_NIFTY_OPTION_CHAIN_df[
        PUT_BANK_NIFTY_OPTION_CHAIN_df.columns[0]].count()
    PUT_BANK_NIFTY_OPTION_CHAIN_df['GAMMA'] = [0] * PUT_BANK_NIFTY_OPTION_CHAIN_df[
        PUT_BANK_NIFTY_OPTION_CHAIN_df.columns[0]].count()

    # NIFTY_OPTION_CHAIN_df = pd.DataFrame(NIFTY_OPTION_CHAIN_DATA).transpose()
    # BANK_NIFTY_OPTION_CHAIN_df = pd.DataFrame(BANK_NIFTY_OPTION_CHAIN_DATA).transpose()

    # NIFTY_OPTION_CHAIN_df = NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc','depth'])
    # BANK_NIFTY_OPTION_CHAIN_df = BANK_NIFTY_OPTION_CHAIN_df.drop(columns=['ohlc'])
    bank_nifty_spot_p = bank_nifty_ltp()
    # bank_nifty_spot_p=bank_nifty_ltp()
    t = TIME_TO_EXPIRY()  # TIME TO EXPIRY IN YEARS
    # if(t==0):
    #     t=0.00001

    # pprint(PUT_NIFTY_OPTION_CHAIN_df)
    # print(",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,")

    for k, v in CALL_BANK_NIFTY_OPTION_CHAIN_df.iterrows():
        if (k == '260105' or k == '256265' or k == '257801'):
            print("ye ni krna")
            continue

        OPTION_strike = k[-7:]
        OPTION_strike = int(OPTION_strike[:5])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        BANK_NIFTY_SPOT_CALL_IV, BANK_NIFTY_SPOT_CALL_GREEKS = bank_nify_get_greeks(OPTION_LTP, bank_nifty_spot_p,
                                                                                    int(OPTION_strike), t, 'c')
        BANK_NIFTY_SPOT_CALL_DELTA = BANK_NIFTY_SPOT_CALL_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        BANK_NIFTY_SPOT_CALL_THETA = BANK_NIFTY_SPOT_CALL_GREEKS['theta'][0]
        BANK_NIFTY_SPOT_CALL_GAMMA = BANK_NIFTY_SPOT_CALL_GREEKS['gamma'][0]
        # print(type(NIFTY_SPOT_CALL_IV))
        # if(type(NIFTY_SPOT_CALL_IV)==INT):
        try:
            CALL_BANK_NIFTY_OPTION_CHAIN_df.at[k, 'IV'] = BANK_NIFTY_SPOT_CALL_IV * 100
            CALL_BANK_NIFTY_OPTION_CHAIN_df.at[k, 'DELTA'] = BANK_NIFTY_SPOT_CALL_DELTA * (100)
            CALL_BANK_NIFTY_OPTION_CHAIN_df.at[k, 'THETA'] = BANK_NIFTY_SPOT_CALL_THETA
            CALL_BANK_NIFTY_OPTION_CHAIN_df.at[k, 'GAMMA'] = BANK_NIFTY_SPOT_CALL_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    for k, v in PUT_BANK_NIFTY_OPTION_CHAIN_df.iterrows():
        if (k == '260105' or k == '256265' or k == '257801'):
            print("ye ni krna")
            continue

        OPTION_strike = k[-7:]
        OPTION_strike = int(OPTION_strike[:5])
        OPTION_LTP = v['last_price']
        if (OPTION_LTP == 0):
            OPTION_LTP = 0.05

        BANK_NIFTY_SPOT_PUT_IV, BANK_NIFTY_SPOT_PUT_GREEKS = bank_nify_get_greeks(OPTION_LTP, bank_nifty_spot_p,
                                                                                  int(OPTION_strike), t, 'p')
        BANK_NIFTY_SPOT_PUT_DELTA = BANK_NIFTY_SPOT_PUT_GREEKS['delta'][0]
        # NIFTY_SPOT_PUT_IV=NIFTY_SPOT_PUT_GREEKS['iv'][0]
        BANK_NIFTY_SPOT_PUT_THETA = BANK_NIFTY_SPOT_PUT_GREEKS['theta'][0]
        BANK_NIFTY_SPOT_PUT_GAMMA = BANK_NIFTY_SPOT_PUT_GREEKS['gamma'][0]
        try:
            PUT_BANK_NIFTY_OPTION_CHAIN_df.at[k, 'IV'] = BANK_NIFTY_SPOT_PUT_IV * 100
            PUT_BANK_NIFTY_OPTION_CHAIN_df.at[k, 'DELTA'] = BANK_NIFTY_SPOT_PUT_DELTA * (-100)
            PUT_BANK_NIFTY_OPTION_CHAIN_df.at[k, 'THETA'] = BANK_NIFTY_SPOT_PUT_THETA
            PUT_BANK_NIFTY_OPTION_CHAIN_df.at[k, 'GAMMA'] = BANK_NIFTY_SPOT_PUT_GAMMA
        except Exception as e:
            A = 1
            # print("error in strike for put: ",OPTION_strike)
            # print(e)

    return CALL_BANK_NIFTY_OPTION_CHAIN_df, PUT_BANK_NIFTY_OPTION_CHAIN_df


# input: Array : [putsymbol, callsymbol] where callsymbol = nifty_strike_to_symbol(int(delta_15_call), 'CALL')
# input : Producttype = "NRML" or "INTR"
# output = margin for one lot of putsymbol and callsymbol
def get_margin_for_positions(order_symbol_list, producttype, expiry_type):
    order_list = []
    num_of_orders = len(order_symbol_list)
    lot_size = 0
    symbol_prefix = "NFO"
    if expiry_type == "nifty":
        lot_size = 50
    elif expiry_type == "banknifty":
        lot_size = 15
    elif expiry_type == "sensex":
        lot_size = 10
        symbol_prefix = "BFO"  # For sensex, exchange symbol differs
    elif expiry_type == 'finnifty':
        lot_size = 40

    for i in range(num_of_orders):
        order = {
            "exchange": symbol_prefix,
            "tradingsymbol": order_symbol_list[i][0],
            "transaction_type": order_symbol_list[i][1],
            "variety": "regular",
            "product": producttype,
            "order_type": "MARKET",
            "quantity": lot_size,
            "price": 0,
            "trigger_price": 0
        }
        order_list.append(order)
    # print(order_list)

    one_lot_margin = kite.basket_order_margins(order_list, consider_positions=True, mode=None)['final']['total']
    logging.info("Margin for one lot is %s", str(one_lot_margin))
    return one_lot_margin


def calculate_quantity_and_margin_for_position_firstock(investment_amount, order_symbol_list, available_margin_to_use,
                                                        producttype,
                                                        expiry_type, getQuantity=False, getMargin=False):
    """

        :param investment_amount: INTEGER / FLOAT
        :param order_symbol_list: [[putsymbol_firstock, "S"], [callsymbol_firstock, "S"]] Ex : [["NIFTY24AUG23P19000", "S"],["NIFTY24AUG23C19000", "S"]]
        :param available_margin_to_use: 0, 0.1, 0.2 -- 1 (Percentage of margin to use / 100)
        :param producttype: "NRML" or "MIS"
        :param expiry_type: "nifty", "banknifty", "sensex", "midcap", "finnifty"
        :return: Quantity sell (strangle / straddle) for given capital
        """
    total_margin = investment_amount
    usable_margin = available_margin_to_use * total_margin

    logging.info("Total available Margin %s but we will use max  %s ", str(total_margin), str(usable_margin))
    order_list = []
    symbol_prefix = "NFO"
    num_of_orders = len(order_symbol_list)
    lot_size = 0
    if expiry_type == "nifty":
        lot_size = 50
    elif expiry_type == "banknifty":
        lot_size = 15
    elif expiry_type == 'finnifty':
        lot_size = 40
    elif expiry_type == 'sensex':
        lot_size = 10
        symbol_prefix = 'BFO'
    elif expiry_type == 'midcap:':
        lot_size = 75

    for i in range(num_of_orders):
        order = {
            "exchange": symbol_prefix,
            "tradingSymbol": order_symbol_list[i][0],
            "quantity": str(lot_size),
            "transactionType": order_symbol_list[i][1],
            "price": "0",
            "product": "M",
            "priceType": "LMT"
        }
        order_list.append(order)
    try:
        one_lot_margin = thefirstock.firstock_BasketMargin(basket=order_list)['data']['marginused']
    except Exception as e:
        time.sleep(0.5)
        one_lot_margin = thefirstock.firstock_BasketMargin(basket=order_list)['data']['marginused']

    # logging.info("Margin for one lot is %s", str(one_lot_margin))

    num_of_lots = int(int(usable_margin) / float(one_lot_margin))
    quantity_to_be_deployed = num_of_lots * lot_size
    # logging.info("Quantity is %s", str(quantity_to_be_deployed))

    if getMargin == False and getQuantity == False:
        return None
    elif getMargin == True and getQuantity == False:
        return one_lot_margin
    elif getMargin == False and getQuantity == True:
        return quantity_to_be_deployed
    else:
        return float(one_lot_margin), quantity_to_be_deployed


def calculate_quantity_for_defined_capital(investment_amount, order_symbol_list, available_margin_to_use, producttype,
                                           expiry_type):
    """

        :param investment_amount: INTEGER / FLOAT
        :param order_symbol_list: [[putsymbol, "SELL"], [callsymbol, "SELL"]] Ex : [["NIFTY2382419400PE", "SELL"],["NIFTY2382419400CE", "SELL"]]
        :param available_margin_to_use: 0, 0.1, 0.2 -- 1 (Percentage of margin to use / 100)
        :param producttype: "NRML" or "MIS"
        :param expiry_type: "nifty", "banknifty", "sensex", "midcap", "finnifty"
        :return: Quantity sell (strangle / straddle) for given capital
        """

    total_margin = investment_amount
    usable_margin = available_margin_to_use * total_margin

    logging.info("Total available Margin %s but we will use max  %s ", str(total_margin), str(usable_margin))
    order_list = []
    symbol_prefix = "NFO"
    num_of_orders = len(order_symbol_list)
    lot_size = 0
    if expiry_type == "nifty":
        lot_size = 50
    elif expiry_type == "banknifty":
        lot_size = 15
    elif expiry_type == 'finnifty':
        lot_size = 40
    elif expiry_type == 'sensex':
        lot_size = 10
        symbol_prefix = 'BFO'
    elif expiry_type == 'midcap:':
        lot_size = 75

    for i in range(num_of_orders):
        order = {
            "exchange": symbol_prefix,
            "tradingsymbol": order_symbol_list[i][0],
            "transaction_type": order_symbol_list[i][1],
            "variety": "regular",
            "product": producttype,
            "order_type": "MARKET",
            "quantity": lot_size,
            "price": 0,
            "trigger_price": 0
        }
        order_list.append(order)

    one_lot_margin = kite.basket_order_margins(order_list, consider_positions=True, mode=None)['final']['total']
    logging.info("Margin for one lot is %s", str(one_lot_margin))

    num_of_lots = int(usable_margin / one_lot_margin)
    quantity_to_be_deployed = num_of_lots * lot_size
    logging.info("Quantity is %s", str(quantity_to_be_deployed))

    return quantity_to_be_deployed


#
# def calculate_quantity_for_defined_capital_nifty(investment_amount, order_symbol_list, available_margin_to_use,
#                                                  producttype):
#     total_margin = investment_amount
#     usable_margin = available_margin_to_use * total_margin
#
#     logging.info("Total available Margin %s but we will use max  %s ", str(total_margin), str(usable_margin))
#     order_list = []
#
#     num_of_orders = len(order_symbol_list)
#
#     for i in range(num_of_orders):
#         order = {
#             "exchange": "NFO",
#             "tradingsymbol": order_symbol_list[i][0],
#             "transaction_type": order_symbol_list[i][1],
#             "variety": "regular",
#             "product": producttype,
#             "order_type": "MARKET",
#             "quantity": 50,
#             "price": 0,
#             "trigger_price": 0
#         }
#         order_list.append(order)
#
#     one_lot_margin = kite.basket_order_margins(order_list, consider_positions=True, mode=None)['final']['total']
#     logging.info("Margin for one lot is %s", str(one_lot_margin))
#
#     num_of_lots = int(usable_margin / one_lot_margin)
#     quantity_to_be_deployed = num_of_lots * 50
#     logging.info("Quantity is %s", str(quantity_to_be_deployed))
#
#     return quantity_to_be_deployed


def calculate_quantity(order_symbol_list, available_margin_to_use, producttype):
    total_margin = kite.margins(segment=None)['equity']['net']
    usable_margin = available_margin_to_use * total_margin

    logging.info("Total available Margin %s but we will use max  %s ", str(total_margin), str(usable_margin))
    order_list = []

    num_of_orders = len(order_symbol_list)

    for i in range(num_of_orders):
        order = {
            "exchange": "NFO",
            "tradingsymbol": order_symbol_list[i][0],
            "transaction_type": order_symbol_list[i][1],
            "variety": "regular",
            "product": producttype,
            "order_type": "MARKET",
            "quantity": 50,
            "price": 0,
            "trigger_price": 0
        }
        order_list.append(order)

    one_lot_margin = kite.basket_order_margins(order_list, consider_positions=True, mode=None)['final']['total']
    logging.info("Margin for one lot is %s", str(one_lot_margin))

    num_of_lots = int(usable_margin / one_lot_margin)
    quantity_to_be_deployed = num_of_lots * 50
    logging.info("Quantity is %s", str(quantity_to_be_deployed))

    return quantity_to_be_deployed


def monitor_banknifty_strangle_with_delta(producttype, day_premium, adjustment_level, filename,
                                          DeRiskPoints, StopLossPoints, expiry_end_code, adjustment_leg_matching_factor,
                                          max_initial_put_to_call_ratio, min_initial_put_to_call_ratio,
                                          call_delta_to_sell_at_open, put_delta_to_sell_at_open, delta_code):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    # DeRiskPoints= 20 # day_premium*2
    # StopLossPoints = DeRiskPoints+5

    sl_hit = 0
    callsymbol = ""
    putsymbol = ""
    # adjustment_level = 1.75
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        logging.info("Nothing to Monitor...Returning!!!")
        return

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                logging.info("Call symbol is %s Quantity is %s", callsymbol, quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = quantity
                logging.info("Put symbol is %s Quantity is %s", putsymbol, quantity)

    logging.info(symbol_dict)
    quantity = abs(callquantity)

    if (callsymbol == "" and putsymbol == ""):
        logging.info("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return round(pnl, 1)
    elif (callsymbol == ""):
        logging.info("No Active Call symbol found...Looks like some problem...Exiting all positions")
        exit_banknifty_strangle(producttype, filename)
        return round(pnl, 1)
    elif (putsymbol == ""):
        logging.info("No Active Put symbol found...Looks like some problem...Exiting all positions")
        exit_banknifty_strangle(producttype, filename)
        return round(pnl, 1)

    symbols = [callsymbol, putsymbol]
    symbols_ltp = last_price(symbols)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    logging.info("Call price is %s", callprice)
    logging.info("Put price is %s", putprice)

    ############################################ YAHA SE DELTA LOGIC KICKS IN ##############################

    ############## WE NEED TO ALWAYS CALCULATE PUT/CALL AND SEE IF IT EXCEEDS MIN OR MAX #################

    if (callprice > putprice):
        higher_price = callprice
        higher_symbol = callsymbol
        lower_price = putprice
        lower_symbol = putsymbol
    else:
        higher_price = putprice
        higher_symbol = putsymbol
        lower_price = callprice
        lower_symbol = callsymbol

    # logging.info("Current Ratio of both legs is %s", round(higher_price / lower_price, 2))
    logging.info("Current PUT/CALL Ratio of both legs is %s", round(putprice / callprice, 2))

    put_to_call_ratio = round(putprice / callprice, 2)
    # print("Max Loss points is ", MaxLossPoints)

    sl_count = 0
    for i in range(num_orders - 1, 0, -1):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (processed_order_data[i][txn_type_index] == 'SLL' and (symbol == callsymbol or symbol == putsymbol)):
            # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            sl_count += 1
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            logging.info("SLL order status is - %s", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                logging.info("Stop loss hit at average price %s", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                stop_loss_symbol = symbol
                sl_hit = 1
                break
            elif (sl_count == 2):
                logging.info("Sl not hit yet")
                break
    if (sl_hit == 1):
        # Update the file
        # Cancel the other SL order - Done
        # Exit the active leg - Done
        # Place new orders- Done

        if (stop_loss_symbol == callsymbol):
            logging.info("Call leg cut by SL, cancelling PUT SL and cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=producttype)
            # time.sleep(2)

            logging.info("Updating File - Replacing SLL with BUY")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()

            putprice_buy = fetch_order(putorderid_buy)['average_price']

            if (putprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    putprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        elif (stop_loss_symbol == putsymbol):
            logging.info("Put leg cut by SL, cancelling CALL SLand cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                            product=producttype)
            # time.sleep(2)
            logging.info("Updating File")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()
            callprice_buy = fetch_order(callorderid_buy)['average_price']

            if (callprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    callprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        logging.info("Starting both positions afresh now")

        if delta_code == 1:

            call_delta_to_sell = call_delta_to_sell_at_open
            put_delta_to_sell = put_delta_to_sell_at_open

            bank_nifty_strike = bank_nifty_ltp()

            strike_bank_nifty = bank_nifty_strike / 100
            mod_bank_nifty = bank_nifty_strike % 100

            if mod_bank_nifty > 51:
                strike_bank_nifty = (int(strike_bank_nifty) + 1) * 100
            else:
                strike_bank_nifty = (int(strike_bank_nifty)) * 100

            print("___________________________________________________________________________________")

            print("BANK NIFTY STRIKE IS: ", strike_bank_nifty)
            print("_______________________________________________________________________________________________")

            CALL_BANK_NIFTY_OPTION_CHAIN_df, PUT_BANK_NIFTY_OPTION_CHAIN_df = COMPLETE_BANK_NIFTY_WATCHLIST()

            BANK_delta_15_call, BANK_delta_15_call_LTP = bank_nifty_n_delta_strike(call_delta_to_sell,
                                                                                   CALL_BANK_NIFTY_OPTION_CHAIN_df, "c")

            BANK_delta_15_put, BANK_delta_15_put_LTP = bank_nifty_n_delta_strike(put_delta_to_sell,
                                                                                 PUT_BANK_NIFTY_OPTION_CHAIN_df, "p")

            banknifty_cur_price = weekly_banknifty_future()
            banknifty_atm_strike = int(banknifty_cur_price - (banknifty_cur_price % 100))

            put_strike_new = BANK_delta_15_put
            call_strike_new = BANK_delta_15_call
            putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

        else:
            banknifty_cur_price = weekly_banknifty_future()
            banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)
            put_strike_new = banknifty_atm_strike
            call_strike_new = banknifty_atm_strike

            while (True):

                putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
                callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

                symbols = [callsymbol_new, putsymbol_new]
                symbols_ltp = last_price(symbols)
                callprice_new = symbols_ltp[0]
                putprice_new = symbols_ltp[1]

                if (callprice_new > day_premium):
                    call_strike_new += 100
                if (putprice_new > day_premium):
                    put_strike_new -= 100

                if (callprice_new < day_premium and putprice_new < day_premium):
                    break

        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None,
                                       trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None,
                                        trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity,
                                       price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        if putstrike_price_new > 0:
            f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
                putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &s order did not get executed....Some problem ...check ", putsymbol_new)

        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        if callstrike_price_new > 0:
            f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
                callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &sorder did not get executed....Some problem ...check ", callsymbol_new)

        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        f.close()
    elif ((higher_price > day_premium + DeRiskPoints) or expiry_end_code == 1):
        logging.info("Cutting both positions and de-risking")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()
        putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime2 = datetime.datetime.now()
        callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        logging.info("Starting both positions afresh now")

        if delta_code == 1:

            call_delta_to_sell = call_delta_to_sell_at_open
            put_delta_to_sell = put_delta_to_sell_at_open

            bank_nifty_strike = bank_nifty_ltp()

            strike_bank_nifty = bank_nifty_strike / 100
            mod_bank_nifty = bank_nifty_strike % 100

            if mod_bank_nifty > 51:
                strike_bank_nifty = (int(strike_bank_nifty) + 1) * 100
            else:
                strike_bank_nifty = (int(strike_bank_nifty)) * 100

            print("___________________________________________________________________________________")

            print("BANK NIFTY STRIKE IS: ", strike_bank_nifty)
            print("_______________________________________________________________________________________________")

            CALL_BANK_NIFTY_OPTION_CHAIN_df, PUT_BANK_NIFTY_OPTION_CHAIN_df = COMPLETE_BANK_NIFTY_WATCHLIST()

            BANK_delta_15_call, BANK_delta_15_call_LTP = bank_nifty_n_delta_strike(call_delta_to_sell,
                                                                                   CALL_BANK_NIFTY_OPTION_CHAIN_df, "c")

            BANK_delta_15_put, BANK_delta_15_put_LTP = bank_nifty_n_delta_strike(put_delta_to_sell,
                                                                                 PUT_BANK_NIFTY_OPTION_CHAIN_df, "p")

            banknifty_cur_price = weekly_banknifty_future()
            banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)

            put_strike_new = BANK_delta_15_put

            call_strike_new = BANK_delta_15_call
            putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

        else:
            banknifty_cur_price = weekly_banknifty_future()
            banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)
            put_strike_new = banknifty_atm_strike
            call_strike_new = banknifty_atm_strike

            while (True):

                putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
                callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

                symbols = [callsymbol_new, putsymbol_new]
                symbols_ltp = last_price(symbols)
                callprice_new = symbols_ltp[0]
                putprice_new = symbols_ltp[1]

                if (callprice_new > day_premium):
                    call_strike_new += 100
                if (putprice_new > day_premium):
                    put_strike_new -= 100

                if (callprice_new < day_premium and putprice_new < day_premium):
                    break

        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None, trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putprice_buy = fetch_order(putorderid_buy)['average_price']
        callprice_buy = fetch_order(callorderid_buy)['average_price']

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
            putprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
            callprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()
        if (expiry_end_code == 1):
            time.sleep(60)
            expiry_end_code = 0
    elif (delta_code == 0 and higher_price / lower_price >= adjustment_level and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = banknifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * adjustment_leg_matching_factor):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return round(pnl, 1)
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return round(pnl, 1)

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = banknifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice * adjustment_leg_matching_factor):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return round(pnl, 1)

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return round(pnl, 1)

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()
    elif (delta_code == 1 and (
            put_to_call_ratio >= max_initial_put_to_call_ratio or put_to_call_ratio <= min_initial_put_to_call_ratio) and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = banknifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * adjustment_leg_matching_factor):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return round(pnl, 1)
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return round(pnl, 1)

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = banknifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice * adjustment_leg_matching_factor):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return round(pnl, 1)

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return round(pnl, 1)

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

    else:
        if (delta_code == 0 and higher_price <= 4 and higher_price / lower_price >= adjustment_level):
            logging.info("Premiums too low, adjustment not required")
        elif (delta_code == 1 and higher_price <= 4 and (
                put_to_call_ratio < max_initial_put_to_call_ratio and put_to_call_ratio > min_initial_put_to_call_ratio)):
            logging.info("Premiums too low, adjustment not required")

        else:
            logging.info("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return round(pnl, 1)


def monitor_nifty_strangle_with_delta_moving_strangle(producttype, day_premium, adjustment_level, filename,
                                                      DeRiskPoints, StopLossPoints, expiry_end_code,
                                                      adjustment_leg_matching_factor, max_initial_put_to_call_ratio,
                                                      min_initial_put_to_call_ratio, call_delta_to_sell_at_open,
                                                      put_delta_to_sell_at_open, delta_code, initial_pcr):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    # DeRiskPoints= 20 # day_premium*2
    # StopLossPoints = DeRiskPoints+5
    global has_moving_strangle_started

    sl_hit = 0
    callsymbol = ""
    putsymbol = ""
    # adjustment_level = 1.75
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        logging.info("Nothing to Monitor...Returning!!!")
        return 0, 0, 0, 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                logging.info("Call symbol is %s Quantity is %s", callsymbol, quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = quantity
                logging.info("Put symbol is %s Quantity is %s", putsymbol, quantity)

    logging.info(symbol_dict)
    quantity = abs(callquantity)

    if (callsymbol == "" and putsymbol == ""):
        logging.info("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return 0, round(pnl, 1), 0, 0
    elif (callsymbol == ""):
        logging.info("No Active Call symbol found...Looks like some problem...Exiting all positions")
        exit_nifty_strangle(producttype, filename)
        return 0, round(pnl, 1), 0, 0
    elif (putsymbol == ""):
        logging.info("No Active Put symbol found...Looks like some problem...Exiting all positions")
        exit_nifty_strangle(producttype, filename)
        return 0, round(pnl, 1), 0, 0

    symbols = [callsymbol, putsymbol]
    callstrike = nifty_symbol_to_strike(callsymbol)
    putstrike = nifty_symbol_to_strike(putsymbol)
    symbols_ltp = last_price(symbols)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    logging.info("Call price is %s", callprice)
    logging.info("Put price is %s", putprice)

    ############################################ YAHA SE DELTA LOGIC KICKS IN ##############################

    ############## WE NEED TO ALWAYS CALCULATE PUT/CALL AND SEE IF IT EXCEEDS MIN OR MAX #################

    if (callprice > putprice):
        higher_price = callprice
        higher_symbol = callsymbol
        lower_price = putprice
        lower_symbol = putsymbol
    else:
        higher_price = putprice
        higher_symbol = putsymbol
        lower_price = callprice
        lower_symbol = callsymbol

    # logging.info("Current Ratio of both legs is %s", round(higher_price / lower_price, 2))
    logging.info("Current PUT/CALL Ratio of both legs is %s", round(putprice / callprice, 2))

    put_to_call_ratio = round(putprice / callprice, 2)
    # print("Max Loss points is ", MaxLossPoints)

    sl_count = 0
    for i in range(num_orders - 1, 0, -1):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (processed_order_data[i][txn_type_index] == 'SLL' and (symbol == callsymbol or symbol == putsymbol)):
            # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            sl_count += 1
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            logging.info("SLL order status is - %s", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                logging.info("Stop loss hit at average price %s", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                stop_loss_symbol = symbol
                sl_hit = 1
                break
            elif (sl_count == 2):
                logging.info("Sl not hit yet")
                break
    if (sl_hit == 1):
        # Update the file
        # Cancel the other SL order - Done
        # Exit the active leg - Done
        # Place new orders- Done

        if (stop_loss_symbol == callsymbol):
            logging.info("Call leg cut by SL, cancelling PUT SL and cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=producttype)
            # time.sleep(2)

            logging.info("Updating File - Replacing SLL with BUY")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()

            putprice_buy = fetch_order(putorderid_buy)['average_price']

            if (putprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    putprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        elif (stop_loss_symbol == putsymbol):
            logging.info("Put leg cut by SL, cancelling CALL SLand cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                            product=producttype)
            # time.sleep(2)
            logging.info("Updating File")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()
            callprice_buy = fetch_order(callorderid_buy)['average_price']

            if (callprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    callprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        logging.info("Starting both positions afresh now")

        if delta_code == 1:

            call_delta_to_sell = call_delta_to_sell_at_open
            put_delta_to_sell = put_delta_to_sell_at_open

            nifty_strike = weekly_nifty_future()
            strike_nifty = nifty_strike / 100
            mod_nifty = nifty_strike % 100

            if mod_nifty > 51:
                strike_nifty = (int(strike_nifty) + 1) * 100
            else:
                strike_nifty = (int(strike_nifty)) * 100

            print("___________________________________________________________________________________")

            print(" NIFTY STRIKE IS: ", strike_nifty)
            print("_______________________________________________________________________________________________")

            CALL_NIFTY_OPTION_CHAIN_df, PUT_NIFTY_OPTION_CHAIN_df = COMPLETE_NIFTY_WATCHLIST()

            delta_15_call, delta_15_call_LTP = nifty_n_delta_strike_with_ltp(call_delta_to_sell,
                                                                             CALL_NIFTY_OPTION_CHAIN_df, "c")

            delta_15_put, delta_15_put_LTP = nifty_n_delta_strike_with_ltp(put_delta_to_sell, PUT_NIFTY_OPTION_CHAIN_df,
                                                                           "p")

            nifty_cur_price = weekly_nifty_future()
            nifty_atm_strike = int(nifty_cur_price - nifty_cur_price % 100)

            put_strike_new = delta_15_put
            call_strike_new = delta_15_call
            putsymbol_new = nifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = nifty_strike_to_symbol(call_strike_new, "CALL")

        else:
            nifty_cur_price = weekly_nifty_future()
            nifty_atm_strike = int(nifty_cur_price - nifty_cur_price % 100)
            put_strike_new = nifty_atm_strike
            call_strike_new = nifty_atm_strike

            while (True):

                putsymbol_new = nifty_strike_to_symbol(put_strike_new, "PUT")
                callsymbol_new = nifty_strike_to_symbol(call_strike_new, "CALL")

                symbols = [callsymbol_new, putsymbol_new]
                symbols_ltp = last_price(symbols)
                callprice_new = symbols_ltp[0]
                putprice_new = symbols_ltp[1]

                if (callprice_new > day_premium):
                    call_strike_new += 100
                if (putprice_new > day_premium):
                    put_strike_new -= 100

                if (callprice_new < day_premium and putprice_new < day_premium):
                    break

        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None,
                                       trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None,
                                        trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity,
                                       price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        if putstrike_price_new > 0:
            f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
                putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &s order did not get executed....Some problem ...check ", putsymbol_new)

        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        if callstrike_price_new > 0:
            f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
                callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &sorder did not get executed....Some problem ...check ", callsymbol_new)

        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        f.close()

    elif ((higher_price > day_premium + DeRiskPoints) or expiry_end_code == 1):

        new_put_strike = 0
        new_call_strike = 0
        # new_put_strike=0
        # new_put_strike=0

        if (callprice == higher_price):
            print("xyz")
            # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts and calls Up")
            nifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            nifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            new_put_strike = putstrike + 100
            new_call_strike = callstrike + 100
            new_putsymbol = nifty_strike_to_symbol(new_put_strike, "PUT")
            new_callsymbol = nifty_strike_to_symbol(new_call_strike, "CALL")
        else:
            print("xyz")
            # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts and calls down")
            nifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            nifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            new_put_strike = putstrike - 100
            new_call_strike = callstrike - 100
            new_putsymbol = nifty_strike_to_symbol(new_put_strike, "PUT")
            new_callsymbol = nifty_strike_to_symbol(new_call_strike, "CALL")

        new_putprice = last_price(new_putsymbol)
        new_callprice = last_price(new_callsymbol)

        # logging.info("Cutting both positions and de-risking")
        logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()

        put_sl_trig_price = new_putprice * 2
        call_sl_trig_price = new_callprice * 2

        put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
        #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        # f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
        #     callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()

        # CALCULATE THE DIFF OF CURR CALL AND PUT FROM ATM TO FIX IT ON MOVING STRANGLE

        nifty_strike = weekly_nifty_future()

        strike_nifty = nifty_strike / 100
        mod_nifty = nifty_strike % 100

        if mod_nifty > 51:
            strike_nifty = (int(strike_nifty) + 1) * 100
        else:
            strike_nifty = (int(strike_nifty)) * 100

        logging.info("___________________________________________________________________________________")

        logging.info(" NIFTY STRIKE IS: " + str(strike_nifty))

        logging.info("_______________________________________________________________________________________________")

        # CALL_NIFTY_OPTION_CHAIN_df,PUT_NIFTY_OPTION_CHAIN_df=COMPLETE_NIFTY_WATCHLIST()

        # delta_15_call,delta_15_call_LTP=nifty_n_delta_strike_with_ltp(call_delta_to_sell_at_open,CALL_NIFTY_OPTION_CHAIN_df,"c")

        # delta_15_put,delta_15_put_LTP=nifty_n_delta_strike_with_ltp(put_delta_to_sell_at_open,PUT_NIFTY_OPTION_CHAIN_df,"p")

        put_strike = nifty_symbol_to_strike(new_putsymbol)
        call_strike = nifty_symbol_to_strike(new_callsymbol)

        nifty_cur_price = nifty_strike

        call_diff = call_strike - nifty_cur_price
        put_diff = nifty_cur_price - put_strike

        return 1, round(pnl, 1), call_diff, put_diff

        if (curday == 3):  # Expiry Day - Thursday
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100
            # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
            # elif(cur_hour==12 or cur_hour==13 ):
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
            # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
        elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
            # call_max_range = 400
            # call_min_range =300
            # put_max_range = 450
            # put_min_range = 350
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
            # call_max_range = 400
            # call_min_range =300
            # put_max_range = 400
            # put_min_range = 300
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
            # call_max_range = 350
            # call_min_range =250
            # put_max_range = 400
            # put_min_range = 300
            # call_max_range =555
            # call_min_range =450
            # put_max_range =605
            # put_min_range = 500

            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
            # call_max_range = 500
            # call_min_range =400
            # put_max_range = 550
            # put_min_range = 450

            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        else:  # saturday and sunday for testing Start with a delta neutral 250/300 point strangle
            call_max_range = 500
            call_min_range = 400
            put_max_range = 550
            put_min_range = 450

        has_moving_strangle_started = 1

        nifty_cur_price = weekly_nifty_future()
        print(" Nifty CUrrent Price is - ", nifty_cur_price, "\n")
        if (callsymbol == "" and putsymbol == ""):
            print("Found No Positions to Monitor...Exiting!!")
            return 0, round(pnl, 1), 0, 0
        else:
            callstrike = nifty_symbol_to_strike(callsymbol)
            putstrike = nifty_symbol_to_strike(putsymbol)

            put_diff = nifty_cur_price - putstrike
            call_diff = callstrike - nifty_cur_price

            if (call_diff > call_max_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Down")
                nifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            elif (call_diff < call_min_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Up")
                nifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            else:
                print("Call Strike Diff is ", int(call_diff), "Nothing to do right now !!")
                print("Will Move Calls Up At ", callstrike - call_min_range)
                print("Will Move Calls Down At ", callstrike - call_max_range)

            if (put_diff > put_max_range):

                print("Put Strike Diff is ", int(put_diff), "Moving Puts Up")
                nifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            elif (put_diff < put_min_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Down")
                nifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            else:
                print("Put Strike Diff is ", int(put_diff), "Nothing to do right now !!")
                print("Will Move Puts Up At ", putstrike + put_max_range)
                print("Will Move Puts Down At ", putstrike + put_min_range)

        if (expiry_end_code == 1):
            time.sleep(60)
            expiry_end_code = 0





    elif (delta_code == 0 and higher_price / lower_price >= adjustment_level and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = nifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * adjustment_leg_matching_factor):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_nifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = nifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice * adjustment_leg_matching_factor):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_nifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()
    elif (delta_code == 1 and (
            put_to_call_ratio >= max_initial_put_to_call_ratio or put_to_call_ratio <= min_initial_put_to_call_ratio) and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = nifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * initial_pcr):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_nifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = nifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice / initial_pcr):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_nifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

    else:
        if (delta_code == 0 and higher_price <= 4 and higher_price / lower_price >= adjustment_level):
            logging.info("Premiums too low, adjustment not required")
        elif (delta_code == 1 and higher_price <= 4 and (
                put_to_call_ratio < max_initial_put_to_call_ratio and put_to_call_ratio > min_initial_put_to_call_ratio)):
            logging.info("Premiums too low, adjustment not required")

        else:
            logging.info("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return 0, round(pnl, 1), 0, 0


def monitor_banknifty_strangle_with_delta_moving_strangle(producttype, day_premium, adjustment_level, filename,
                                                          DeRiskPoints, StopLossPoints, expiry_end_code,
                                                          adjustment_leg_matching_factor, max_initial_put_to_call_ratio,
                                                          min_initial_put_to_call_ratio, call_delta_to_sell_at_open,
                                                          put_delta_to_sell_at_open, delta_code, initial_pcr):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index

    # DeRiskPoints= 20 # day_premium*2
    # StopLossPoints = DeRiskPoints+5
    global has_moving_strangle_started

    sl_hit = 0
    callsymbol = ""
    putsymbol = ""
    # adjustment_level = 1.75
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        logging.info("Nothing to Monitor...Returning!!!")
        return 0, 0, 0, 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                logging.info("Call symbol is %s Quantity is %s", callsymbol, quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = quantity
                logging.info("Put symbol is %s Quantity is %s", putsymbol, quantity)

    logging.info(symbol_dict)
    quantity = abs(callquantity)

    if (callsymbol == "" and putsymbol == ""):
        logging.info("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return 0, round(pnl, 1), 0, 0
    elif (callsymbol == ""):
        logging.info("No Active Call symbol found...Looks like some problem...Exiting all positions")
        exit_banknifty_strangle(producttype, filename)
        return 0, round(pnl, 1), 0, 0
    elif (putsymbol == ""):
        logging.info("No Active Put symbol found...Looks like some problem...Exiting all positions")
        exit_banknifty_strangle(producttype, filename)
        return 0, round(pnl, 1), 0, 0

    symbols = [callsymbol, putsymbol]
    callstrike = banknifty_symbol_to_strike(callsymbol)
    putstrike = banknifty_symbol_to_strike(putsymbol)
    symbols_ltp = last_price(symbols)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    logging.info("Call price is %s", callprice)
    logging.info("Put price is %s", putprice)

    ############################################ YAHA SE DELTA LOGIC KICKS IN ##############################

    ############## WE NEED TO ALWAYS CALCULATE PUT/CALL AND SEE IF IT EXCEEDS MIN OR MAX #################

    if (callprice > putprice):
        higher_price = callprice
        higher_symbol = callsymbol
        lower_price = putprice
        lower_symbol = putsymbol
    else:
        higher_price = putprice
        higher_symbol = putsymbol
        lower_price = callprice
        lower_symbol = callsymbol

    # logging.info("Current Ratio of both legs is %s", round(higher_price / lower_price, 2))
    logging.info("Current PUT/CALL Ratio of both legs is %s", round(putprice / callprice, 2))

    put_to_call_ratio = round(putprice / callprice, 2)
    # print("Max Loss points is ", MaxLossPoints)

    sl_count = 0
    for i in range(num_orders - 1, 0, -1):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (processed_order_data[i][txn_type_index] == 'SLL' and (symbol == callsymbol or symbol == putsymbol)):
            # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            sl_count += 1
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            logging.info("SLL order status is - %s", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                logging.info("Stop loss hit at average price %s", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                stop_loss_symbol = symbol
                sl_hit = 1
                break
            elif (sl_count == 2):
                logging.info("Sl not hit yet")
                break
    if (sl_hit == 1):
        # Update the file
        # Cancel the other SL order - Done
        # Exit the active leg - Done
        # Place new orders- Done

        if (stop_loss_symbol == callsymbol):
            logging.info("Call leg cut by SL, cancelling PUT SL and cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=producttype)
            # time.sleep(2)

            logging.info("Updating File - Replacing SLL with BUY")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()

            putprice_buy = fetch_order(putorderid_buy)['average_price']

            if (putprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    putprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        elif (stop_loss_symbol == putsymbol):
            logging.info("Put leg cut by SL, cancelling CALL SLand cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                            product=producttype)
            # time.sleep(2)
            logging.info("Updating File")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()
            callprice_buy = fetch_order(callorderid_buy)['average_price']

            if (callprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    callprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        logging.info("Starting both positions afresh now")

        if delta_code == 1:

            call_delta_to_sell = call_delta_to_sell_at_open
            put_delta_to_sell = put_delta_to_sell_at_open

            bank_nifty_strike = weekly_banknifty_future()
            strike_bank_nifty = bank_nifty_strike / 100
            mod_bank_nifty = bank_nifty_strike % 100

            if mod_bank_nifty > 51:
                strike_bank_nifty = (int(strike_bank_nifty) + 1) * 100
            else:
                strike_bank_nifty = (int(strike_bank_nifty)) * 100

            print("___________________________________________________________________________________")

            print("BANK NIFTY STRIKE IS: ", strike_bank_nifty)
            print("_______________________________________________________________________________________________")

            CALL_BANK_NIFTY_OPTION_CHAIN_df, PUT_BANK_NIFTY_OPTION_CHAIN_df = COMPLETE_BANK_NIFTY_WATCHLIST()

            BANK_delta_15_call, BANK_delta_15_call_LTP = bank_nifty_n_delta_strike(call_delta_to_sell,
                                                                                   CALL_BANK_NIFTY_OPTION_CHAIN_df, "c")

            BANK_delta_15_put, BANK_delta_15_put_LTP = bank_nifty_n_delta_strike(put_delta_to_sell,
                                                                                 PUT_BANK_NIFTY_OPTION_CHAIN_df, "p")

            banknifty_cur_price = weekly_banknifty_future()
            banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)

            put_strike_new = BANK_delta_15_put
            call_strike_new = BANK_delta_15_call
            putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

        else:
            banknifty_cur_price = weekly_banknifty_future()
            banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)
            put_strike_new = banknifty_atm_strike
            call_strike_new = banknifty_atm_strike

            while (True):

                putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
                callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

                symbols = [callsymbol_new, putsymbol_new]
                symbols_ltp = last_price(symbols)
                callprice_new = symbols_ltp[0]
                putprice_new = symbols_ltp[1]

                if (callprice_new > day_premium):
                    call_strike_new += 100
                if (putprice_new > day_premium):
                    put_strike_new -= 100

                if (callprice_new < day_premium and putprice_new < day_premium):
                    break

        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None,
                                       trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None,
                                        trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity,
                                       price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        if putstrike_price_new > 0:
            f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
                putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &s order did not get executed....Some problem ...check ", putsymbol_new)

        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        if callstrike_price_new > 0:
            f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
                callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &sorder did not get executed....Some problem ...check ", callsymbol_new)

        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        f.close()

    elif ((higher_price > day_premium + DeRiskPoints) or expiry_end_code == 1):

        new_put_strike = 0
        new_call_strike = 0
        # new_put_strike=0
        # new_put_strike=0

        if (callprice == higher_price):
            print("xyz")
            # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts and calls Up")
            banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            banknifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            new_put_strike = putstrike + 100
            new_call_strike = callstrike + 100
            new_putsymbol = banknifty_strike_to_symbol(new_put_strike, "PUT")
            new_callsymbol = banknifty_strike_to_symbol(new_call_strike, "CALL")
        else:
            print("xyz")
            # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts and calls down")
            banknifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            banknifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            new_put_strike = putstrike - 100
            new_call_strike = callstrike - 100
            new_putsymbol = banknifty_strike_to_symbol(new_put_strike, "PUT")
            new_callsymbol = banknifty_strike_to_symbol(new_call_strike, "CALL")

        new_putprice = last_price(new_putsymbol)
        new_callprice = last_price(new_callsymbol)

        # logging.info("Cutting both positions and de-risking")
        logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()

        put_sl_trig_price = new_putprice * 2
        call_sl_trig_price = new_callprice * 2

        put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
        #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        # f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
        #     callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()

        # CALCULATE THE DIFF OF CURR CALL AND PUT FROM ATM TO FIX IT ON MOVING STRANGLE

        bank_nifty_strike = weekly_banknifty_future()

        strike_bank_nifty = bank_nifty_strike / 100
        mod_bank_nifty = bank_nifty_strike % 100

        if mod_bank_nifty > 51:
            strike_bank_nifty = (int(strike_bank_nifty) + 1) * 100
        else:
            strike_bank_nifty = (int(strike_bank_nifty)) * 100

        logging.info("___________________________________________________________________________________")

        logging.info("BANK NIFTY STRIKE IS: " + str(strike_bank_nifty))

        logging.info("_______________________________________________________________________________________________")

        # CALL_BANK_NIFTY_OPTION_CHAIN_df,PUT_BANK_NIFTY_OPTION_CHAIN_df=COMPLETE_BANK_NIFTY_WATCHLIST()

        # BANK_delta_15_call,BANK_delta_15_call_LTP=bank_nifty_n_delta_strike(call_delta_to_sell_at_open,CALL_BANK_NIFTY_OPTION_CHAIN_df,"c")

        # BANK_delta_15_put,BANK_delta_15_put_LTP=bank_nifty_n_delta_strike(put_delta_to_sell_at_open,PUT_BANK_NIFTY_OPTION_CHAIN_df,"p")

        put_strike = banknifty_symbol_to_strike(new_putsymbol)
        call_strike = banknifty_symbol_to_strike(new_callsymbol)

        banknifty_cur_price = bank_nifty_strike

        call_diff = call_strike - banknifty_cur_price
        put_diff = banknifty_cur_price - put_strike

        return 1, round(pnl, 1), call_diff, put_diff

        if (curday == 3):  # Expiry Day - Thursday
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100
            # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
            # elif(cur_hour==12 or cur_hour==13 ):
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
            # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
        elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
            # call_max_range = 400
            # call_min_range =300
            # put_max_range = 450
            # put_min_range = 350
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
            # call_max_range = 400
            # call_min_range =300
            # put_max_range = 400
            # put_min_range = 300
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
            # call_max_range = 350
            # call_min_range =250
            # put_max_range = 400
            # put_min_range = 300
            # call_max_range =555
            # call_min_range =450
            # put_max_range =605
            # put_min_range = 500

            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
            # call_max_range = 500
            # call_min_range =400
            # put_max_range = 550
            # put_min_range = 450

            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        else:  # saturday and sunday for testing Start with a delta neutral 250/300 point strangle
            call_max_range = 500
            call_min_range = 400
            put_max_range = 550
            put_min_range = 450

        has_moving_strangle_started = 1

        banknifty_cur_price = weekly_banknifty_future()
        print("Bank Nifty CUrrent Price is - ", banknifty_cur_price, "\n")
        if (callsymbol == "" and putsymbol == ""):
            print("Found No Positions to Monitor...Exiting!!")
            return 0, round(pnl, 1), 0, 0
        else:
            callstrike = banknifty_symbol_to_strike(callsymbol)
            putstrike = banknifty_symbol_to_strike(putsymbol)

            put_diff = banknifty_cur_price - putstrike
            call_diff = callstrike - banknifty_cur_price

            if (call_diff > call_max_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Down")
                banknifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            elif (call_diff < call_min_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Up")
                banknifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            else:
                print("Call Strike Diff is ", int(call_diff), "Nothing to do right now !!")
                print("Will Move Calls Up At ", callstrike - call_min_range)
                print("Will Move Calls Down At ", callstrike - call_max_range)

            if (put_diff > put_max_range):

                print("Put Strike Diff is ", int(put_diff), "Moving Puts Up")
                banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            elif (put_diff < put_min_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Down")
                banknifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            else:
                print("Put Strike Diff is ", int(put_diff), "Nothing to do right now !!")
                print("Will Move Puts Up At ", putstrike + put_max_range)
                print("Will Move Puts Down At ", putstrike + put_min_range)

        if (expiry_end_code == 1):
            time.sleep(60)
            expiry_end_code = 0





    elif (delta_code == 0 and higher_price / lower_price >= adjustment_level and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = banknifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * adjustment_leg_matching_factor):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = banknifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice * adjustment_leg_matching_factor):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()
    elif (delta_code == 1 and (
            put_to_call_ratio >= max_initial_put_to_call_ratio or put_to_call_ratio <= min_initial_put_to_call_ratio) and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = banknifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * initial_pcr):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = banknifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice / initial_pcr):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

    else:
        if (delta_code == 0 and higher_price <= 4 and higher_price / lower_price >= adjustment_level):
            logging.info("Premiums too low, adjustment not required")
        elif (delta_code == 1 and higher_price <= 4 and (
                put_to_call_ratio < max_initial_put_to_call_ratio and put_to_call_ratio > min_initial_put_to_call_ratio)):
            logging.info("Premiums too low, adjustment not required")

        else:
            logging.info("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return 0, round(pnl, 1), 0, 0


def monitor_nifty_strangle_with_moving_strangle(producttype, day_premium, adjustment_level, filename,
                                                DeRiskPoints, StopLossPoints, expiry_end_code,
                                                adjustment_leg_matching_factor):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index
    global has_moving_strangle_started

    # if has_moving_strangle_started!=1:
    #     has_moving_strangle_started=0

    # has_moving_strangle_started=0

    # DeRiskPoints= 20 # day_premium*2
    # StopLossPoints = DeRiskPoints+5

    sl_hit = 0
    callsymbol = ""
    putsymbol = ""
    # adjustment_level = 1.75
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        logging.info("Nothing to Monitor...Returning!!!")
        return 0, 0, 0, 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue, pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                logging.info("Call symbol is %s Quantity is %s", callsymbol, quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = quantity
                logging.info("Put symbol is %s Quantity is %s", putsymbol, quantity)

    logging.info(symbol_dict)
    quantity = abs(callquantity)

    if (callsymbol == "" and putsymbol == ""):
        logging.info("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return 0, round(pnl, 1), 0, 0
    elif (callsymbol == ""):
        logging.info("No Active Call symbol found...Looks like some problem...Exiting all positions")
        exit_nifty_strangle(producttype, filename)
        return 0, round(pnl, 1), 0, 0
    elif (putsymbol == ""):
        logging.info("No Active Put symbol found...Looks like some problem...Exiting all positions")
        exit_nifty_strangle(producttype, filename)
        return 0, round(pnl, 1), 0, 0

    symbols = [callsymbol, putsymbol]
    callstrike = nifty_symbol_to_strike(callsymbol)
    putstrike = nifty_symbol_to_strike(putsymbol)

    symbols_ltp = last_price(symbols)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    logging.info("Call price is %s", callprice)
    logging.info("Put price is %s", putprice)

    if (callprice > putprice):
        higher_price = callprice
        higher_symbol = callsymbol
        lower_price = putprice
        lower_symbol = putsymbol
    else:
        higher_price = putprice
        higher_symbol = putsymbol
        lower_price = callprice
        lower_symbol = callsymbol

    logging.info("Current Ratio of both legs is %s", round(higher_price / lower_price, 2))
    # print("Max Loss points is ", MaxLossPoints)

    sl_count = 0
    for i in range(num_orders - 1, 0, -1):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (processed_order_data[i][
            txn_type_index] == 'SLL' and (
                symbol == callsymbol or symbol == putsymbol)):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            sl_count += 1
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            logging.info("SLL order status is - %s", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                logging.info("Stop loss hit at average price %s", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                stop_loss_symbol = symbol
                sl_hit = 1
                break
            elif (sl_count == 2):
                logging.info("Sl not hit yet")
                break
    if (sl_hit == 1):
        # Update the file
        # Cancel the other SL order - Done
        # Exit the active leg - Done
        # Place new orders- Done

        if (stop_loss_symbol == callsymbol):
            logging.info("Call leg cut by SL, cancelling PUT SL and cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=producttype)
            # time.sleep(2)

            logging.info("Updating File - Replacing SLL with BUY")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()

            putprice_buy = fetch_order(putorderid_buy)['average_price']

            if (putprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    putprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        elif (stop_loss_symbol == putsymbol):
            logging.info("Put leg cut by SL, cancelling CALL SLand cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                            product=producttype)
            # time.sleep(2)
            logging.info("Updating File")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()
            callprice_buy = fetch_order(callorderid_buy)['average_price']

            if (callprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    callprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        logging.info("Starting both positions afresh now")

        nifty_cur_price = weekly_nifty_future()
        nifty_atm_strike = int(nifty_cur_price - nifty_cur_price % 50)
        put_strike_new = nifty_atm_strike
        call_strike_new = nifty_atm_strike

        while (True):

            putsymbol_new = nifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = nifty_strike_to_symbol(call_strike_new, "CALL")

            symbols = [callsymbol_new, putsymbol_new]
            symbols_ltp = last_price(symbols)
            callprice_new = symbols_ltp[0]
            putprice_new = symbols_ltp[1]

            if (callprice_new > day_premium):
                call_strike_new += 50
            if (putprice_new > day_premium):
                put_strike_new -= 50

            if (callprice_new < day_premium and putprice_new < day_premium):
                break

        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None,
                                       trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None,
                                        trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity,
                                       price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        if putstrike_price_new > 0:
            f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
                putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &s order did not get executed....Some problem ...check ", putsymbol_new)

        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        if callstrike_price_new > 0:
            f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
                callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &sorder did not get executed....Some problem ...check ", callsymbol_new)

        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        f.close()
    # elif ((higher_price > day_premium + DeRiskPoints) or has_moving_strangle_started==1 or expiry_end_code == 1):
    elif ((higher_price > day_premium + DeRiskPoints) or expiry_end_code == 1):

        new_put_strike = 0
        new_call_strike = 0
        # new_put_strike=0
        # new_put_strike=0

        if (callprice == higher_price):
            print("xyz")
            # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts and calls Up")
            nifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            nifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            new_put_strike = putstrike + 50
            new_call_strike = callstrike + 50
            new_putsymbol = nifty_strike_to_symbol(new_put_strike, 'PUT')
            new_callsymbol = nifty_strike_to_symbol(new_call_strike, 'CALL')
        else:
            print("xyz")
            # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts and calls down")
            nifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            nifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            new_put_strike = putstrike - 50
            new_call_strike = callstrike - 50
            new_putsymbol = nifty_strike_to_symbol(new_put_strike, 'PUT')
            new_callsymbol = nifty_strike_to_symbol(new_call_strike, 'CALL')

        new_putprice = last_price(new_putsymbol)
        new_callprice = last_price(new_callsymbol)

        # logging.info("Cutting both positions and de-risking")
        logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()

        put_sl_trig_price = new_putprice * 2
        call_sl_trig_price = new_callprice * 2

        put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
        #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        # f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
        #     callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()

        # CALCULATE THE DIFF OF CURR CALL AND PUT FROM ATM TO FIX IT ON MOVING STRANGLE

        nifty_strike = weekly_nifty_future()

        strike_nifty = nifty_strike / 50
        mod_nifty = nifty_strike % 50

        if mod_nifty > 26:
            strike_nifty = (int(strike_nifty) + 1) * 50
        else:
            strike_nifty = (int(strike_nifty)) * 50

        logging.info("___________________________________________________________________________________")

        logging.info("NIFTY STRIKE IS: " + str(strike_nifty))

        logging.info("_______________________________________________________________________________________________")

        # CALL_NIFTY_OPTION_CHAIN_df,PUT_NIFTY_OPTION_CHAIN_df=COMPLETE_NIFTY_WATCHLIST()

        # delta_15_call,delta_15_call_LTP=nifty_n_delta_strike_with_ltp(call_delta_to_sell_at_open,CALL_NIFTY_OPTION_CHAIN_df,"c")

        # delta_15_put,delta_15_put_LTP=nifty_n_delta_strike_with_ltp(put_delta_to_sell_at_open,PUT_NIFTY_OPTION_CHAIN_df,"p")

        put_strike = nifty_symbol_to_strike(new_putsymbol)
        call_strike = nifty_symbol_to_strike(new_callsymbol)

        nifty_cur_price = nifty_strike

        call_diff = call_strike - nifty_cur_price
        put_diff = nifty_cur_price - put_strike

        return 1, round(pnl, 1), call_diff, put_diff


    elif (higher_price / lower_price >= adjustment_level and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = nifty_symbol_to_strike(putsymbol) + 50
            while (True):
                new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * adjustment_leg_matching_factor):
                    put_strike += 50
                else:
                    break

            put_strike -= 50
            new_putsymbol = nifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_nifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = nifty_symbol_to_strike(callsymbol) - 50
            while (True):
                new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice * adjustment_leg_matching_factor):
                    call_strike -= 50
                else:
                    break

            call_strike += 50
            new_callsymbol = nifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_nifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()
    else:
        if (higher_price <= 4 and higher_price / lower_price >= adjustment_level):
            logging.info("Premiums too low, adjustment not required")
        else:
            logging.info("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return 0, round(pnl, 1), 0, 0


def monitor_banknifty_strangle_with_moving_strangle(producttype, day_premium, adjustment_level, filename,
                                                    DeRiskPoints, StopLossPoints, expiry_end_code,
                                                    adjustment_leg_matching_factor):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index, buysellval_dict_index, quantity_dict_index, pnl_dict_index
    global has_moving_strangle_started

    # if has_moving_strangle_started!=1:
    #     has_moving_strangle_started=0

    # has_moving_strangle_started=0

    # DeRiskPoints= 20 # day_premium*2
    # StopLossPoints = DeRiskPoints+5

    sl_hit = 0
    callsymbol = ""
    putsymbol = ""
    # adjustment_level = 1.75
    curdate = datetime.datetime.today()
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    f = open(filename, "r")  # File Reading
    filedata = f.read()
    f.close()
    symbol_dict = {}

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    if (num_orders == 0):
        logging.info("Nothing to Monitor...Returning!!!")
        return 0, 0, 0, 0

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)

    for i in range(num_orders):
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue, pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)
        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][buysellval_dict_index] += BuySellValue
        symbol_dict[symbol][quantity_dict_index] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][pnl_dict_index] = (symbol_dict[symbol][buysellval_dict_index] * -1) + (
                symbol_dict[symbol][quantity_dict_index] * last_price(
            symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        pnl += symbol_dict[symbol][pnl_dict_index]

        if (symbol_dict[symbol][quantity_dict_index] < 0):
            if (symbol.find('CE') > 0):
                callsymbol = symbol
                callquantity = quantity
                logging.info("Call symbol is %s Quantity is %s", callsymbol, quantity)
            elif (symbol.find('PE') > 0):
                putsymbol = symbol
                putquantity = quantity
                logging.info("Put symbol is %s Quantity is %s", putsymbol, quantity)

    logging.info(symbol_dict)
    quantity = abs(callquantity)

    if (callsymbol == "" and putsymbol == ""):
        logging.info("No Active Call/Put symbol found...Either we have exited or some problem...Returning")
        return 0, round(pnl, 1), 0, 0
    elif (callsymbol == ""):
        logging.info("No Active Call symbol found...Looks like some problem...Exiting all positions")
        exit_banknifty_strangle(producttype, filename)
        return 0, round(pnl, 1), 0, 0
    elif (putsymbol == ""):
        logging.info("No Active Put symbol found...Looks like some problem...Exiting all positions")
        exit_banknifty_strangle(producttype, filename)
        return 0, round(pnl, 1), 0, 0

    symbols = [callsymbol, putsymbol]
    callstrike = banknifty_symbol_to_strike(callsymbol)
    putstrike = banknifty_symbol_to_strike(putsymbol)

    symbols_ltp = last_price(symbols)

    callprice = symbols_ltp[0]
    putprice = symbols_ltp[1]

    logging.info("Call price is %s", callprice)
    logging.info("Put price is %s", putprice)

    if (callprice > putprice):
        higher_price = callprice
        higher_symbol = callsymbol
        lower_price = putprice
        lower_symbol = putsymbol
    else:
        higher_price = putprice
        higher_symbol = putsymbol
        lower_price = callprice
        lower_symbol = callsymbol

    logging.info("Current Ratio of both legs is %s", round(higher_price / lower_price, 2))
    # print("Max Loss points is ", MaxLossPoints)

    sl_count = 0
    for i in range(num_orders - 1, 0, -1):  # This loop does 2 independent things
        symbol = processed_order_data[i][symbol_index]  # 1.Here a dictionary of all symmbols found in orders is created
        if (processed_order_data[i][
            txn_type_index] == 'SLL' and (
                symbol == callsymbol or symbol == putsymbol)):  # 2. Here SLL is checked, has it changed to COmplete, if yes means Stop Loss hit
            sl_count += 1
            order = fetch_order(order_id=processed_order_data[i][order_index])
            cur_order_status = order['status']
            logging.info("SLL order status is - %s", cur_order_status)
            if (cur_order_status == "COMPLETE"):
                sl_avg_price = order['average_price']
                logging.info("Stop loss hit at average price %s", sl_avg_price)
                processed_order_data[i][txn_type_index] = 'BUY'
                processed_order_data[i][price_index] = str(sl_avg_price)
                stop_loss_symbol = symbol
                sl_hit = 1
                break
            elif (sl_count == 2):
                logging.info("Sl not hit yet")
                break
    if (sl_hit == 1):
        # Update the file
        # Cancel the other SL order - Done
        # Exit the active leg - Done
        # Place new orders- Done

        if (stop_loss_symbol == callsymbol):
            logging.info("Call leg cut by SL, cancelling PUT SL and cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            putorderid_buy = execute_order(symbol=putsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                           product=producttype)
            # time.sleep(2)

            logging.info("Updating File - Replacing SLL with BUY")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()

            putprice_buy = fetch_order(putorderid_buy)['average_price']

            if (putprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(putorderid_buy) + "\t" + "BUY" + "\t" + putsymbol + "\t" + str(quantity) + "\t" + str(
                    putprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        elif (stop_loss_symbol == putsymbol):
            logging.info("Put leg cut by SL, cancelling CALL SLand cutting active PUT leg")
            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()
            callorderid_buy = execute_order(symbol=callsymbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                            product=producttype)
            # time.sleep(2)
            logging.info("Updating File")
            f = open(filename, "w")  # For Overwriting Existing File
            for i in range(num_orders):
                num_parameters = len(processed_order_data[i])
                for j in range(num_parameters):
                    f.write(processed_order_data[i][j])
                    if (j != num_parameters - 1):  # No tab space needed after the last word on each line
                        f.write("\t")
                f.write("\n")
            f.close()
            callprice_buy = fetch_order(callorderid_buy)['average_price']

            if (callprice_buy > 0):
                f = open(filename, "a")  # Append mode
                f.write(str(callorderid_buy) + "\t" + "BUY" + "\t" + callsymbol + "\t" + str(quantity) + "\t" + str(
                    callprice_buy) + "\t" + str(datetime.datetime.now()) + "\n")
                f.close()
            else:
                logging.info("BUY order did not get executed....Some problem ...check ")

        logging.info("Starting both positions afresh now")

        banknifty_cur_price = weekly_banknifty_future()
        banknifty_atm_strike = int(banknifty_cur_price - banknifty_cur_price % 100)
        put_strike_new = banknifty_atm_strike
        call_strike_new = banknifty_atm_strike

        while (True):

            putsymbol_new = banknifty_strike_to_symbol(put_strike_new, "PUT")
            callsymbol_new = banknifty_strike_to_symbol(call_strike_new, "CALL")

            symbols = [callsymbol_new, putsymbol_new]
            symbols_ltp = last_price(symbols)
            callprice_new = symbols_ltp[0]
            putprice_new = symbols_ltp[1]

            if (callprice_new > day_premium):
                call_strike_new += 100
            if (putprice_new > day_premium):
                put_strike_new -= 100

            if (callprice_new < day_premium and putprice_new < day_premium):
                break

        curtime3 = datetime.datetime.now()
        putorderid_new = execute_order(symbol=putsymbol_new, type="SELL", quant=quantity, price=None,
                                       trig_price=None,
                                       product=producttype)
        curtime4 = datetime.datetime.now()
        callorderid_new = execute_order(symbol=callsymbol_new, type="SELL", quant=quantity, price=None,
                                        trig_price=None,
                                        product=producttype)

        time.sleep(2)

        putstrike_price_new = fetch_order(putorderid_new)['average_price']
        callstrike_price_new = fetch_order(callorderid_new)['average_price']

        put_sl_trig_price = round(putstrike_price_new, 1) + StopLossPoints
        call_sl_trig_price = round(callstrike_price_new, 1) + StopLossPoints

        put_sl_orderid = execute_order(symbol=putsymbol_new, type="BUY", quant=quantity,
                                       price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=callsymbol_new, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        if putstrike_price_new > 0:
            f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
                putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &s order did not get executed....Some problem ...check ", putsymbol_new)

        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        if callstrike_price_new > 0:
            f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
                callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        else:
            logging.info("SELL &sorder did not get executed....Some problem ...check ", callsymbol_new)

        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
        f.close()
    # elif ((higher_price > day_premium + DeRiskPoints) or has_moving_strangle_started==1 or expiry_end_code == 1):
    elif ((higher_price > day_premium + DeRiskPoints) or expiry_end_code == 1):

        new_put_strike = 0
        new_call_strike = 0
        # new_put_strike=0
        # new_put_strike=0

        if (callprice == higher_price):
            print("xyz")
            # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts and calls Up")
            banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            banknifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            new_put_strike = putstrike + 100
            new_call_strike = callstrike + 100
            new_putsymbol = banknifty_strike_to_symbol(new_put_strike, 'PUT')
            new_callsymbol = banknifty_strike_to_symbol(new_call_strike, 'CALL')
        else:
            print("xyz")
            # send_logs("Put Strike Diff is "+str(put_diff)+ " Moving Puts and calls down")
            banknifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            banknifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            new_put_strike = putstrike - 100
            new_call_strike = callstrike - 100
            new_putsymbol = banknifty_strike_to_symbol(new_put_strike, 'PUT')
            new_callsymbol = banknifty_strike_to_symbol(new_call_strike, 'CALL')

        new_putprice = last_price(new_putsymbol)
        new_callprice = last_price(new_callsymbol)

        # logging.info("Cutting both positions and de-risking")
        logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == putsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == callsymbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        curtime1 = datetime.datetime.now()

        put_sl_trig_price = new_putprice * 2
        call_sl_trig_price = new_callprice * 2

        put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity, price=put_sl_trig_price + 10,
                                       trig_price=put_sl_trig_price,
                                       product=producttype)
        call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                        price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                        product=producttype)

        f = open(filename, "a")  # Append mode
        # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
        #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
            put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        # f.write(str(callorderid_new) + "\t" + "SELL" + "\t" + callsymbol_new + "\t" + str(quantity) + "\t" + str(
        #     callstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
        f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
            call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

        f.close()

        # CALCULATE THE DIFF OF CURR CALL AND PUT FROM ATM TO FIX IT ON MOVING STRANGLE

        bank_nifty_strike = weekly_banknifty_future()

        strike_bank_nifty = bank_nifty_strike / 100
        mod_bank_nifty = bank_nifty_strike % 100

        if mod_bank_nifty > 51:
            strike_bank_nifty = (int(strike_bank_nifty) + 1) * 100
        else:
            strike_bank_nifty = (int(strike_bank_nifty)) * 100

        logging.info("___________________________________________________________________________________")

        logging.info("BANK NIFTY STRIKE IS: " + str(strike_bank_nifty))

        logging.info("_______________________________________________________________________________________________")

        # CALL_BANK_NIFTY_OPTION_CHAIN_df,PUT_BANK_NIFTY_OPTION_CHAIN_df=COMPLETE_BANK_NIFTY_WATCHLIST()

        # BANK_delta_15_call,BANK_delta_15_call_LTP=bank_nifty_n_delta_strike(call_delta_to_sell_at_open,CALL_BANK_NIFTY_OPTION_CHAIN_df,"c")

        # BANK_delta_15_put,BANK_delta_15_put_LTP=bank_nifty_n_delta_strike(put_delta_to_sell_at_open,PUT_BANK_NIFTY_OPTION_CHAIN_df,"p")

        put_strike = banknifty_symbol_to_strike(new_putsymbol)
        call_strike = banknifty_symbol_to_strike(new_callsymbol)

        banknifty_cur_price = bank_nifty_strike

        call_diff = call_strike - banknifty_cur_price
        put_diff = banknifty_cur_price - put_strike

        return 1, round(pnl, 1), call_diff, put_diff

        if (curday == 3):  # Expiry Day - Thursday
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100
            # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
            # elif(cur_hour==12 or cur_hour==13 ):
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
            # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
            # call_max_range = call_diff+100
            # call_min_range =call_diff-100
            # put_max_range = put_diff+100
            # put_min_range = put_diff-100
        elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
            # call_max_range = 400
            # call_min_range =300
            # put_max_range = 450
            # put_min_range = 350
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
            # call_max_range = 400
            # call_min_range =300
            # put_max_range = 400
            # put_min_range = 300
            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
            # call_max_range = 350
            # call_min_range =250
            # put_max_range = 400
            # put_min_range = 300
            # call_max_range =555
            # call_min_range =450
            # put_max_range =605
            # put_min_range = 500

            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
            # call_max_range = 500
            # call_min_range =400
            # put_max_range = 550
            # put_min_range = 450

            call_max_range = call_diff + 100
            call_min_range = call_diff - 100
            put_max_range = put_diff + 100
            put_min_range = put_diff - 100

        else:  # saturday and sunday for testing Start with a delta neutral 250/300 point strangle
            call_max_range = 500
            call_min_range = 400
            put_max_range = 550
            put_min_range = 450

        has_moving_strangle_started = 1

        banknifty_cur_price = weekly_banknifty_future()
        print("Bank Nifty CUrrent Price is - ", banknifty_cur_price, "\n")
        if (callsymbol == "" and putsymbol == ""):
            print("Found No Positions to Monitor...Exiting!!")
            return 0, round(pnl, 1), 0, 0
        else:
            callstrike = banknifty_symbol_to_strike(callsymbol)
            putstrike = banknifty_symbol_to_strike(putsymbol)

            put_diff = banknifty_cur_price - putstrike
            call_diff = callstrike - banknifty_cur_price

            if (call_diff > call_max_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Down")
                banknifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            elif (call_diff < call_min_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Up")
                banknifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), producttype, filename)
            else:
                print("Call Strike Diff is ", int(call_diff), "Nothing to do right now !!")
                print("Will Move Calls Up At ", callstrike - call_min_range)
                print("Will Move Calls Down At ", callstrike - call_max_range)

            if (put_diff > put_max_range):

                print("Put Strike Diff is ", int(put_diff), "Moving Puts Up")
                banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            elif (put_diff < put_min_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Down")
                banknifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), producttype, filename)
            else:
                print("Put Strike Diff is ", int(put_diff), "Nothing to do right now !!")
                print("Will Move Puts Up At ", putstrike + put_max_range)
                print("Will Move Puts Down At ", putstrike + put_min_range)

        if (expiry_end_code == 1):
            time.sleep(60)
            expiry_end_code = 0




    elif (higher_price / lower_price >= adjustment_level and higher_price > 4):

        # Cancel the SL Order
        for i in range(num_orders - 1, 0, -1):
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            symbol_order_id = processed_order_data[i][order_index]
            if (symbol == lower_symbol and type == 'SLL'):
                kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                break

        logging.info("Cutting %s and entering matching position", lower_symbol)

        curtime1 = datetime.datetime.now()
        orderid1 = execute_order(symbol=lower_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                                 product=producttype)

        if (lower_symbol.find("PE") > 0):
            put_strike = banknifty_symbol_to_strike(putsymbol) + 100
            while (True):
                new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")
                new_putprice = last_price(new_putsymbol)

                if (new_putprice < callprice * adjustment_leg_matching_factor):
                    put_strike += 100
                else:
                    break

            put_strike -= 100
            new_putsymbol = banknifty_strike_to_symbol(put_strike, "PUT")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)

            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0
            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_putsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            put_sl_trig_price = round(order_price2, 1) + StopLossPoints
            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10, trig_price=put_sl_trig_price,
                                           product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")
            f.close()
        elif (lower_symbol.find("CE") > 0):
            call_strike = banknifty_symbol_to_strike(callsymbol) - 100
            while (True):
                new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")
                new_callprice = last_price(new_callsymbol)

                if (new_callprice < putprice * adjustment_leg_matching_factor):
                    call_strike -= 100
                else:
                    break

            call_strike += 100
            new_callsymbol = banknifty_strike_to_symbol(call_strike, "CALL")

            curtime2 = datetime.datetime.now()
            orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None, trig_price=None,
                                     product=producttype)
            time.sleep(2)
            order_price1 = fetch_order(orderid1)['average_price']
            order_price2 = fetch_order(orderid2)['average_price']

            # Case1 Both Buy and sell orders have failed
            if (order_price1 == 0 and order_price2 == 0):
                logging.info("Both Buy and sell orders have failed")
                logging.info("Order1 buy order might be in validation pending stage.Rechecking for 5 sec")
                counter = 5
                while (counter > 0):
                    order1_status = fetch_order(orderid1)['status']
                    if (order1_status == 'COMPLETE'):
                        order_price1 = float(fetch_order(orderid1)['average_price'])
                        break
                    time.sleep(1)
                    counter -= 1
                if (counter > 0):
                    logging.info("Now Buy order has executed properly. So Re Triggering sell order")
                    curtime2 = datetime.datetime.now()
                    orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                             trig_price=None,
                                             product=producttype)
                    time.sleep(2)
                    order_price2 = fetch_order(orderid2)['average_price']
                else:
                    logging.info("Buy Order did not get successfully executed.")
                    if (order1_status != "REJECTED"):
                        kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=orderid1)
                    logging.info("Adjustment failed. Reattempting adjustment from scratch. Running the loop again.")
                    return 0, round(pnl, 1), 0, 0

            elif (order_price1 != 0 and order_price2 == 0):  # Case 2 Buy order executed but sell failed
                logging.info("Buy executed properly but sell failed...maybe it was too quick trying once again")
                curtime2 = datetime.datetime.now()
                orderid2 = execute_order(symbol=new_callsymbol, type="SELL", quant=quantity, price=None,
                                         trig_price=None,
                                         product=producttype)
                time.sleep(2)
                order_price2 = fetch_order(orderid2)['average_price']

                if (order_price2 == 0):
                    logging.info("Sell Order failed again...Lets close all positions")

                    # Writing Buy position to file
                    f = open(filename, "a")  # Append mode
                    f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                        order_price1) + "\t" + str(datetime.datetime.now()) + "\n")
                    f.close()
                    exit_banknifty_strangle(producttype, filename)
                    return 0, round(pnl, 1), 0, 0

            call_sl_trig_price = round(order_price2, 1) + StopLossPoints
            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10, trig_price=call_sl_trig_price,
                                            product=producttype)

            f = open(filename, "a")  # Append mode
            f.write(str(orderid1) + "\t" + "BUY" + "\t" + lower_symbol + "\t" + str(quantity) + "\t" + str(
                order_price1) + "\t" + str(datetime.datetime.now()) + "\n")

            f = open(filename, "a")  # Append mode
            f.write(str(orderid2) + "\t" + "SELL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                order_price2) + "\t" + str(datetime.datetime.now()) + "\n")

            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()
    else:
        if (higher_price <= 4 and higher_price / lower_price >= adjustment_level):
            logging.info("Premiums too low, adjustment not required")
        else:
            logging.info("Both positions in range...Nothing to do now!!")

        # Handling is the same in both the above cases

    return 0, round(pnl, 1), 0, 0


def monitor_nifty_moving_strangle_with_nifty_strangle(product_type, call_diff, put_diff, filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    print("In monitor moving strangle nifty")

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += int(quantity)
    pnl = 0
    # pprint(symbol_dict)
    # ppp.set_trace()
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            # send_logs("Call symbol is "+ callsymbol+" and quantity is "+ str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    send_logs("Total pnl is " + str(round(pnl, 1)))
    print("Total pnl is " + str(round(pnl, 1)))

    # ppp.set_trace()
    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday

        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle

        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle

        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle

        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle

        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    else:  # saturday and sunday for testing Start with a delta neutral 250/300 point strangle

        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    nifty_cur_price = weekly_nifty_future()

    if (callsymbol == "" and putsymbol == ""):
        send_logs("Found No Positions to Monitor...Exiting!!")
        return 1, pnl
    else:
        callstrike = nifty_symbol_to_strike(callsymbol)
        putstrike = nifty_symbol_to_strike(putsymbol)

        put_diff = nifty_cur_price - putstrike
        call_diff = callstrike - nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            nifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type, filename)

            new_put_strike = putstrike + 50
            new_putsymbol = nifty_strike_to_symbol(new_put_strike, "PUT")
            new_putprice = last_price(new_putsymbol)

            # logging.info("Cutting both positions and de-risking")
            logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()

            put_sl_trig_price = new_putprice * 2

            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10,
                                           trig_price=put_sl_trig_price,
                                           product=product_type)

            f = open(filename, "a")  # Append mode
            # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            nifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), product_type, filename)

            new_put_strike = putstrike - 50
            new_putsymbol = nifty_strike_to_symbol(new_put_strike, "PUT")
            new_putprice = last_price(new_putsymbol)

            # logging.info("Cutting both positions and de-risking")
            logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()

            put_sl_trig_price = new_putprice * 2

            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10,
                                           trig_price=put_sl_trig_price,
                                           product=product_type)

            f = open(filename, "a")  # Append mode
            # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            nifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), product_type, filename)

            new_call_strike = callstrike - 50
            new_callsymbol = nifty_strike_to_symbol(new_call_strike, "CALL")
            new_callprice = last_price(new_callsymbol)

            # logging.info("Cutting both positions and de-risking")
            logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()

            call_sl_trig_price = new_callprice * 2

            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10,
                                            trig_price=call_sl_trig_price,
                                            product=product_type)

            f = open(filename, "a")  # Append mode
            # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            nifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), product_type, filename)

            new_call_strike = callstrike + 50
            new_callsymbol = nifty_strike_to_symbol(new_call_strike, "CALL")
            new_callprice = last_price(new_callsymbol)

            # logging.info("Cutting both positions and de-risking")
            logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()

            call_sl_trig_price = new_callprice * 2

            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10,
                                            trig_price=call_sl_trig_price,
                                            product=product_type)

            f = open(filename, "a")  # Append mode
            # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return 1, pnl


def monitor_banknifty_moving_strangle_with_bn_strangle(product_type, call_diff, put_diff, filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    print("In monitor moving strangle bn")

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += int(quantity)
    pnl = 0
    # pprint(symbol_dict)
    # ppp.set_trace()
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            # send_logs("Call symbol is "+ callsymbol+" and quantity is "+ str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    send_logs("Total pnl is " + str(round(pnl, 1)))
    print("Total pnl is " + str(round(pnl, 1)))

    # ppp.set_trace()
    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday

        call_max_range = call_diff + 100
        call_min_range = call_diff - 100
        put_max_range = put_diff + 100
        put_min_range = put_diff - 100

    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle

        call_max_range = call_diff + 100
        call_min_range = call_diff - 100
        put_max_range = put_diff + 100
        put_min_range = put_diff - 100

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle

        call_max_range = call_diff + 100
        call_min_range = call_diff - 100
        put_max_range = put_diff + 100
        put_min_range = put_diff - 100

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle

        call_max_range = call_diff + 100
        call_min_range = call_diff - 100
        put_max_range = put_diff + 100
        put_min_range = put_diff - 100

    elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle

        call_max_range = call_diff + 100
        call_min_range = call_diff - 100
        put_max_range = put_diff + 100
        put_min_range = put_diff - 100

    else:  # saturday and sunday for testing Start with a delta neutral 250/300 point strangle

        call_max_range = call_diff + 100
        call_min_range = call_diff - 100
        put_max_range = put_diff + 100
        put_min_range = put_diff - 100

    bank_nifty_cur_price = weekly_banknifty_future()

    if (callsymbol == "" and putsymbol == ""):
        send_logs("Found No Positions to Monitor...Exiting!!")
        return 1, pnl
    else:
        callstrike = banknifty_symbol_to_strike(callsymbol)
        putstrike = banknifty_symbol_to_strike(putsymbol)

        put_diff = bank_nifty_cur_price - putstrike
        call_diff = callstrike - bank_nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            banknifty_put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type, filename)

            new_put_strike = putstrike + 100
            new_putsymbol = banknifty_strike_to_symbol(new_put_strike, "PUT")
            new_putprice = last_price(new_putsymbol)

            # logging.info("Cutting both positions and de-risking")
            logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()

            put_sl_trig_price = new_putprice * 2

            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10,
                                           trig_price=put_sl_trig_price,
                                           product=product_type)

            f = open(filename, "a")  # Append mode
            # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            banknifty_put_strike_down_moving_strangle(putstrike, abs(putquantity), product_type, filename)

            new_put_strike = putstrike - 100
            new_putsymbol = banknifty_strike_to_symbol(new_put_strike, "PUT")
            new_putprice = last_price(new_putsymbol)

            # logging.info("Cutting both positions and de-risking")
            logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == putsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()

            put_sl_trig_price = new_putprice * 2

            put_sl_orderid = execute_order(symbol=new_putsymbol, type="BUY", quant=quantity,
                                           price=put_sl_trig_price + 10,
                                           trig_price=put_sl_trig_price,
                                           product=product_type)

            f = open(filename, "a")  # Append mode
            # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
            f.write(str(put_sl_orderid) + "\t" + "SLL" + "\t" + new_putsymbol + "\t" + str(quantity) + "\t" + str(
                put_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            banknifty_call_strike_down_moving_strangle(callstrike, abs(callquantity), product_type, filename)

            new_call_strike = callstrike - 100
            new_callsymbol = banknifty_strike_to_symbol(new_call_strike, "CALL")
            new_callprice = last_price(new_callsymbol)

            # logging.info("Cutting both positions and de-risking")
            logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()

            call_sl_trig_price = new_callprice * 2

            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10,
                                            trig_price=call_sl_trig_price,
                                            product=product_type)

            f = open(filename, "a")  # Append mode
            # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            banknifty_call_strike_up_moving_strangle(callstrike, abs(callquantity), product_type, filename)

            new_call_strike = callstrike + 100
            new_callsymbol = banknifty_strike_to_symbol(new_call_strike, "CALL")
            new_callprice = last_price(new_callsymbol)

            # logging.info("Cutting both positions and de-risking")
            logging.info("DE RISK CRITERIA REACHED. CONVERTING CODE TO MOVING STRANGLE NOW..")

            for i in range(num_orders - 1, 0, -1):
                type = processed_order_data[i][txn_type_index]
                symbol = processed_order_data[i][symbol_index]  # fetch symbol
                symbol_order_id = processed_order_data[i][order_index]
                if (symbol == callsymbol and type == 'SLL'):
                    kite.cancel_order(variety=kite.VARIETY_REGULAR, order_id=symbol_order_id)
                    break

            curtime1 = datetime.datetime.now()

            call_sl_trig_price = new_callprice * 2

            call_sl_orderid = execute_order(symbol=new_callsymbol, type="BUY", quant=quantity,
                                            price=call_sl_trig_price + 10,
                                            trig_price=call_sl_trig_price,
                                            product=product_type)

            f = open(filename, "a")  # Append mode
            # f.write(str(putorderid_new) + "\t" + "SELL" + "\t" + putsymbol_new + "\t" + str(quantity) + "\t" + str(
            #     putstrike_price_new) + "\t" + str(datetime.datetime.now()) + "\n")
            f.write(str(call_sl_orderid) + "\t" + "SLL" + "\t" + new_callsymbol + "\t" + str(quantity) + "\t" + str(
                call_sl_trig_price) + "\t" + str(datetime.datetime.now()) + "\n")

            f.close()

        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return 1, pnl


def start_of_code_trigger_nifty():
    flag = 0

    nifty_prefix = nifty_current_expiry_symbol()
    # bank_nifty_prefix=bank_nifty_current_expiry_symbol()

    NIFTY_RATIO_STRADDLE_ARRAY = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
    # BANK_NIFTY_RATIO_STRADDLE_ARRAY=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
    minima = 1000000
    r = 0

    while flag != 1:

        curtime = datetime.datetime.now()
        cur_minute = curtime.minute
        cur_hour = curtime.hour
        curdate = datetime.datetime.today()

        # if (cur_hour==start_hour and cur_minute>=end_minute):

        quote_watchlist = []
        nifty_strike = nifty_ltp()
        # bank_nifty_strike=bank_nifty_ltp()

        strike_nifty = nifty_strike / 50
        mod = nifty_strike % 50

        # strike_bank_nifty=bank_nifty_strike/100
        # mod_bank_nifty=bank_nifty_strike%100

        if mod >= 0:
            strike_nifty = (int(strike_nifty) + 1) * 50
        else:
            strike_nifty = (int(strike_nifty)) * 50

        # if mod_bank_nifty>=0 :
        #     strike_bank_nifty= (int(strike_bank_nifty)+1)*100
        # else:
        #     strike_bank_nifty= (int(strike_bank_nifty))*100

        strike_nifty_below = strike_nifty - 50
        # strike_bank_nifty_below=strike_bank_nifty-100

        send_logs("NIFTY ABOVE STRIKE IS: " + str(strike_nifty))
        # send_logs("BANK NIFTY ABOVE STRIKE IS: "+ str(strike_bank_nifty))

        send_logs("NIFTY BELOW STRIKE IS: " + str(strike_nifty_below))
        # send_logs("BANK NIFTY BELOW STRIKE IS: "+ str(strike_bank_nifty_below))

        send_logs("NIFTY LTP IS: " + str(nifty_strike))
        # send_logs("BANK NIFTY LTP IS: "+ str(bank_nifty_strike))

        send_logs("_______________________________________________________________________________________________")

        sys_ce = nifty_prefix + str(strike_nifty) + "CE"
        sys_pe = nifty_prefix + str(strike_nifty) + "PE"

        # sys_ce_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "CE"
        # sys_pe_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty) + "PE"

        sys_below_ce = nifty_prefix + str(strike_nifty_below) + "CE"
        sys_below_pe = nifty_prefix + str(strike_nifty_below) + "PE"

        # sys_below_ce_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty_below) + "CE"
        # sys_below_pe_bank_nifty=bank_nifty_prefix + str(strike_bank_nifty_below) + "PE"

        NIFTY_OPTION_CHAIN_WATCHLIST = get_nifty_watchlist(strike_nifty, 4, nifty_prefix)
        # BANK_NIFTY_OPTION_CHAIN_WATCHLIST=get_bank_nifty_watchlist(strike_bank_nifty,4,bank_nifty_prefix)

        # pprint(NIFTY_OPTION_CHAIN_WATCHLIST)

        NIFTY_OPTION_CHAIN_DATA = get_ltp(NIFTY_OPTION_CHAIN_WATCHLIST)
        # BANK_NIFTY_OPTION_CHAIN_DATA = get_ltp(BANK_NIFTY_OPTION_CHAIN_WATCHLIST)

        above_straddle_price_nifty = NIFTY_OPTION_CHAIN_DATA[sys_ce]['last_price'] + NIFTY_OPTION_CHAIN_DATA[sys_pe][
            'last_price']
        below_straddle_price_nifty = NIFTY_OPTION_CHAIN_DATA[sys_below_ce]['last_price'] + \
                                     NIFTY_OPTION_CHAIN_DATA[sys_below_pe]['last_price']
        diff_from_above_nifty = strike_nifty - nifty_strike
        diff_from_below_nifty = nifty_strike - strike_nifty_below
        ratio_straddle_price_nifty = ((above_straddle_price_nifty * diff_from_below_nifty) + (
                below_straddle_price_nifty * diff_from_above_nifty)) / 50

        # above_straddle_price_bank_nifty=BANK_NIFTY_OPTION_CHAIN_DATA[sys_ce_bank_nifty]['last_price']+BANK_NIFTY_OPTION_CHAIN_DATA[sys_pe_bank_nifty]['last_price']
        # below_straddle_price_bank_nifty=BANK_NIFTY_OPTION_CHAIN_DATA[sys_below_ce_bank_nifty]['last_price']+BANK_NIFTY_OPTION_CHAIN_DATA[sys_below_pe_bank_nifty]['last_price']
        # diff_from_above_bank_nifty=strike_bank_nifty-bank_nifty_strike
        # diff_from_below_bank_nifty=bank_nifty_strike-strike_bank_nifty_below
        # ratio_straddle_price_bank_nifty=((above_straddle_price_bank_nifty*diff_from_below_bank_nifty)+(below_straddle_price_bank_nifty*diff_from_above_bank_nifty))/100

        # print(above_straddle_price_bank_nifty)
        send_logs("_______________________________________________________________________________________________")

        send_logs("NIFTY RATIO STRADDLE PRICE IS: " + str(ratio_straddle_price_nifty))
        # send_logs("BANK NIFTY RATIO STRADDLE PRICE IS: "+ str(ratio_straddle_price_bank_nifty))
        send_logs("_______________________________________________________________________________________________")

        # NIFTY_RATIO_STRADDLE_ARRAY.insert(r%15,ratio_straddle_price_nifty)
        # BANK_NIFTY_RATIO_STRADDLE_ARRAY.insert(r%15,ratio_straddle_price_bank_nifty)

        NIFTY_RATIO_STRADDLE_ARRAY[r % 15] = r % 15 + r
        # BANK_NIFTY_RATIO_STRADDLE_ARRAY[r%15]=r%15+r

        r = r + 1
        if (r > 15):
            minima = min(NIFTY_RATIO_STRADDLE_ARRAY)
            if ratio_straddle_price_nifty <= minima:
                flag = 1
                return 1
        pprint(NIFTY_RATIO_STRADDLE_ARRAY)

        # pprint(BANK_NIFTY_RATIO_STRADDLE_ARRAY)

        send_logs("Time is - " + str(curtime))

        send_logs("_______________________________________________________________________________________________")

        time.sleep(0.3)

        # flag=1
        # ppp.set_trace()


def start_of_code_trigger_bank_nifty():
    flag = 0

    # nifty_prefix=nifty_current_expiry_symbol()
    bank_nifty_prefix = bank_nifty_current_expiry_symbol()

    # NIFTY_RATIO_STRADDLE_ARRAY=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
    BANK_NIFTY_RATIO_STRADDLE_ARRAY = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
    minima = 1000000
    r = 0

    while flag != 1:

        curtime = datetime.datetime.now()
        cur_minute = curtime.minute
        cur_hour = curtime.hour
        curdate = datetime.datetime.today()

        # if (cur_hour==start_hour and cur_minute>=end_minute):

        quote_watchlist = []
        # nifty_strike=nifty_ltp()
        bank_nifty_strike = bank_nifty_ltp()

        # strike_nifty=nifty_strike/50
        # mod=nifty_strike%50

        strike_bank_nifty = bank_nifty_strike / 100
        mod_bank_nifty = bank_nifty_strike % 100

        # if mod>=0 :
        #     strike_nifty= (int(strike_nifty)+1)*50
        # else:
        #     strike_nifty= (int(strike_nifty))*50

        if mod_bank_nifty >= 0:
            strike_bank_nifty = (int(strike_bank_nifty) + 1) * 100
        else:
            strike_bank_nifty = (int(strike_bank_nifty)) * 100

        # strike_nifty_below=strike_nifty-50
        strike_bank_nifty_below = strike_bank_nifty - 100

        # send_logs("NIFTY ABOVE STRIKE IS: "+ str(strike_nifty))
        send_logs("BANK NIFTY ABOVE STRIKE IS: " + str(strike_bank_nifty))

        # send_logs("NIFTY BELOW STRIKE IS: "+ str(strike_nifty_below))
        send_logs("BANK NIFTY BELOW STRIKE IS: " + str(strike_bank_nifty_below))

        # send_logs("NIFTY LTP IS: "+ str(nifty_strike))
        send_logs("BANK NIFTY LTP IS: " + str(bank_nifty_strike))

        send_logs("_______________________________________________________________________________________________")

        # sys_ce=nifty_prefix + str(strike_nifty) + "CE"
        # sys_pe=nifty_prefix + str(strike_nifty) + "PE"

        sys_ce_bank_nifty = bank_nifty_prefix + str(strike_bank_nifty) + "CE"
        sys_pe_bank_nifty = bank_nifty_prefix + str(strike_bank_nifty) + "PE"

        # sys_below_ce=nifty_prefix + str(strike_nifty_below) + "CE"
        # sys_below_pe=nifty_prefix + str(strike_nifty_below) + "PE"

        sys_below_ce_bank_nifty = bank_nifty_prefix + str(strike_bank_nifty_below) + "CE"
        sys_below_pe_bank_nifty = bank_nifty_prefix + str(strike_bank_nifty_below) + "PE"

        # NIFTY_OPTION_CHAIN_WATCHLIST=get_nifty_watchlist(strike_nifty,4,nifty_prefix)
        BANK_NIFTY_OPTION_CHAIN_WATCHLIST = get_bank_nifty_watchlist(strike_bank_nifty, 4, bank_nifty_prefix)

        # pprint(NIFTY_OPTION_CHAIN_WATCHLIST)

        # NIFTY_OPTION_CHAIN_DATA = get_ltp(NIFTY_OPTION_CHAIN_WATCHLIST)
        BANK_NIFTY_OPTION_CHAIN_DATA = get_ltp(BANK_NIFTY_OPTION_CHAIN_WATCHLIST)

        # above_straddle_price_nifty=NIFTY_OPTION_CHAIN_DATA[sys_ce]['last_price']+NIFTY_OPTION_CHAIN_DATA[sys_pe]['last_price']
        # below_straddle_price_nifty=NIFTY_OPTION_CHAIN_DATA[sys_below_ce]['last_price']+NIFTY_OPTION_CHAIN_DATA[sys_below_pe]['last_price']
        # diff_from_above_nifty=strike_nifty-nifty_strike
        # diff_from_below_nifty=nifty_strike-strike_nifty_below
        # ratio_straddle_price_nifty=((above_straddle_price_nifty*diff_from_below_nifty)+(below_straddle_price_nifty*diff_from_above_nifty))/50

        above_straddle_price_bank_nifty = BANK_NIFTY_OPTION_CHAIN_DATA[sys_ce_bank_nifty]['last_price'] + \
                                          BANK_NIFTY_OPTION_CHAIN_DATA[sys_pe_bank_nifty]['last_price']
        below_straddle_price_bank_nifty = BANK_NIFTY_OPTION_CHAIN_DATA[sys_below_ce_bank_nifty]['last_price'] + \
                                          BANK_NIFTY_OPTION_CHAIN_DATA[sys_below_pe_bank_nifty]['last_price']
        diff_from_above_bank_nifty = strike_bank_nifty - bank_nifty_strike
        diff_from_below_bank_nifty = bank_nifty_strike - strike_bank_nifty_below
        ratio_straddle_price_bank_nifty = ((above_straddle_price_bank_nifty * diff_from_below_bank_nifty) + (
                below_straddle_price_bank_nifty * diff_from_above_bank_nifty)) / 100
        ratio_straddle_price_bank_nifty = round(ratio_straddle_price_bank_nifty, 0)
        # print(above_straddle_price_bank_nifty)
        send_logs("_______________________________________________________________________________________________")

        # send_logs("NIFTY RATIO STRADDLE PRICE IS: "+ str(ratio_straddle_price_nifty))
        send_logs("BANK NIFTY RATIO STRADDLE PRICE IS: " + str(ratio_straddle_price_bank_nifty))
        send_logs("_______________________________________________________________________________________________")

        # NIFTY_RATIO_STRADDLE_ARRAY.insert(r%15,ratio_straddle_price_nifty)
        # BANK_NIFTY_RATIO_STRADDLE_ARRAY.insert(r%15,ratio_straddle_price_bank_nifty)

        # NIFTY_RATIO_STRADDLE_ARRAY[r%15]=r%15+r
        BANK_NIFTY_RATIO_STRADDLE_ARRAY[r % 15] = ratio_straddle_price_bank_nifty

        r = r + 1
        if (r > 15):
            minima = min(BANK_NIFTY_RATIO_STRADDLE_ARRAY)
            send_logs("MINIMA IS: " + str(minima))
            if ratio_straddle_price_bank_nifty <= minima:
                flag = 1
                return 1
        # pprint(NIFTY_RATIO_STRADDLE_ARRAY)

        pprint(BANK_NIFTY_RATIO_STRADDLE_ARRAY)
        print(minima, r, ratio_straddle_price_bank_nifty, ratio_straddle_price_bank_nifty <= minima)

        send_logs("Time is - " + str(curtime))

        send_logs("_______________________________________________________________________________________________")

        time.sleep(1)

    return 0

    # flag=1
    # ppp.set_trace()


def MONITOR_BANKNIFTY_STRADDLE(producttype, filename):
    take_logs("IN MONITOR_BANKNIFTY_STRADDLE", filename)

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    # take_logs("In monitor moving strangle bn")

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += int(quantity)
    pnl = 0
    # pprint(symbol_dict)
    # ppp.set_trace()
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            # send_logs("Call symbol is "+ callsymbol+" and quantity is "+ str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    take_logs("Total pnl is " + str(round(pnl, 1)), filename)
    print("Total pnl is " + str(round(pnl, 1)))

    return round(pnl, 1)


def MONITOR_NIFTY_STRADDLE(producttype, filename):
    take_logs("IN MONITOR_NIFTY_STRADDLE", filename)

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    # take_logs("In monitor moving strangle bn")

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += int(quantity)
    pnl = 0
    # pprint(symbol_dict)
    # ppp.set_trace()
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            # send_logs("Call symbol is "+ callsymbol+" and quantity is "+ str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    take_logs("Total pnl is " + str(round(pnl, 1)), filename)
    print("Total pnl is " + str(round(pnl, 1)))

    return round(pnl, 1)


def MONITOR_NIFTY_MOVING_STRADDLE(producttype, filename):
    take_logs("IN MONITOR_NIFTY_MOVING_STRADDLE", filename)

    # global order_index, txn_type_index, symbol_index, quantity_index, price_index

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    # call_diff=200
    # put_diff=250

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    pprint(symbol_dict)
    # print("Step 4")
    send_logs("Total pnl is " + str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = 45
        call_min_range = -45
        put_max_range = 45
        put_min_range = -45
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 450
        # put_min_range = 350
        call_max_range = 45
        call_min_range = -45
        put_max_range = 45
        put_min_range = -45
    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 400
        # put_min_range = 300
        call_max_range = 45
        call_min_range = -45
        put_max_range = 45
        put_min_range = -45
    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        # call_max_range = 350
        # call_min_range =250
        # put_max_range = 400
        # put_min_range = 300
        # call_max_range =555
        # call_min_range =450
        # put_max_range =605
        # put_min_range = 500

        call_max_range = 45
        call_min_range = -45
        put_max_range = 45
        put_min_range = -45

    elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
        # call_max_range = 500
        # call_min_range =400
        # put_max_range = 550
        # put_min_range = 450

        call_max_range = 45
        call_min_range = -45
        put_max_range = 45
        put_min_range = -45

    else:  # saturday and sunday for testing Start with a delta neutral 250/300 point strangle
        call_max_range = 45
        call_min_range = -45
        put_max_range = 45
        put_min_range = -45

    nifty_cur_price = weekly_nifty_future()

    if (callsymbol == "" and putsymbol == ""):
        send_logs("Found No Positions to Monitor...Exiting!!")
        return 0
    else:
        callstrike = nifty_symbol_to_strike(callsymbol)
        putstrike = nifty_symbol_to_strike(putsymbol)

        put_diff = nifty_cur_price - putstrike
        call_diff = callstrike - nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            put_strike_up_moving_strangle(putstrike, abs(putquantity), producttype, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            put_strike_down_moving_strangle(putstrike, abs(putquantity), producttype, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            call_strike_down_moving_strangle(callstrike, abs(callquantity), producttype, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            call_strike_up_moving_strangle(callstrike, abs(callquantity), producttype, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return pnl


def monitor_nifty_moving_strangle_with_delta(product_type, call_diff, put_diff):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        elif (type == 'SLL'):
            continue
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0
    # pprint(symbol_dict)
    print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            print("Call symbol and quantity is", callsymbol, callquantity)

    pprint(symbol_dict)
    print("Step 4")
    print("Total pnl is ", round(pnl, 1))

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = 280
        call_min_range = 170
        put_max_range = 350
        put_min_range = 205
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        # call_max_range = 550
        # call_min_range =450
        # put_max_range = 550
        # put_min_range = 450
        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 400
        # put_min_range = 300
        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        # call_max_range = 350
        # call_min_range =250
        # put_max_range = 400
        # put_min_range = 300
        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    elif (curday == 2):  # Wednesday - Start with a delta neutral 250/300 point strangle
        # call_max_range = 500
        # call_min_range =400
        # put_max_range = 550
        # put_min_range = 450
        call_max_range = call_diff + 50
        call_min_range = call_diff - 50
        put_max_range = put_diff + 50
        put_min_range = put_diff - 50

    nifty_cur_price = weekly_nifty_future()

    if (callsymbol == "" and putsymbol == ""):
        print("Found No Positions to Monitor...Exiting!!")
        return 0
    else:
        callstrike = nifty_symbol_to_strike(callsymbol)
        putstrike = nifty_symbol_to_strike(putsymbol)

        put_diff = nifty_cur_price - putstrike
        call_diff = callstrike - nifty_cur_price

        if (put_diff > put_max_range):
            time.sleep(5)
            nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
            put_diff = nifty_cur_price - putstrike
            if (put_diff > put_max_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Up")
                put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type)
        elif (put_diff < put_min_range):
            time.sleep(5)
            nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
            if (put_diff < put_min_range):
                print("Put Strike Diff is ", int(put_diff), "Moving Puts Down")
                put_strike_down_moving_strangle(putstrike, abs(putquantity), product_type)
        else:
            print("Put Strike Diff is ", int(put_diff), "Nothing to do right now !!")
            print("Will Move Puts Up At ", putstrike + put_max_range)
            print("Will Move Puts Down At ", putstrike + put_min_range)

        if (call_diff > call_max_range):
            time.sleep(5)
            nifty_cur_price = weekly_nifty_future()
            call_diff = callstrike - nifty_cur_price
            if (call_diff > call_max_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Down")
                call_strike_down_moving_strangle(callstrike, abs(callquantity), product_type)
        elif (call_diff < call_min_range):
            time.sleep(5)
            nifty_cur_price = kite.ltp('NSE:NIFTY 50')['NSE:NIFTY 50']['last_price']
            call_diff = callstrike - nifty_cur_price
            if (call_diff < call_min_range):
                print("Call Strike Diff is ", int(call_diff), "Moving Calls Up")
                call_strike_up_moving_strangle(callstrike, abs(callquantity), product_type)
        else:
            print("Call Strike Diff is ", int(call_diff), "Nothing to do right now !!")
            print("Will Move Calls Up At ", callstrike - call_min_range)
            print("Will Move Calls Down At ", callstrike - call_max_range)

    return pnl


def monitor_symbol_moving_strangle_with_delta_multiple_firstock(product_type, call_diff, put_diff,
                                                                filename, expiry_name="nifty",
                                                                firstock_testing_mode=False):  # Based on Orderid
    """

    :param product_type: 'NRML' , 'MIS' from Zerodha
    :param call_diff: INT , Ex: 300, 200 etc
    :param put_diff: INT , Ex: 300, 200 etc
    :param filename: Orders file to save orders to.
    :param expiry_name: STRING - "nifty", "banknifty", "sensex", "finnifty", "midcap"
    :param firstock_testing_mode: BOOLEAN - TRUE, FALSE
    :return: current pnl of running position
    """

    global order_index, txn_type_index, symbol_index, quantity_index, price_index, success_status_firstock

    if firstock_testing_mode:
        success_status_firstock = 'REJECTED'
    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = int(processed_order_data[i][quantity_index])
        symbol_avg_price = processed_order_data[i][price_index]
        # print("sold price of symbol : " + symbol + " is: "+str(symbol_avg_price))
        # print("LTP for symbol : " + symbol + " is: "+str(last_price_firstock(symbol)))

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")

    symbol_exchange = "NFO"
    if expiry_name == "sensex":
        symbol_exchange = "BFO"
    else:
        symbol_exchange = "NFO"

    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        try:
            symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                    quantity * last_price_firstock(symbol, symbol_exchange))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        except Exception as e:
            time.sleep(0.5)
            symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                    quantity * last_price_firstock(symbol, symbol_exchange))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        # Instrument_type : C or CE , P or PE
        if expiry_name == "sensex":
            instrument_type = symbol[-2:]
        else:
            instrument_type = symbol[-6:-5]

        # if quantity < 0 and (symbol[-6:-5] == 'P'):
        #     putsymbol = symbol
        #     putquantity = int(quantity)
        # elif quantity < 0 and (symbol[-6:-5] == 'C'):
        #     callsymbol = symbol
        #     callquantity = int(quantity)
        #     send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

        if quantity < 0 and (instrument_type == 'P' or instrument_type == 'PE'):
            putsymbol = symbol
            putquantity = int(quantity)
            send_logs("Put symbol is " + putsymbol + " and quantity is " + str(putquantity))
        elif quantity < 0 and (instrument_type == 'C' or instrument_type == 'CE'):
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly(expiry_name)

    if expiry_name == "sensex":
        diff_plus = 200
        diff_minus = 100
    elif expiry_name == "nifty":
        diff_plus = 46
        diff_minus = 46
    elif expiry_name == "banknifty":
        diff_plus = 200
        diff_minus = 100
    elif expiry_name == "midcap":
        diff_plus = 50
        diff_minus = 25
    elif expiry_name == "finnifty":
        diff_plus = 46
        diff_minus = 46
    else:
        send_logs("Wrong input expiry_name recieved, returning none!")
        return None

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 446
        # put_min_range = 346
        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 400
        # put_min_range = 300
        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        # call_max_range = 346
        # call_min_range =246
        # put_max_range = 400
        # put_min_range = 300
        # call_max_range =555
        # call_min_range =446
        # put_max_range =605
        # put_min_range = 460

        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        # call_max_range = 460
        # call_min_range =400
        # put_max_range = 546
        # put_min_range = 446

        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    symbol_cur_price = weekly_future_using_firstock(expiry_name)
    send_logs(f"CURRENTLY {expiry_name} IS AT: " + str(symbol_cur_price))

    ########## Define Move Up strike for each symbol ##########
    strike_adjustment = 0
    if expiry_name == "nifty":
        strike_adjustment = 50  # pts
    elif expiry_name == "banknifty":
        strike_adjustment = 200  # pts
    elif expiry_name == "finnifty":
        strike_adjustment = 50  # pts
    elif expiry_name == "sensex":
        strike_adjustment = 200  # pts
    elif expiry_name == "midcap":
        strike_adjustment = 50  # pts

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        # callstrike = nifty_symbol_to_strike_firstock(callsymbol)
        # putstrike = nifty_symbol_to_strike_firstock(putsymbol)

        callstrike = symbol_to_strike_firstock(callsymbol, expiry_name)
        putstrike = symbol_to_strike_firstock(putsymbol, expiry_name)

        put_diff = symbol_cur_price - putstrike
        call_diff = callstrike - symbol_cur_price

        if put_diff < put_max_range and put_diff > put_min_range:
            send_logs("Put Diff is in range, no action needed!!!" + " Put_Min_Range: " + str(
                put_min_range) + " < PutDiff: " + str(put_diff) + " < Put_max_range: " + str(put_max_range))

        if put_diff > put_max_range:
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            put_strike_up_moving_strangle_firstock_v2(strike_adjustment, putstrike, abs(putquantity), "product_type",
                                                      filename, expiry_name)
        elif put_diff < put_min_range:
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            put_strike_down_moving_strangle_firstock_v2(strike_adjustment, putstrike, abs(putquantity), "product_type",
                                                        filename, expiry_name)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if call_diff > call_max_range:
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + " Moving Calls Down")
            call_strike_down_moving_strangle_firstock_v2(strike_adjustment, callstrike, abs(callquantity),
                                                         "product_type", filename, expiry_name)
        elif call_diff < call_min_range:
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + " Moving Calls Up")
            call_strike_up_moving_strangle_firstock_v2(strike_adjustment, callstrike, abs(callquantity), "product_type",
                                                       filename, expiry_name)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


# TODO Debug this
def monitor_nifty_moving_strangle_with_delta_multiple_firstock(product_type, call_diff, put_diff,
                                                               filename):  # Based on Orderid
    """

    :param product_type: 'NRML' , 'MIS' from Zerodha
    :param call_diff: INT , Ex: 300, 200 etc
    :param put_diff: INT , Ex: 300, 200 etc
    :param filename: Orders file to save orders to.
    :return: current pnl of running position
    """
    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]
        # print("sold price of symbol : " + symbol + " is: "+str(symbol_avg_price))
        # print("LTP for symbol : " + symbol + " is: "+str(last_price_firstock(symbol)))

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        try:
            symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                    quantity * last_price_firstock(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)
        except Exception as e:
            time.sleep(0.5)
            symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                    quantity * last_price_firstock(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol[-6:-5] == 'P':
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol[-6:-5] == 'C':
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly()

    diff_plus = 46
    diff_minus = 46
    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 446
        # put_min_range = 346
        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 400
        # put_min_range = 300
        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        # call_max_range = 346
        # call_min_range =246
        # put_max_range = 400
        # put_min_range = 300
        # call_max_range =555
        # call_min_range =446
        # put_max_range =605
        # put_min_range = 460

        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        # call_max_range = 460
        # call_min_range =400
        # put_max_range = 546
        # put_min_range = 446

        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + diff_plus
        call_min_range = call_diff - diff_minus
        put_max_range = put_diff + diff_plus
        put_min_range = put_diff - diff_minus

    nifty_cur_price = weekly_nifty_future_using_firstock()
    send_logs("CURRENTLY NIFTY IS AT: " + str(nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = nifty_symbol_to_strike_firstock(callsymbol)
        putstrike = nifty_symbol_to_strike_firstock(putsymbol)

        put_diff = nifty_cur_price - putstrike
        call_diff = callstrike - nifty_cur_price

        if put_diff < put_max_range and put_diff > put_min_range:
            send_logs("Put Diff is in range, no action needed!!!" + " Put_Min_Range: " + str(
                put_min_range) + " < PutDiff: " + str(put_diff) + " < Put_max_range: " + str(put_max_range))

        if put_diff > put_max_range:
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            put_strike_up_moving_strangle_firstock(putstrike, abs(putquantity), product_type, filename)
        elif put_diff < put_min_range:
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            put_strike_down_moving_strangle_firstock(putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if call_diff > call_max_range:
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + " Moving Calls Down")
            call_strike_down_moving_strangle_firstock(callstrike, abs(callquantity), product_type, filename)
        elif call_diff < call_min_range:
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + " Moving Calls Up")
            call_strike_up_moving_strangle_firstock(callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_nifty_moving_strangle_with_delta_multiple(product_type, call_diff, put_diff, filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 446
        # put_min_range = 346
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 400
        # put_min_range = 300
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        # call_max_range = 346
        # call_min_range =246
        # put_max_range = 400
        # put_min_range = 300
        # call_max_range =555
        # call_min_range =446
        # put_max_range =605
        # put_min_range = 460

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        # call_max_range = 460
        # call_min_range =400
        # put_max_range = 546
        # put_min_range = 446

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    nifty_cur_price = weekly_nifty_future()
    send_logs("CURRENTLY NIFTY IS AT: " + str(nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = nifty_symbol_to_strike(callsymbol)
        putstrike = nifty_symbol_to_strike(putsymbol)

        put_diff = nifty_cur_price - putstrike
        call_diff = callstrike - nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            put_strike_up_moving_strangle(putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            put_strike_down_moving_strangle(putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            call_strike_down_moving_strangle(callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            call_strike_up_moving_strangle(callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


# expected input format: NIFTY2380319200PE, 100, 'NRML', ordersfile
def sell_and_write_option(strike_symbol, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    f = open(filename, "a")  # Append mode

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=strike_symbol, type="SELL", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "SELL" + "\t" + strike_symbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "SELL" + "\t" + strike_symbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")


# expected input format: NIFTY2380319200PE, 100, 'NRML', ordersfile
def buy_and_write_option(strike_symbol, quantity, product_type, filename):
    curdate = datetime.datetime.today()
    f = open(filename, "a")  # Append mode

    curtime = datetime.datetime.now()
    orderid = execute_order(symbol=strike_symbol, type="BUY", quant=quantity, price=None, trig_price=None,
                            product=product_type)
    time.sleep(0.3)
    order = fetch_order(orderid)
    if (order['status'] == 'COMPLETE'):
        f.write(str(orderid) + "\t" + "BUY" + "\t" + strike_symbol + "\t" + str(quantity) + "\t" + str(
            order['average_price']) + "\t" + str(curtime) + "\n")
    else:
        time.sleep(2)
        if (order['status'] == 'COMPLETE'):
            f.write(str(orderid) + "\t" + "BUY" + "\t" + strike_symbol + "\t" + str(quantity) + "\t" + str(
                order['average_price']) + "\t" + str(curtime) + "\n")
        else:
            send_logs("Something Wrong with Order CHeck Now")


# It is a given that orders file has positions. So, we dont need to check that

def check_sell_additional_quantity_anyIndex(filename, newQuantity, product_type):
    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []
    quantity_being_traded = 0
    for i in range(num_orders):
        processed_order_data.append(order_data[i].split('\t'))
        quantity_being_traded = processed_order_data[i][quantity_index]

    if int(quantity_being_traded) == newQuantity:
        print("Same quantity, no need updation")
        return
    else:

        orderid = 0
        newsymbol = 0
        for i in range(
                num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
            processed_order_data.append(order_data[i].split('\t'))
            # send_logs("Data fetched from file is- \n" )
            # psend_logs(processed_order_data)
        symbol_dict = {}

        for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
            symbol = processed_order_data[i][symbol_index]
            if (symbol in symbol_dict.keys()):
                pass  # Do Nothing equivalent in python
            else:  # Add symbol to dictionary
                symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

        for i in range(num_orders):  # PNL Calculation
            BuySellValue = 0  # persymbol
            type = processed_order_data[i][txn_type_index]
            symbol = processed_order_data[i][symbol_index]  # fetch symbol
            quantity = processed_order_data[i][quantity_index]
            symbol_avg_price = processed_order_data[i][price_index]

            if (type == 'SELL'):
                quantity = (int(quantity) * -1)
            elif (type == 'BUY'):
                quantity = int(quantity)
            # send_logs(symbol_list)

            BuySellValue += (int(quantity) * float(symbol_avg_price))

            symbol_dict[symbol][1] += BuySellValue
            symbol_dict[symbol][0] += quantity

        #         f.write(str(orderid) + "\t" + "SELL" + "\t" + newsymbol + "\t" + str(newQuantity) + "\t" + str(
        #             order['average_price']) + "\t" + str(curtime) + "\n")

        # clear the previous file being managed, write new positions and sell/ buy the difference of shares hence forth
        open(filename, 'w').close()

        for symbol_ in symbol_dict:
            symbol_quantity = symbol_dict[symbol_][0]
            difference_quantity = symbol_quantity + newQuantity  # symbol_quantity is negative

            if symbol_quantity > 0:
                # sell difference in units of that symbol
                # write the new sold quantity = newQuantity to file with symbol and data
                f = open(filename, "a")  # Append mode

                curtime = datetime.datetime.now()
                orderid = execute_order(symbol=symbol_, type="SELL", quant=difference_quantity, price=None,
                                        trig_price=None,
                                        product=product_type)
                time.sleep(0.3)
                order = fetch_order(orderid)
                if (order['status'] == 'COMPLETE'):
                    f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol_ + "\t" + str(newQuantity) + "\t" + str(
                        order['average_price']) + "\t" + str(curtime) + "\n")
                else:
                    time.sleep(2)
                    if (order['status'] == 'COMPLETE'):
                        f.write(str(orderid) + "\t" + "SELL" + "\t" + symbol_ + "\t" + str(newQuantity) + "\t" + str(
                            order['average_price']) + "\t" + str(curtime) + "\n")
                    else:
                        send_logs("Something Wrong with Order CHeck Now")
            elif symbol_quantity < 0:
                # buy difference in units of that symbol
                # write the new sold quantity = newQuantity to file with symbol and data
                curdate = datetime.datetime.today()
                f = open(filename, "a")  # Append mode

                curtime = datetime.datetime.now()
                orderid = execute_order(symbol=symbol_, type="BUY", quant=difference_quantity, price=None,
                                        trig_price=None,
                                        product=product_type)
                time.sleep(0.3)
                order = fetch_order(orderid)
                if (order['status'] == 'COMPLETE'):
                    f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol_ + "\t" + str(newQuantity) + "\t" + str(
                        order['average_price']) + "\t" + str(curtime) + "\n")
                else:
                    time.sleep(2)
                    if (order['status'] == 'COMPLETE'):
                        f.write(str(orderid) + "\t" + "BUY" + "\t" + symbol_ + "\t" + str(newQuantity) + "\t" + str(
                            order['average_price']) + "\t" + str(curtime) + "\n")
                    else:
                        send_logs("Something Wrong with Order CHeck Now")

        return


def monitor_fin_nifty_moving_strangle_with_delta_multiple(product_type, call_diff, put_diff,
                                                          filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # send_logs("Data fetched from file is- \n" )
    # psend_logs(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # send_logs(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # psend_logs(symbol_dict)
    # send_logs("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # psend_logs(symbol_dict)
    # send_logs("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 446
        # put_min_range = 346
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 400
        # put_min_range = 300
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        # call_max_range = 346
        # call_min_range =246
        # put_max_range = 400
        # put_min_range = 300
        # call_max_range =555
        # call_min_range =446
        # put_max_range =605
        # put_min_range = 460

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        # call_max_range = 460
        # call_min_range =400
        # put_max_range = 546
        # put_min_range = 446

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    fin_nifty_cur_price = weekly_finnifty_future()
    send_logs("CURRENTLY FIN NIFTY IS AT: " + str(fin_nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = fin_nifty_symbol_to_strike(callsymbol)
        putstrike = fin_nifty_symbol_to_strike(putsymbol)

        put_diff = fin_nifty_cur_price - putstrike
        call_diff = callstrike - fin_nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            put_strike_up_moving_strangle_fin_nifty(putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            put_strike_down_moving_strangle_fin_nifty(putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            call_strike_down_moving_strangle_fin_nifty(callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            call_strike_up_moving_strangle_fin_nifty(callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_nifty_moving_strangle_with_delta_multiple_times(product_type, call_diff, put_diff,
                                                            filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 446
        # put_min_range = 346
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        # call_max_range = 400
        # call_min_range =300
        # put_max_range = 400
        # put_min_range = 300
        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        # call_max_range = 346
        # call_min_range =246
        # put_max_range = 400
        # put_min_range = 300
        # call_max_range =555
        # call_min_range =446
        # put_max_range =605
        # put_min_range = 460

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        # call_max_range = 460
        # call_min_range =400
        # put_max_range = 546
        # put_min_range = 446

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 46
        call_min_range = call_diff - 46
        put_max_range = put_diff + 46
        put_min_range = put_diff - 46

    nifty_cur_price = weekly_nifty_future()

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = nifty_symbol_to_strike(callsymbol)
        putstrike = nifty_symbol_to_strike(putsymbol)

        put_diff = nifty_cur_price - putstrike
        call_diff = callstrike - nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            put_strike_up_moving_strangle_multiple_times(putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            put_strike_down_moving_strangle_multiple_times(putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            call_strike_down_moving_strangle_multiple_times(callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            call_strike_up_moving_strangle_multiple_times(callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_bank_nifty_moving_strangle_with_delta_multiple_v2(product_type, call_diff, put_diff,
                                                              filename, expiry_name="banknifty"):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    print(symbol_dict)
    print(symbol_dict)

    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly_for_symbol_zerodha(expiry_name)

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    bank_nifty_cur_price = synthetic_symbol_future(expiry_name)
    send_logs("CURRENTLY BANK NIFTY FUTURE IS AT: " + str(bank_nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = banknifty_symbol_to_strike(callsymbol)
        putstrike = banknifty_symbol_to_strike(putsymbol)

        put_diff = bank_nifty_cur_price - putstrike
        call_diff = callstrike - bank_nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            bank_put_strike_up_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            bank_put_strike_down_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + " Moving Calls Down")
            bank_call_strike_down_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + " Moving Calls Up")
            # print("call quantity is : "+ str(callquantity))
            bank_call_strike_up_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_bank_nifty_moving_strangle_with_delta_multiple(product_type, call_diff, put_diff,
                                                           filename, expiry_name="banknifty"):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    print(symbol_dict)
    print(symbol_dict)

    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly_for_symbol_zerodha(expiry_name)

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    bank_nifty_cur_price = synthetic_symbol_future(expiry_name)
    send_logs("CURRENTLY BANK NIFTY FUTURE IS AT: " + str(bank_nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = banknifty_symbol_to_strike(callsymbol)
        putstrike = banknifty_symbol_to_strike(putsymbol)

        put_diff = bank_nifty_cur_price - putstrike
        call_diff = callstrike - bank_nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            bank_put_strike_up_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            bank_put_strike_down_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + " Moving Calls Down")
            bank_call_strike_down_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + " Moving Calls Up")
            # print("call quantity is : "+ str(callquantity))
            bank_call_strike_up_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_bank_nifty_moving_strangle_with_delta_multiple_test(iterator, product_type, call_diff, put_diff,
                                                                filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    if iterator < 5:
        bank_nifty_cur_price = 44910
    elif iterator < 7:
        bank_nifty_cur_price = 44890
    elif iterator < 10:
        bank_nifty_cur_price = 44799
    elif iterator < 11:
        bank_nifty_cur_price = 44910
    elif iterator < 14:
        bank_nifty_cur_price = 45010
    elif iterator < 16:
        bank_nifty_cur_price = 45210
    else:
        bank_nifty_cur_price = 45050

    # send_logs("CURRENTLY NIFTY IS AT: " + str(nifty_cur_price))

    # bank_nifty_cur_price = weekly_banknifty_future()
    send_logs("CURRENTLY BANK NIFTY FUTURE IS AT: " + str(bank_nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = banknifty_symbol_to_strike(callsymbol)
        putstrike = banknifty_symbol_to_strike(putsymbol)

        put_diff = bank_nifty_cur_price - putstrike
        call_diff = callstrike - bank_nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            bank_put_strike_up_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            bank_put_strike_down_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            bank_call_strike_down_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            bank_call_strike_up_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_bank_nifty_moving_strangle_with_delta_multiple_using_firstock(product_type, call_diff, put_diff,
                                                                          filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price_of_zerodha_symbol_using_firstock(symbol,
                                                                       "bn"))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    # is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    bank_nifty_cur_price = weekly_banknifty_future_using_firstock()
    send_logs("CURRENTLY BANK NIFTY FUTURE IS AT: " + str(bank_nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = banknifty_symbol_to_strike(callsymbol)
        putstrike = banknifty_symbol_to_strike(putsymbol)

        put_diff = bank_nifty_cur_price - putstrike
        call_diff = callstrike - bank_nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            bank_put_strike_up_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            bank_put_strike_down_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            bank_call_strike_down_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            bank_call_strike_up_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_nifty_moving_strangle_with_delta_multiple_using_firstock(product_type, call_diff, put_diff,
                                                                     filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price_of_zerodha_symbol_using_firstock(symbol,
                                                                       "nifty"))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    # is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    nifty_cur_price = weekly_nifty_future_using_firstock()
    send_logs("CURRENTLY NIFTY FUTURE IS AT: " + str(nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = nifty_symbol_to_strike(callsymbol)
        putstrike = nifty_symbol_to_strike(putsymbol)

        put_diff = nifty_cur_price - putstrike
        call_diff = callstrike - nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            nifty_nifty_put_strike_up_moving_strangle(100, putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            nifty_nifty_put_strike_down_moving_strangle(100, putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            nifty_nifty_call_strike_down_moving_strangle(100, callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            nifty_nifty_call_strike_up_moving_strangle(100, callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_midcap_nifty_moving_strangle_with_delta_multiple(product_type, call_diff, put_diff,
                                                             filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    # is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 2):  # Expiry Day - Thursday
        call_max_range = call_diff + 50
        call_min_range = call_diff - 25
        put_max_range = put_diff + 50
        put_min_range = put_diff - 25
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = call_diff + 50
        call_min_range = call_diff - 25
        put_max_range = put_diff + 50
        put_min_range = put_diff - 25
    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 50
        call_min_range = call_diff - 25
        put_max_range = put_diff + 50
        put_min_range = put_diff - 25
    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 50
        call_min_range = call_diff - 25
        put_max_range = put_diff + 50
        put_min_range = put_diff - 25
    elif (curday == 3):  # Wednesday - Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 50
        call_min_range = call_diff - 25
        put_max_range = put_diff + 50
        put_min_range = put_diff - 25
    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 50
        call_min_range = call_diff - 25
        put_max_range = put_diff + 50
        put_min_range = put_diff - 25

    midcap_nifty_cur_price = weekly_midcap_nifty_future()
    send_logs("CURRENTLY MICAP NIFTY FUTURE IS AT: " + str(midcap_nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = midcap_nifty_symbol_to_strike(callsymbol)
        putstrike = midcap_nifty_symbol_to_strike(putsymbol)

        put_diff = midcap_nifty_cur_price - putstrike
        call_diff = callstrike - midcap_nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            midcap_nifty_put_strike_up_moving_strangle(50, putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            midcap_nifty_put_strike_down_moving_strangle(50, putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            midcap_nifty_call_strike_down_moving_strangle(50, callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            midcap_nifty_call_strike_up_moving_strangle(50, callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_sensex_moving_strangle_with_delta_multiple(product_type, call_diff, put_diff, filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price_sensex(symbol))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    # is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 2):  # Expiry Day - Thursday
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
    elif (curday == 3):  # Wednesday - Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100
    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 200
        call_min_range = call_diff - 100
        put_max_range = put_diff + 200
        put_min_range = put_diff - 100

    sensex_cur_price = weekly_sensex_future()
    send_logs("CURRENTLY MICAP NIFTY FUTURE IS AT: " + str(sensex_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        # return 0.0
    else:
        callstrike = sensex_symbol_to_strike(callsymbol)
        putstrike = sensex_symbol_to_strike(putsymbol)

        put_diff = sensex_cur_price - putstrike
        call_diff = callstrike - sensex_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            sensex_put_strike_up_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            sensex_put_strike_down_moving_strangle(200, putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            sensex_call_strike_down_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            sensex_call_strike_up_moving_strangle(200, callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)


def monitor_fin_nifty_moving_strangle_with_delta_multiple_using_firstock(product_type, call_diff, put_diff,
                                                                         filename):  # Based on Orderid

    global order_index, txn_type_index, symbol_index, quantity_index, price_index

    callsymbol = ""
    putsymbol = ""

    curtime = datetime.datetime.now()
    cur_hour = curtime.hour
    curdate = datetime.datetime.today()
    curday = curdate.weekday()

    # filename = curdate.strftime("%d") + curdate.strftime("%m") + curdate.strftime("%y") + "MovingStrangle.txt"
    f = open(filename, "r")  # Append mode
    filedata = f.read()
    f.close()

    order_data = filedata.splitlines()
    num_orders = len(order_data)
    processed_order_data = []

    for i in range(num_orders):  # Processes Data fetched from file and stores it as a 2D array in processed_order_data
        processed_order_data.append(order_data[i].split('\t'))
    # print("Data fetched from file is- \n" )
    # pprint(processed_order_data)
    symbol_dict = {}

    for i in range(num_orders):  # Here a dictionary of all symbols found in orders is created
        symbol = processed_order_data[i][symbol_index]
        if (symbol in symbol_dict.keys()):
            pass  # Do Nothing equivalent in python
        else:  # Add symbol to dictionary
            symbol_dict[symbol] = [0, 0, 0]  # quantity, BuySellValue,pnl

    for i in range(num_orders):  # PNL Calculation
        BuySellValue = 0  # persymbol
        type = processed_order_data[i][txn_type_index]
        symbol = processed_order_data[i][symbol_index]  # fetch symbol
        quantity = processed_order_data[i][quantity_index]
        symbol_avg_price = processed_order_data[i][price_index]

        if (type == 'SELL'):
            quantity = (int(quantity) * -1)
        elif (type == 'BUY'):
            quantity = int(quantity)
        # print(symbol_list)

        BuySellValue += (int(quantity) * float(symbol_avg_price))

        symbol_dict[symbol][1] += BuySellValue
        symbol_dict[symbol][0] += quantity
    pnl = 0.0
    # pprint(symbol_dict)
    # print("Step 3")
    for symbol in symbol_dict:  # Calculates Total PNL and Finds our current SELL Legs
        quantity = symbol_dict[symbol][0]
        symbol_dict[symbol][2] = (symbol_dict[symbol][1] * -1) + (
                quantity * last_price_of_zerodha_symbol_using_firstock(symbol,
                                                                       "fin_nifty"))  # symbolpnl = BuySellValue+ (Quantity*LTP)

        pnl += symbol_dict[symbol][2]

        if quantity < 0 and symbol.find('PE') > 0:
            putsymbol = symbol
            putquantity = int(quantity)
        elif quantity < 0 and symbol.find('CE') > 0:
            callsymbol = symbol
            callquantity = int(quantity)
            send_logs("Call symbol is " + callsymbol + " and quantity is " + str(callquantity))

    # pprint(symbol_dict)
    # print("Step 4")
    # send_logs("Total pnl is "+str(round(pnl, 1)))

    # is_weekly_expiry = is_cur_expiry_weekly()

    if (curday == 3):  # Expiry Day - Thursday
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50
        # if(cur_hour>=9 and cur_hour<=11 ): #Start with a 250 or 300 point delta neutral strangle
        # call_max_range = call_diff+50
        # call_min_range =call_diff-50
        # put_max_range = put_diff+50
        # put_min_range = put_diff-50
        # elif(cur_hour==12 or cur_hour==13 ):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
        # elif((cur_hour==14 or cur_hour==15) and is_weekly_expiry==True):
        # call_max_range = call_diff+46
        # call_min_range =call_diff-46
        # put_max_range = put_diff+46
        # put_min_range = put_diff-46
    elif (curday == 4):  # Friday - Start with a delta neutral 350 point strangle
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    elif (curday == 0):  # Monday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    elif (curday == 1):  # Tuesday - Start with a delta neutral 250 point strangle
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    elif (curday == 2):  # Wednesday - Start with a delta neutral 246/300 point strangle
        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    else:  # saturday and sunday for testing Start with a delta neutral 246/300 point strangle

        call_max_range = call_diff + 100
        call_min_range = call_diff - 50
        put_max_range = put_diff + 100
        put_min_range = put_diff - 50

    fin_nifty_cur_price = weekly_fin_nifty_future_using_firstock()
    send_logs("CURRENTLY FIN NIFTY FUTURE IS AT: " + str(fin_nifty_cur_price))

    if (callsymbol == "" and putsymbol == ""):
        send_logs("PLEASE TAKE SOME POSITIONS")
        return 0.0
    else:
        callstrike = fin_nifty_symbol_to_strike(callsymbol)
        putstrike = fin_nifty_symbol_to_strike(putsymbol)

        put_diff = fin_nifty_cur_price - putstrike
        call_diff = callstrike - fin_nifty_cur_price

        if (put_diff > put_max_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Up")
            fin_nifty_nifty_put_strike_up_moving_strangle(100, putstrike, abs(putquantity), product_type, filename)
        elif (put_diff < put_min_range):
            # time.sleep(5)
            send_logs("Put Strike Diff is " + str(put_diff) + " Moving Puts Down")
            fin_nifty_nifty_put_strike_down_moving_strangle(100, putstrike, abs(putquantity), product_type, filename)
        else:
            send_logs("Put Strike Diff is " + str(put_diff) + " Nothing to do right now !!")
            send_logs("Will Move Puts Up At " + str(putstrike + put_max_range))
            send_logs("Will Move Puts Down At " + str(putstrike + put_min_range))

        if (call_diff > call_max_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Down")
            fin_nifty_nifty_call_strike_down_moving_strangle(100, callstrike, abs(callquantity), product_type, filename)
        elif (call_diff < call_min_range):
            # time.sleep(5)
            send_logs("Call Strike Diff is " + str(call_diff) + "Moving Calls Up")
            fin_nifty_nifty_call_strike_up_moving_strangle(100, callstrike, abs(callquantity), product_type, filename)
        else:
            send_logs("Call Strike Diff is " + str(call_diff) + " Nothing to do right now !!")
            send_logs("Will Move Calls Up At " + str(callstrike - call_min_range))
            send_logs("Will Move Calls Down At " + str(callstrike - call_max_range))

    return round(pnl, 1)
